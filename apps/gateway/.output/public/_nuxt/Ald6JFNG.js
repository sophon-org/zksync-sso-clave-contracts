import {
  P as A,
  A as D,
  r as de,
  a0 as ec,
  d as ee,
  N as Et,
  t as F,
  a5 as Fn,
  S as Fo,
  Y as gr,
  a3 as ie,
  a4 as it,
  v as j,
  M as J,
  V as Ja,
  L as Ka,
  B as le,
  U as Lo,
  Z as Mo,
  x as N,
  a6 as nc,
  y as ne,
  O as No,
  $ as Oo,
  K as Qa,
  z as R,
  a7 as rc,
  a8 as sc,
  T as So,
  a2 as tc,
  a1 as Te,
  G as ut,
  Q as we,
  W as Xa,
  _ as xe,
  o as Ya,
  R as Yr,
  i as Z,
  X as zo,
} from "./C6uzYG6W.js";

const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f || (m.f = ["./CntDG-S9.js", "./C6uzYG6W.js", "./entry.Cm8MqiX4.css"]),
) => i.map((i) => d[i]);
const Za = Object.defineProperty;
const Wa = (e, t, n) =>
  t in e
    ? Za(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
const He = (e, t, n) => Wa(e, typeof t != "symbol" ? t + "" : t, n);
const oc = {},
  ic = {
    viewBox: "0 0 160 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
  },
  ac = Ka(
    '<g clip-path="url(#clip0_2308_2426)"><path fill-rule="evenodd" clip-rule="evenodd" d="M55.5386 15.7054L39.7838 0.0057373V11.5034L24.1407 23.0153L39.7838 23.0261V31.405L55.5386 15.7054Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M-0.00213623 15.6997L15.7526 31.3993V19.9941L31.3958 8.38965L15.7526 8.37891V0L-0.00213623 15.6997Z" fill="currentColor"></path><path d="M79.0115 23.5456H66.9531V20.0828L73.8563 12.3879H67.131V8.98425H78.893V12.2695L71.7825 20.1124H79.0115V23.5456Z" fill="currentColor"></path><path d="M95.4678 8.98435L89.6313 15.1108L95.5864 23.5457H90.757L86.9056 17.9816L85.276 19.6981V23.5457H81.3356V2.11804H85.276V14.4005L90.3126 8.98435H95.4678Z" fill="currentColor"></path><path d="M112.606 7.56374L108.932 8.68839C108.794 7.93861 108.419 7.25791 107.807 6.64626C107.194 6.0346 106.296 5.72878 105.11 5.72878C104.143 5.72878 103.353 5.99514 102.74 6.52787C102.128 7.04087 101.822 7.66239 101.822 8.39243C101.822 9.67492 102.582 10.4641 104.103 10.7601L107.036 11.3225C108.893 11.6776 110.335 12.4174 111.362 13.5421C112.389 14.6668 112.902 15.9888 112.902 17.508C112.902 19.2444 112.211 20.7636 110.829 22.0658C109.466 23.3484 107.629 23.9896 105.318 23.9896C103.995 23.9896 102.8 23.7922 101.733 23.3977C100.666 23.003 99.8071 22.4802 99.1554 21.829C98.5035 21.1582 97.9901 20.4578 97.6147 19.7277C97.2593 18.978 97.0419 18.2085 96.963 17.4193L100.755 16.413C100.854 17.5376 101.289 18.4749 102.059 19.2246C102.849 19.9744 103.945 20.3493 105.348 20.3493C106.414 20.3493 107.244 20.1125 107.836 19.6389C108.448 19.1654 108.755 18.5438 108.755 17.7744C108.755 17.1628 108.528 16.6398 108.073 16.2058C107.639 15.752 107.016 15.4462 106.207 15.2884L103.274 14.6964C101.575 14.3413 100.232 13.6408 99.2443 12.595C98.2567 11.5493 97.7629 10.2471 97.7629 8.68839C97.7629 6.83369 98.4739 5.27496 99.8961 4.0122C101.338 2.74943 103.066 2.11804 105.081 2.11804C106.286 2.11804 107.362 2.28576 108.31 2.62119C109.258 2.9566 110.019 3.41042 110.592 3.9826C111.164 4.53507 111.609 5.10726 111.925 5.69918C112.241 6.2911 112.468 6.91262 112.606 7.56374Z" fill="currentColor"></path><path d="M119.541 29.2872H115.363L118.8 21.7105L112.608 8.98425H117.022L120.904 17.5079L124.489 8.98425H128.696L119.541 29.2872Z" fill="currentColor"></path><path d="M134.135 15.17V23.5457H130.194V8.98436H134.016V10.7897C134.431 10.0794 135.023 9.53681 135.793 9.16193C136.564 8.78705 137.373 8.59961 138.223 8.59961C139.941 8.59961 141.245 9.1422 142.133 10.2274C143.043 11.2929 143.496 12.674 143.496 14.3709V23.5457H139.556V15.0516C139.556 14.1834 139.329 13.4829 138.875 12.9502C138.44 12.4174 137.768 12.1512 136.86 12.1512C136.031 12.1512 135.369 12.4372 134.875 13.0094C134.381 13.5816 134.135 14.3018 134.135 15.17Z" fill="currentColor"></path><path d="M153.155 12.1808C152.108 12.1808 151.229 12.5457 150.517 13.2758C149.807 14.0058 149.451 15.0022 149.451 16.265C149.451 17.5277 149.807 18.534 150.517 19.2838C151.248 20.0138 152.137 20.3789 153.184 20.3789C154.112 20.3789 154.853 20.1421 155.407 19.6685C155.96 19.1753 156.335 18.5932 156.532 17.9224L159.999 19.0766C159.643 20.4184 158.873 21.5725 157.688 22.5394C156.503 23.5062 155.001 23.9896 153.184 23.9896C151.012 23.9896 149.184 23.2596 147.703 21.7994C146.241 20.3197 145.511 18.4749 145.511 16.265C145.511 14.0354 146.232 12.1906 147.673 10.7305C149.135 9.27044 150.932 8.54041 153.065 8.54041C154.923 8.54041 156.443 9.02381 157.628 9.99062C158.813 10.9377 159.573 12.092 159.909 13.4533L156.384 14.6372C155.909 12.9996 154.833 12.1808 153.155 12.1808Z" fill="currentColor"></path></g><defs><clipPath id="clip0_2308_2426"><rect width="160" height="32" fill="currentColor"></rect></clipPath></defs>',
    2,
  ),
  cc = [ac];
function uc(e, t) {
  return F(), j("svg", ic, cc);
}
const lc = xe(oc, [["render", uc]]),
  dc = {},
  fc = {
    "aria-hidden": "true",
    class: "spinner animate-spin",
    viewBox: "0 0 100 101",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
  },
  hc = N(
    "path",
    {
      d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
      fill: "currentFill",
    },
    null,
    -1,
  ),
  pc = N(
    "path",
    {
      d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
      fill: "currentColor",
    },
    null,
    -1,
  ),
  mc = [hc, pc];
function yc(e, t) {
  return F(), j("svg", fc, mc);
}
const Ro = xe(dc, [["render", yc]]),
  jo = {
    enterActiveClass: "transition",
    enterFromClass: "opacity-0",
    enterToClass: "opacity-100",
    leaveActiveClass: "transition",
    leaveFromClass: "opacity-100",
    leaveToClass: "opacity-0",
  },
  jn = ee({
    __name: "Button",
    props: {
      as: { type: [String, Object], default: "button" },
      variant: { type: String, default: "primary" },
      size: { type: String, default: "md" },
      disabled: { type: Boolean, default: !1 },
      loading: { type: Boolean, default: !1 },
    },
    setup(e) {
      return (t, n) => {
        const r = Ro;
        return (
          F(),
          J(
            Yr(e.as),
            {
              disabled: e.disabled || e.loading ? !0 : void 0,
              type: "button",
              class: Et([
                "default-button",
                [`size-${e.size}`, `variant-${e.variant}`],
              ]),
            },
            {
              default: D(() => [
                N(
                  "span",
                  {
                    class: Et([
                      "icon-container",
                      { "icon-visible": t.$slots.icon || e.loading },
                    ]),
                  },
                  [
                    R(
                      So,
                      No(
                        "TransitionOpacity" in t ? t.TransitionOpacity : A(jo),
                        { mode: "out-in" },
                      ),
                      {
                        default: D(() => [
                          e.loading
                            ? (F(), J(r, { key: 0 }))
                            : we(t.$slots, "icon", { key: 1 }),
                        ]),
                        _: 3,
                      },
                      16,
                    ),
                  ],
                  2,
                ),
                we(t.$slots, "default"),
              ]),
              _: 3,
            },
            8,
            ["disabled", "class"],
          )
        );
      };
    },
  });
function Ln(e) {
  return Ja() ? (Xa(e), !0) : !1;
}
function me(e) {
  return typeof e == "function" ? e() : A(e);
}
const wr = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const bc = Object.prototype.toString,
  gc = (e) => bc.call(e) === "[object Object]",
  vr = () => {};
function wc(e, t) {
  function n(...r) {
    return new Promise((s, o) => {
      Promise.resolve(
        e(() => t.apply(this, r), { fn: t, thisArg: this, args: r }),
      )
        .then(s)
        .catch(o);
    });
  }
  return n;
}
const Uo = (e) => e();
function vc(e = Uo) {
  const t = de(!0);
  function n() {
    t.value = !1;
  }
  function r() {
    t.value = !0;
  }
  const s = (...o) => {
    t.value && e(...o);
  };
  return { isActive: Lo(t), pause: n, resume: r, eventFilter: s };
}
function xr(e, t = !1, n = "Timeout") {
  return new Promise((r, s) => {
    setTimeout(t ? () => s(n) : r, e);
  });
}
function xc(e) {
  return Qa();
}
function Ec(e, t, n = {}) {
  const { eventFilter: r = Uo, ...s } = n;
  return ut(e, wc(r, t), s);
}
function Pc(e, t, n = {}) {
  const { eventFilter: r, ...s } = n,
    { eventFilter: o, pause: i, resume: a, isActive: c } = vc(r);
  return {
    stop: Ec(e, t, { ...s, eventFilter: o }),
    pause: i,
    resume: a,
    isActive: c,
  };
}
function _c(e, t = !0, n) {
  xc() ? Ya(e, n) : t ? e() : Fo(e);
}
function Er(e, t = !1) {
  function n(
    l,
    { flush: f = "sync", deep: p = !1, timeout: y, throwOnTimeout: h } = {},
  ) {
    let m = null;
    const g = [
      new Promise((w) => {
        m = ut(
          e,
          (v) => {
            l(v) !== t && (m == null || m(), w(v));
          },
          { flush: f, deep: p, immediate: !0 },
        );
      }),
    ];
    return (
      y != null &&
        g.push(
          xr(y, h)
            .then(() => me(e))
            .finally(() => (m == null ? void 0 : m())),
        ),
      Promise.race(g)
    );
  }
  function r(l, f) {
    if (!zo(l)) return n((v) => v === l, f);
    const {
      flush: p = "sync",
      deep: y = !1,
      timeout: h,
      throwOnTimeout: m,
    } = f ?? {};
    let b = null;
    const w = [
      new Promise((v) => {
        b = ut(
          [e, l],
          ([P, x]) => {
            t !== (P === x) && (b == null || b(), v(P));
          },
          { flush: p, deep: y, immediate: !0 },
        );
      }),
    ];
    return (
      h != null &&
        w.push(
          xr(h, m)
            .then(() => me(e))
            .finally(() => (b == null || b(), me(e))),
        ),
      Promise.race(w)
    );
  }
  function s(l) {
    return n((f) => !!f, l);
  }
  function o(l) {
    return r(null, l);
  }
  function i(l) {
    return r(void 0, l);
  }
  function a(l) {
    return n(Number.isNaN, l);
  }
  function c(l, f) {
    return n((p) => {
      const y = Array.from(p);
      return y.includes(l) || y.includes(me(l));
    }, f);
  }
  function u(l) {
    return d(1, l);
  }
  function d(l = 1, f) {
    let p = -1;
    return n(() => ((p += 1), p >= l), f);
  }
  return Array.isArray(me(e))
    ? {
        toMatch: n,
        toContains: c,
        changed: u,
        changedTimes: d,
        get not() {
          return Er(e, !t);
        },
      }
    : {
        toMatch: n,
        toBe: r,
        toBeTruthy: s,
        toBeNull: o,
        toBeNaN: a,
        toBeUndefined: i,
        changed: u,
        changedTimes: d,
        get not() {
          return Er(e, !t);
        },
      };
}
function $c(e) {
  return Er(e);
}
function Ac(e, t = 1e3, n = {}) {
  const { immediate: r = !0, immediateCallback: s = !1 } = n;
  let o = null;
  const i = de(!1);
  function a() {
    o && (clearInterval(o), (o = null));
  }
  function c() {
    (i.value = !1), a();
  }
  function u() {
    const d = me(t);
    d <= 0 || ((i.value = !0), s && e(), a(), (o = setInterval(e, d)));
  }
  if ((r && wr && u(), zo(t) || typeof t == "function")) {
    const d = ut(t, () => {
      i.value && wr && u();
    });
    Ln(d);
  }
  return Ln(c), { isActive: i, pause: c, resume: u };
}
function Ic(e) {
  let t;
  const n = me(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const zn = wr ? window : void 0;
function Hs(...e) {
  let t, n, r, s;
  if (
    (typeof e[0] == "string" || Array.isArray(e[0])
      ? (([n, r, s] = e), (t = zn))
      : ([t, n, r, s] = e),
    !t)
  )
    return vr;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const o = [],
    i = () => {
      o.forEach((d) => d()), (o.length = 0);
    },
    a = (d, l, f, p) => (
      d.addEventListener(l, f, p), () => d.removeEventListener(l, f, p)
    ),
    c = ut(
      () => [Ic(t), me(s)],
      ([d, l]) => {
        if ((i(), !d)) return;
        const f = gc(l) ? { ...l } : l;
        o.push(...n.flatMap((p) => r.map((y) => a(d, p, y, f))));
      },
      { immediate: !0, flush: "post" },
    ),
    u = () => {
      c(), i();
    };
  return Ln(u), u;
}
function Bc(e, t = {}) {
  const { immediate: n = !0, fpsLimit: r = void 0, window: s = zn } = t,
    o = de(!1),
    i = r ? 1e3 / r : null;
  let a = 0,
    c = null;
  function u(f) {
    if (!o.value || !s) return;
    a || (a = f);
    const p = f - a;
    if (i && p < i) {
      c = s.requestAnimationFrame(u);
      return;
    }
    (a = f), e({ delta: p, timestamp: f }), (c = s.requestAnimationFrame(u));
  }
  function d() {
    !o.value &&
      s &&
      ((o.value = !0), (a = 0), (c = s.requestAnimationFrame(u)));
  }
  function l() {
    (o.value = !1), c != null && s && (s.cancelAnimationFrame(c), (c = null));
  }
  return n && d(), Ln(l), { isActive: Lo(o), pause: l, resume: d };
}
function Cc(e, t, n) {
  const {
      immediate: r = !0,
      delay: s = 0,
      onError: o = vr,
      onSuccess: i = vr,
      resetOnExecute: a = !0,
      shallow: c = !0,
      throwError: u,
    } = n ?? {},
    d = c ? gr(t) : de(t),
    l = de(!1),
    f = de(!1),
    p = gr(void 0);
  async function y(b = 0, ...g) {
    a && (d.value = t),
      (p.value = void 0),
      (l.value = !1),
      (f.value = !0),
      b > 0 && (await xr(b));
    const w = typeof e == "function" ? e(...g) : e;
    try {
      const v = await w;
      (d.value = v), (l.value = !0), i(v);
    } catch (v) {
      if (((p.value = v), o(v), u)) throw v;
    } finally {
      f.value = !1;
    }
    return d.value;
  }
  r && y(s);
  const h = { state: d, isReady: l, isLoading: f, error: p, execute: y };
  function m() {
    return new Promise((b, g) => {
      $c(f)
        .toBe(!1)
        .then(() => b(h))
        .catch(g);
    });
  }
  return {
    ...h,
    then(b, g) {
      return m().then(b, g);
    },
  };
}
const An =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
        ? window
        : typeof global < "u"
          ? global
          : typeof self < "u"
            ? self
            : {},
  In = "__vueuse_ssr_handlers__",
  Tc = kc();
function kc() {
  return In in An || (An[In] = An[In] || {}), An[In];
}
function Sc(e, t) {
  return Tc[e] || t;
}
function Nc(e) {
  return e == null
    ? "any"
    : e instanceof Set
      ? "set"
      : e instanceof Map
        ? "map"
        : e instanceof Date
          ? "date"
          : typeof e == "boolean"
            ? "boolean"
            : typeof e == "string"
              ? "string"
              : typeof e == "object"
                ? "object"
                : Number.isNaN(e)
                  ? "any"
                  : "number";
}
const qo = {
    boolean: { read: (e) => e === "true", write: (e) => String(e) },
    object: { read: (e) => JSON.parse(e), write: (e) => JSON.stringify(e) },
    number: { read: (e) => Number.parseFloat(e), write: (e) => String(e) },
    any: { read: (e) => e, write: (e) => String(e) },
    string: { read: (e) => e, write: (e) => String(e) },
    map: {
      read: (e) => new Map(JSON.parse(e)),
      write: (e) => JSON.stringify(Array.from(e.entries())),
    },
    set: {
      read: (e) => new Set(JSON.parse(e)),
      write: (e) => JSON.stringify(Array.from(e)),
    },
    date: { read: (e) => new Date(e), write: (e) => e.toISOString() },
  },
  Vs = "vueuse-storage";
function Do(e, t, n, r = {}) {
  let s;
  const {
      flush: o = "pre",
      deep: i = !0,
      listenToStorageChanges: a = !0,
      writeDefaults: c = !0,
      mergeDefaults: u = !1,
      shallow: d,
      window: l = zn,
      eventFilter: f,
      onError: p = (B) => {
        console.error(B);
      },
      initOnMounted: y,
    } = r,
    h = (d ? gr : de)(typeof t == "function" ? t() : t);
  if (!n)
    try {
      n = Sc("getDefaultStorage", () => {
        let B;
        return (B = zn) == null ? void 0 : B.localStorage;
      })();
    } catch (B) {
      p(B);
    }
  if (!n) return h;
  const m = me(t),
    b = Nc(m),
    g = (s = r.serializer) != null ? s : qo[b],
    { pause: w, resume: v } = Pc(h, () => x(h.value), {
      flush: o,
      deep: i,
      eventFilter: f,
    });
  l &&
    a &&
    _c(() => {
      Hs(l, "storage", $), Hs(l, Vs, k), y && $();
    }),
    y || $();
  function P(B, T) {
    l &&
      l.dispatchEvent(
        new CustomEvent(Vs, {
          detail: { key: e, oldValue: B, newValue: T, storageArea: n },
        }),
      );
  }
  function x(B) {
    try {
      const T = n.getItem(e);
      if (B == null) P(T, null), n.removeItem(e);
      else {
        const L = g.write(B);
        T !== L && (n.setItem(e, L), P(T, L));
      }
    } catch (T) {
      p(T);
    }
  }
  function _(B) {
    const T = B ? B.newValue : n.getItem(e);
    if (T == null) return c && m != null && n.setItem(e, g.write(m)), m;
    if (!B && u) {
      const L = g.read(T);
      return typeof u == "function"
        ? u(L, m)
        : b === "object" && !Array.isArray(L)
          ? { ...m, ...L }
          : L;
    } else return typeof T != "string" ? T : g.read(T);
  }
  function $(B) {
    if (!(B && B.storageArea !== n)) {
      if (B && B.key == null) {
        h.value = m;
        return;
      }
      if (!(B && B.key !== e)) {
        w();
        try {
          (B == null ? void 0 : B.newValue) !== g.write(h.value) &&
            (h.value = _(B));
        } catch (T) {
          p(T);
        } finally {
          B ? Fo(v) : v();
        }
      }
    }
  }
  function k(B) {
    $(B.detail);
  }
  return h;
}
async function Fc(e) {
  return new Promise((t, n) => {
    const r = new Image(),
      {
        src: s,
        srcset: o,
        sizes: i,
        class: a,
        loading: c,
        crossorigin: u,
        referrerPolicy: d,
      } = e;
    (r.src = s),
      o && (r.srcset = o),
      i && (r.sizes = i),
      a && (r.className = a),
      c && (r.loading = c),
      u && (r.crossOrigin = u),
      d && (r.referrerPolicy = d),
      (r.onload = () => t(r)),
      (r.onerror = n);
  });
}
function Lc(e, t = {}) {
  const n = Cc(() => Fc(me(e)), void 0, { resetOnExecute: !0, ...t });
  return (
    ut(
      () => me(e),
      () => n.execute(t.delay),
      { deep: !0 },
    ),
    n
  );
}
function zc(e = {}) {
  const { controls: t = !1, interval: n = "requestAnimationFrame" } = e,
    r = de(new Date()),
    s = () => (r.value = new Date()),
    o =
      n === "requestAnimationFrame"
        ? Bc(s, { immediate: !0 })
        : Ac(s, n, { immediate: !0 });
  return t ? { now: r, ...o } : r;
}
const Mc = [
    { max: 6e4, value: 1e3, name: "second" },
    { max: 276e4, value: 6e4, name: "minute" },
    { max: 72e6, value: 36e5, name: "hour" },
    { max: 5184e5, value: 864e5, name: "day" },
    { max: 24192e5, value: 6048e5, name: "week" },
    { max: 28512e6, value: 2592e6, name: "month" },
    { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" },
  ],
  Oc = {
    justNow: "just now",
    past: (e) => (e.match(/\d/) ? `${e} ago` : e),
    future: (e) => (e.match(/\d/) ? `in ${e}` : e),
    month: (e, t) =>
      e === 1
        ? t
          ? "last month"
          : "next month"
        : `${e} month${e > 1 ? "s" : ""}`,
    year: (e, t) =>
      e === 1
        ? t
          ? "last year"
          : "next year"
        : `${e} year${e > 1 ? "s" : ""}`,
    day: (e, t) =>
      e === 1 ? (t ? "yesterday" : "tomorrow") : `${e} day${e > 1 ? "s" : ""}`,
    week: (e, t) =>
      e === 1
        ? t
          ? "last week"
          : "next week"
        : `${e} week${e > 1 ? "s" : ""}`,
    hour: (e) => `${e} hour${e > 1 ? "s" : ""}`,
    minute: (e) => `${e} minute${e > 1 ? "s" : ""}`,
    second: (e) => `${e} second${e > 1 ? "s" : ""}`,
    invalid: "",
  };
function Rc(e) {
  return e.toISOString().slice(0, 10);
}
function jc(e, t = {}) {
  const { controls: n = !1, updateInterval: r = 3e4 } = t,
    { now: s, ...o } = zc({ interval: r, controls: !0 }),
    i = Z(() => Uc(new Date(me(e)), t, me(s)));
  return n ? { timeAgo: i, ...o } : i;
}
function Uc(e, t = {}, n = Date.now()) {
  let r;
  const {
      max: s,
      messages: o = Oc,
      fullDateFormatter: i = Rc,
      units: a = Mc,
      showSecond: c = !1,
      rounding: u = "round",
    } = t,
    d = typeof u == "number" ? (m) => +m.toFixed(u) : Math[u],
    l = +n - +e,
    f = Math.abs(l);
  function p(m, b) {
    return d(Math.abs(m) / b.value);
  }
  function y(m, b) {
    const g = p(m, b),
      w = m > 0,
      v = h(b.name, g, w);
    return h(w ? "past" : "future", v, w);
  }
  function h(m, b, g) {
    const w = o[m];
    return typeof w == "function" ? w(b, g) : w.replace("{0}", b.toString());
  }
  if (f < 6e4 && !c) return o.justNow;
  if (typeof s == "number" && f > s) return i(new Date(e));
  if (typeof s == "string") {
    const m = (r = a.find((b) => b.name === s)) == null ? void 0 : r.max;
    if (m && f > m) return i(new Date(e));
  }
  for (const [m, b] of a.entries()) {
    if (p(l, b) <= 0 && a[m - 1]) return y(l, a[m - 1]);
    if (f < b.max) return y(l, b);
  }
  return o.invalid;
}
const qc = "1.0.5";
const Ee = class Pr extends Error {
  constructor(t, n = {}) {
    let i;
    const r =
        n.cause instanceof Pr
          ? n.cause.details
          : (i = n.cause) != null && i.message
            ? n.cause.message
            : n.details,
      s = (n.cause instanceof Pr && n.cause.docsPath) || n.docsPath,
      o = [
        t || "An error occurred.",
        "",
        ...(n.metaMessages ? [...n.metaMessages, ""] : []),
        ...(s ? [`Docs: https://abitype.dev${s}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        `Version: abitype@${qc}`,
      ].join(`
`);
    super(o),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiTypeError",
      }),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = s),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = t);
  }
};
function et(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups;
}
const Go = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  Ho =
    /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  Vo = /^\(.+?\).*?$/,
  Zs = /^tuple(?<array>(\[(\d*)\])*)$/;
function _r(e) {
  let t = e.type;
  if (Zs.test(e.type) && "components" in e) {
    t = "(";
    const n = e.components.length;
    for (let s = 0; s < n; s++) {
      const o = e.components[s];
      (t += _r(o)), s < n - 1 && (t += ", ");
    }
    const r = et(Zs, e.type);
    return (
      (t += `)${(r == null ? void 0 : r.array) ?? ""}`), _r({ ...e, type: t })
    );
  }
  return (
    "indexed" in e && e.indexed && (t = `${t} indexed`),
    e.name ? `${t} ${e.name}` : t
  );
}
function Mt(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
    const s = e[r];
    (t += _r(s)), r !== n - 1 && (t += ", ");
  }
  return t;
}
function Dc(e) {
  return e.type === "function"
    ? `function ${e.name}(${Mt(e.inputs)})${e.stateMutability && e.stateMutability !== "nonpayable" ? ` ${e.stateMutability}` : ""}${e.outputs.length ? ` returns (${Mt(e.outputs)})` : ""}`
    : e.type === "event"
      ? `event ${e.name}(${Mt(e.inputs)})`
      : e.type === "error"
        ? `error ${e.name}(${Mt(e.inputs)})`
        : e.type === "constructor"
          ? `constructor(${Mt(e.inputs)})${e.stateMutability === "payable" ? " payable" : ""}`
          : e.type === "fallback"
            ? "fallback()"
            : "receive() external payable";
}
const Zo = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function Gc(e) {
  return Zo.test(e);
}
function Hc(e) {
  return et(Zo, e);
}
const Wo = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function Vc(e) {
  return Wo.test(e);
}
function Zc(e) {
  return et(Wo, e);
}
const Ko =
  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function Wc(e) {
  return Ko.test(e);
}
function Kc(e) {
  return et(Ko, e);
}
const Yo = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function Jo(e) {
  return Yo.test(e);
}
function Yc(e) {
  return et(Yo, e);
}
const Xo =
  /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function Jc(e) {
  return Xo.test(e);
}
function Xc(e) {
  return et(Xo, e);
}
const Qc = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function eu(e) {
  return Qc.test(e);
}
const tu = /^receive\(\) external payable$/;
function nu(e) {
  return tu.test(e);
}
const ru = new Set(["indexed"]),
  $r = new Set(["calldata", "memory", "storage"]);
class su extends Ee {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownTypeError",
      });
  }
}
class ou extends Ee {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type.`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownSolidityTypeError",
      });
  }
}
class iu extends Ee {
  constructor({ param: t }) {
    super("Invalid ABI parameter.", { details: t }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidParameterError",
      });
  }
}
class au extends Ee {
  constructor({ param: t, name: n }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SolidityProtectedKeywordError",
      });
  }
}
class cu extends Ee {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidModifierError",
      });
  }
}
class uu extends Ee {
  constructor({ param: t, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidFunctionModifierError",
      });
  }
}
class lu extends Ee {
  constructor({ abiParameter: t }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(t, null, 2),
      metaMessages: ["ABI parameter type is invalid."],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidAbiTypeParameterError",
      });
  }
}
class jt extends Ee {
  constructor({ signature: t, type: n }) {
    super(`Invalid ${n} signature.`, { details: t }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidSignatureError",
      });
  }
}
class du extends Ee {
  constructor({ signature: t }) {
    super("Unknown signature.", { details: t }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownSignatureError",
      });
  }
}
class fu extends Ee {
  constructor({ signature: t }) {
    super("Invalid struct signature.", {
      details: t,
      metaMessages: ["No properties exist."],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidStructSignatureError",
      });
  }
}
class hu extends Ee {
  constructor({ type: t }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${t}" is a circular reference.`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "CircularReferenceError",
      });
  }
}
class pu extends Ee {
  constructor({ current: t, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${t.trim()}" has too many ${n > 0 ? "opening" : "closing"} parentheses.`,
      ],
      details: `Depth "${n}"`,
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidParenthesisError",
      });
  }
}
function mu(e, t) {
  return t ? `${t}:${e}` : e;
}
const or = new Map([
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 },
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 },
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 },
  ],
]);
function yu(e, t = {}) {
  if (Wc(e)) {
    const n = Kc(e);
    if (!n) throw new jt({ signature: e, type: "function" });
    const r = Ae(n.parameters),
      s = [],
      o = r.length;
    for (let a = 0; a < o; a++)
      s.push(rt(r[a], { modifiers: $r, structs: t, type: "function" }));
    const i = [];
    if (n.returns) {
      const a = Ae(n.returns),
        c = a.length;
      for (let u = 0; u < c; u++)
        i.push(rt(a[u], { modifiers: $r, structs: t, type: "function" }));
    }
    return {
      name: n.name,
      type: "function",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: s,
      outputs: i,
    };
  }
  if (Vc(e)) {
    const n = Zc(e);
    if (!n) throw new jt({ signature: e, type: "event" });
    const r = Ae(n.parameters),
      s = [],
      o = r.length;
    for (let i = 0; i < o; i++)
      s.push(rt(r[i], { modifiers: ru, structs: t, type: "event" }));
    return { name: n.name, type: "event", inputs: s };
  }
  if (Gc(e)) {
    const n = Hc(e);
    if (!n) throw new jt({ signature: e, type: "error" });
    const r = Ae(n.parameters),
      s = [],
      o = r.length;
    for (let i = 0; i < o; i++) s.push(rt(r[i], { structs: t, type: "error" }));
    return { name: n.name, type: "error", inputs: s };
  }
  if (Jc(e)) {
    const n = Xc(e);
    if (!n) throw new jt({ signature: e, type: "constructor" });
    const r = Ae(n.parameters),
      s = [],
      o = r.length;
    for (let i = 0; i < o; i++)
      s.push(rt(r[i], { structs: t, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: s,
    };
  }
  if (eu(e)) return { type: "fallback" };
  if (nu(e)) return { type: "receive", stateMutability: "payable" };
  throw new du({ signature: e });
}
const bu =
    /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  gu =
    /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  wu = /^u?int$/;
function rt(e, t) {
  let l, f;
  const n = mu(e, t == null ? void 0 : t.type);
  if (or.has(n)) return or.get(n);
  const r = Vo.test(e),
    s = et(r ? gu : bu, e);
  if (!s) throw new iu({ param: e });
  if (s.name && xu(s.name)) throw new au({ param: e, name: s.name });
  const o = s.name ? { name: s.name } : {},
    i = s.modifier === "indexed" ? { indexed: !0 } : {},
    a = (t == null ? void 0 : t.structs) ?? {};
  let c,
    u = {};
  if (r) {
    c = "tuple";
    const p = Ae(s.type),
      y = [],
      h = p.length;
    for (let m = 0; m < h; m++) y.push(rt(p[m], { structs: a }));
    u = { components: y };
  } else if (s.type in a) (c = "tuple"), (u = { components: a[s.type] });
  else if (wu.test(s.type)) c = `${s.type}256`;
  else if (((c = s.type), (t == null ? void 0 : t.type) !== "struct" && !Qo(c)))
    throw new ou({ type: c });
  if (s.modifier) {
    if (
      !(
        (f = (l = t == null ? void 0 : t.modifiers) == null ? void 0 : l.has) !=
          null && f.call(l, s.modifier)
      )
    )
      throw new cu({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: s.modifier,
      });
    if ($r.has(s.modifier) && !Eu(c, !!s.array))
      throw new uu({
        param: e,
        type: t == null ? void 0 : t.type,
        modifier: s.modifier,
      });
  }
  const d = { type: `${c}${s.array ?? ""}`, ...o, ...i, ...u };
  return or.set(n, d), d;
}
function Ae(e, t = [], n = "", r = 0) {
  const s = e.trim().length;
  for (let o = 0; o < s; o++) {
    const i = e[o],
      a = e.slice(o + 1);
    switch (i) {
      case ",":
        return r === 0 ? Ae(a, [...t, n.trim()]) : Ae(a, t, `${n}${i}`, r);
      case "(":
        return Ae(a, t, `${n}${i}`, r + 1);
      case ")":
        return Ae(a, t, `${n}${i}`, r - 1);
      default:
        return Ae(a, t, `${n}${i}`, r);
    }
  }
  if (n === "") return t;
  if (r !== 0) throw new pu({ current: n, depth: r });
  return t.push(n.trim()), t;
}
function Qo(e) {
  return (
    e === "address" ||
    e === "bool" ||
    e === "function" ||
    e === "string" ||
    Go.test(e) ||
    Ho.test(e)
  );
}
const vu =
  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function xu(e) {
  return (
    e === "address" ||
    e === "bool" ||
    e === "function" ||
    e === "string" ||
    e === "tuple" ||
    Go.test(e) ||
    Ho.test(e) ||
    vu.test(e)
  );
}
function Eu(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
function Pu(e) {
  const t = {},
    n = e.length;
  for (let i = 0; i < n; i++) {
    const a = e[i];
    if (!Jo(a)) continue;
    const c = Yc(a);
    if (!c) throw new jt({ signature: a, type: "struct" });
    const u = c.properties.split(";"),
      d = [],
      l = u.length;
    for (let f = 0; f < l; f++) {
      const y = u[f].trim();
      if (!y) continue;
      const h = rt(y, { type: "struct" });
      d.push(h);
    }
    if (!d.length) throw new fu({ signature: a });
    t[c.name] = d;
  }
  const r = {},
    s = Object.entries(t),
    o = s.length;
  for (let i = 0; i < o; i++) {
    const [a, c] = s[i];
    r[a] = ei(c, t);
  }
  return r;
}
const _u = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function ei(e, t, n = new Set()) {
  const r = [],
    s = e.length;
  for (let o = 0; o < s; o++) {
    const i = e[o];
    if (Vo.test(i.type)) r.push(i);
    else {
      const c = et(_u, i.type);
      if (!(c != null && c.type)) throw new lu({ abiParameter: i });
      const { array: u, type: d } = c;
      if (d in t) {
        if (n.has(d)) throw new hu({ type: d });
        r.push({
          ...i,
          type: `tuple${u ?? ""}`,
          components: ei(t[d] ?? [], t, new Set([...n, d])),
        });
      } else if (Qo(d)) r.push(i);
      else throw new su({ type: d });
    }
  }
  return r;
}
function ti(e) {
  const t = Pu(e),
    n = [],
    r = e.length;
  for (let s = 0; s < r; s++) {
    const o = e[s];
    Jo(o) || n.push(yu(o, t));
  }
  return n;
}
function O(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function") return r;
  const s = e[n];
  return typeof s == "function" ? s : (o) => t(e, o);
}
function Me(e, { includeName: t = !1 } = {}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error")
    throw new Mu(e.type);
  return `${e.name}(${Un(e.inputs, { includeName: t })})`;
}
function Un(e, { includeName: t = !1 } = {}) {
  return e ? e.map((n) => $u(n, { includeName: t })).join(t ? ", " : ",") : "";
}
function $u(e, { includeName: t }) {
  return e.type.startsWith("tuple")
    ? `(${Un(e.components, { includeName: t })})${e.type.slice(5)}`
    : e.type + (t && e.name ? ` ${e.name}` : "");
}
function ve(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string"
    ? !1
    : t
      ? /^0x[0-9a-fA-F]*$/.test(e)
      : e.startsWith("0x");
}
function V(e) {
  return ve(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
const ni = "2.20.0";
const Bn = {
  getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: n }) =>
    t ? `${e ?? "https://viem.sh"}${t}${n ? `#${n}` : ""}` : void 0,
  version: ni,
};
class E extends Error {
  constructor(t, n = {}) {
    let a;
    const r = (() => {
        let c;
        return n.cause instanceof E
          ? n.cause.details
          : (c = n.cause) != null && c.message
            ? n.cause.message
            : n.details;
      })(),
      s = (n.cause instanceof E && n.cause.docsPath) || n.docsPath,
      o =
        (a = Bn.getDocsUrl) == null
          ? void 0
          : a.call(Bn, { ...n, docsPath: s }),
      i = [
        t || "An error occurred.",
        "",
        ...(n.metaMessages ? [...n.metaMessages, ""] : []),
        ...(o ? [`Docs: ${o}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        `Version: ${Bn.version}`,
      ].join(`
`);
    super(i, n.cause ? { cause: n.cause } : void 0),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BaseError",
      }),
      (this.details = r),
      (this.docsPath = s),
      (this.metaMessages = n.metaMessages),
      (this.name = n.name ?? this.name),
      (this.shortMessage = t),
      (this.version = ni);
  }
  walk(t) {
    return ri(this, t);
  }
}
function ri(e, t) {
  return t != null && t(e)
    ? e
    : e && typeof e == "object" && "cause" in e
      ? ri(e.cause, t)
      : t
        ? null
        : e;
}
class Au extends E {
  constructor({ docsPath: t }) {
    super(
      [
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it.",
      ].join(`
`),
      { docsPath: t, name: "AbiConstructorNotFoundError" },
    );
  }
}
class Ws extends E {
  constructor({ docsPath: t }) {
    super(
      [
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.",
      ].join(`
`),
      { docsPath: t, name: "AbiConstructorParamsNotFoundError" },
    );
  }
}
class si extends E {
  constructor({ data: t, params: n, size: r }) {
    super(
      [`Data size of ${r} bytes is too small for given parameters.`].join(`
`),
      {
        metaMessages: [
          `Params: (${Un(n, { includeName: !0 })})`,
          `Data:   ${t} (${r} bytes)`,
        ],
        name: "AbiDecodingDataSizeTooSmallError",
      },
    ),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = t),
      (this.params = n),
      (this.size = r);
  }
}
class qn extends E {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError",
    });
  }
}
class Iu extends E {
  constructor({ expectedLength: t, givenLength: n, type: r }) {
    super(
      [
        `ABI encoding array length mismatch for type ${r}.`,
        `Expected length: ${t}`,
        `Given length: ${n}`,
      ].join(`
`),
      { name: "AbiEncodingArrayLengthMismatchError" },
    );
  }
}
class Bu extends E {
  constructor({ expectedSize: t, value: n }) {
    super(
      `Size of bytes "${n}" (bytes${V(n)}) does not match expected size (bytes${t}).`,
      { name: "AbiEncodingBytesSizeMismatchError" },
    );
  }
}
class Cu extends E {
  constructor({ expectedLength: t, givenLength: n }) {
    super(
      [
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${t}`,
        `Given length (values): ${n}`,
      ].join(`
`),
      { name: "AbiEncodingLengthMismatchError" },
    );
  }
}
class oi extends E {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Encoded error signature "${t}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`,
      ].join(`
`),
      { docsPath: n, name: "AbiErrorSignatureNotFoundError" },
    ),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.signature = t);
  }
}
class Tu extends E {
  constructor({ docsPath: t }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: t,
      name: "AbiEventSignatureEmptyTopicsError",
    });
  }
}
class ii extends E {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Encoded event signature "${t}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`,
      ].join(`
`),
      { docsPath: n, name: "AbiEventSignatureNotFoundError" },
    );
  }
}
class Ks extends E {
  constructor(t, { docsPath: n } = {}) {
    super(
      [
        `Event ${t ? `"${t}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiEventNotFoundError" },
    );
  }
}
class Mn extends E {
  constructor(t, { docsPath: n } = {}) {
    super(
      [
        `Function ${t ? `"${t}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiFunctionNotFoundError" },
    );
  }
}
class ku extends E {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Function "${t}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiFunctionOutputsNotFoundError" },
    );
  }
}
class Su extends E {
  constructor(t, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${t.type}\` in \`${Me(t.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Me(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI.",
      ],
      name: "AbiItemAmbiguityError",
    });
  }
}
class Nu extends E {
  constructor({ expectedSize: t, givenSize: n }) {
    super(`Expected bytes${t}, got bytes${n}.`, {
      name: "BytesSizeMismatchError",
    });
  }
}
class Dt extends E {
  constructor({ abiItem: t, data: n, params: r, size: s }) {
    super(
      [`Data size of ${s} bytes is too small for non-indexed event parameters.`]
        .join(`
`),
      {
        metaMessages: [
          `Params: (${Un(r, { includeName: !0 })})`,
          `Data:   ${n} (${s} bytes)`,
        ],
        name: "DecodeLogDataMismatch",
      },
    ),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = t),
      (this.data = n),
      (this.params = r),
      (this.size = s);
  }
}
class Dn extends E {
  constructor({ abiItem: t, param: n }) {
    super(
      [
        `Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ""} on event "${Me(t, { includeName: !0 })}".`,
      ].join(`
`),
      { name: "DecodeLogTopicsMismatch" },
    ),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = t);
  }
}
class Fu extends E {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Type "${t}" is not a valid encoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n, name: "InvalidAbiEncodingType" },
    );
  }
}
class Lu extends E {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Type "${t}" is not a valid decoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n, name: "InvalidAbiDecodingType" },
    );
  }
}
class zu extends E {
  constructor(t) {
    super(
      [`Value "${t}" is not a valid array.`].join(`
`),
      { name: "InvalidArrayError" },
    );
  }
}
class Mu extends E {
  constructor(t) {
    super(
      [
        `"${t}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"',
      ].join(`
`),
      { name: "InvalidDefinitionTypeError" },
    );
  }
}
class Ou extends E {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`, {
      name: "FilterTypeNotSupportedError",
    });
  }
}
class ai extends E {
  constructor({ offset: t, position: n, size: r }) {
    super(
      `Slice ${n === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${r}).`,
      { name: "SliceOffsetOutOfBoundsError" },
    );
  }
}
class ci extends E {
  constructor({ size: t, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`,
      { name: "SizeExceedsPaddingSizeError" },
    );
  }
}
class Ys extends E {
  constructor({ size: t, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`,
      { name: "InvalidBytesLengthError" },
    );
  }
}
function mt(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string"
    ? We(e, { dir: t, size: n })
    : Ru(e, { dir: t, size: n });
}
function We(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new ci({ size: Math.ceil(r.length / 2), targetSize: n, type: "hex" });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function Ru(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  if (e.length > n)
    throw new ci({ size: e.length, targetSize: n, type: "bytes" });
  const r = new Uint8Array(n);
  for (let s = 0; s < n; s++) {
    const o = t === "right";
    r[o ? s : n - s - 1] = e[o ? s : e.length - s - 1];
  }
  return r;
}
class ju extends E {
  constructor({ max: t, min: n, signed: r, size: s, value: o }) {
    super(
      `Number "${o}" is not in safe ${s ? `${s * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`,
      { name: "IntegerOutOfRangeError" },
    );
  }
}
class Uu extends E {
  constructor(t) {
    super(
      `Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
      { name: "InvalidBytesBooleanError" },
    );
  }
}
class qu extends E {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`, {
      name: "SizeOverflowError",
    });
  }
}
function Ke(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e,
    r = 0;
  for (
    let s = 0;
    s < n.length - 1 &&
    n[t === "left" ? s : n.length - s - 1].toString() === "0";
    s++
  )
    r++;
  return (
    (n = t === "left" ? n.slice(r) : n.slice(0, n.length - r)),
    typeof e == "string"
      ? (n.length === 1 && t === "right" && (n = `${n}0`),
        `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  );
}
function ke(e, { size: t }) {
  if (V(e) > t) throw new qu({ givenSize: V(e), maxSize: t });
}
function Y(e, t = {}) {
  const { signed: n } = t;
  t.size && ke(e, { size: t.size });
  const r = BigInt(e);
  if (!n) return r;
  const s = (e.length - 2) / 2,
    o = (1n << (BigInt(s) * 8n - 1n)) - 1n;
  return r <= o ? r : r - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function Be(e, t = {}) {
  return Number(Y(e, t));
}
const Du = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0"),
);
function S(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? z(e, t)
    : typeof e == "string"
      ? Pt(e, t)
      : typeof e == "boolean"
        ? ui(e, t)
        : X(e, t);
}
function ui(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number"
    ? (ke(n, { size: t.size }), mt(n, { size: t.size }))
    : n;
}
function X(e, t = {}) {
  let n = "";
  for (let s = 0; s < e.length; s++) n += Du[e[s]];
  const r = `0x${n}`;
  return typeof t.size == "number"
    ? (ke(r, { size: t.size }), mt(r, { dir: "right", size: t.size }))
    : r;
}
function z(e, t = {}) {
  const { signed: n, size: r } = t,
    s = BigInt(e);
  let o;
  r
    ? n
      ? (o = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (o = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof e == "number" && (o = BigInt(Number.MAX_SAFE_INTEGER));
  const i = typeof o == "bigint" && n ? -o - 1n : 0;
  if ((o && s > o) || s < i) {
    const c = typeof e == "bigint" ? "n" : "";
    throw new ju({
      max: o ? `${o}${c}` : void 0,
      min: `${i}${c}`,
      signed: n,
      size: r,
      value: `${e}${c}`,
    });
  }
  const a = `0x${(n && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? mt(a, { size: r }) : a;
}
const Gu = new TextEncoder();
function Pt(e, t = {}) {
  const n = Gu.encode(e);
  return X(n, t);
}
const Hu = new TextEncoder();
function Ie(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? Zu(e, t)
    : typeof e == "boolean"
      ? Vu(e, t)
      : ve(e)
        ? fe(e, t)
        : at(e, t);
}
function Vu(e, t = {}) {
  const n = new Uint8Array(1);
  return (
    (n[0] = Number(e)),
    typeof t.size == "number"
      ? (ke(n, { size: t.size }), mt(n, { size: t.size }))
      : n
  );
}
const Ne = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function Js(e) {
  if (e >= Ne.zero && e <= Ne.nine) return e - Ne.zero;
  if (e >= Ne.A && e <= Ne.F) return e - (Ne.A - 10);
  if (e >= Ne.a && e <= Ne.f) return e - (Ne.a - 10);
}
function fe(e, t = {}) {
  let n = e;
  t.size &&
    (ke(n, { size: t.size }), (n = mt(n, { dir: "right", size: t.size })));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const s = r.length / 2,
    o = new Uint8Array(s);
  for (let i = 0, a = 0; i < s; i++) {
    const c = Js(r.charCodeAt(a++)),
      u = Js(r.charCodeAt(a++));
    if (c === void 0 || u === void 0)
      throw new E(
        `Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`,
      );
    o[i] = c * 16 + u;
  }
  return o;
}
function Zu(e, t) {
  const n = z(e, t);
  return fe(n);
}
function at(e, t = {}) {
  const n = Hu.encode(e);
  return typeof t.size == "number"
    ? (ke(n, { size: t.size }), mt(n, { dir: "right", size: t.size }))
    : n;
}
function On(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function Wu(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
  );
}
function un(e, ...t) {
  if (!Wu(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(
      `Uint8Array expected of length ${t}, not of length=${e.length}`,
    );
}
function Ku(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  On(e.outputLen), On(e.blockLen);
}
function _t(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function li(e, t) {
  un(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(
      `digestInto() expects output buffer of length at least ${n}`,
    );
}
const Cn = BigInt(2 ** 32 - 1),
  Xs = BigInt(32);
function Yu(e, t = !1) {
  return t
    ? { h: Number(e & Cn), l: Number((e >> Xs) & Cn) }
    : { h: Number((e >> Xs) & Cn) | 0, l: Number(e & Cn) | 0 };
}
function Ju(e, t = !1) {
  const n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let s = 0; s < e.length; s++) {
    const { h: o, l: i } = Yu(e[s], t);
    [n[s], r[s]] = [o, i];
  }
  return [n, r];
}
const Xu = (e, t, n) => (e << n) | (t >>> (32 - n)),
  Qu = (e, t, n) => (t << n) | (e >>> (32 - n)),
  el = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  tl = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n)),
  ir =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const nl =
    (e) =>
      new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  ar = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Ce = (e, t) => (e << (32 - t)) | (e >>> t),
  Qs = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
  rl = (e) =>
    ((e << 24) & 4278190080) |
    ((e << 8) & 16711680) |
    ((e >>> 8) & 65280) |
    ((e >>> 24) & 255);
function eo(e) {
  for (let t = 0; t < e.length; t++) e[t] = rl(e[t]);
}
function sl(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Gn(e) {
  return typeof e == "string" && (e = sl(e)), un(e), e;
}
function ol(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    un(s), (t += s.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, s = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, s), (s += o.length);
  }
  return n;
}
class Jr {
  clone() {
    return this._cloneInto();
  }
}
function di(e) {
  const t = (r) => e().update(Gn(r)).digest(),
    n = e();
  return (
    (t.outputLen = n.outputLen),
    (t.blockLen = n.blockLen),
    (t.create = () => e()),
    t
  );
}
function il(e = 32) {
  if (ir && typeof ir.getRandomValues == "function")
    return ir.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
const fi = [],
  hi = [],
  pi = [],
  al = BigInt(0),
  Ot = BigInt(1),
  cl = BigInt(2),
  ul = BigInt(7),
  ll = BigInt(256),
  dl = BigInt(113);
for (let e = 0, t = Ot, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    fi.push(2 * (5 * r + n)),
    hi.push((((e + 1) * (e + 2)) / 2) % 64);
  let s = al;
  for (let o = 0; o < 7; o++)
    (t = ((t << Ot) ^ ((t >> ul) * dl)) % ll),
      t & cl && (s ^= Ot << ((Ot << BigInt(o)) - Ot));
  pi.push(s);
}
const [fl, hl] = Ju(pi, !0),
  to = (e, t, n) => (n > 32 ? el(e, t, n) : Xu(e, t, n)),
  no = (e, t, n) => (n > 32 ? tl(e, t, n) : Qu(e, t, n));
function pl(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let i = 0; i < 10; i++)
      n[i] = e[i] ^ e[i + 10] ^ e[i + 20] ^ e[i + 30] ^ e[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const a = (i + 8) % 10,
        c = (i + 2) % 10,
        u = n[c],
        d = n[c + 1],
        l = to(u, d, 1) ^ n[a],
        f = no(u, d, 1) ^ n[a + 1];
      for (let p = 0; p < 50; p += 10) (e[i + p] ^= l), (e[i + p + 1] ^= f);
    }
    let s = e[2],
      o = e[3];
    for (let i = 0; i < 24; i++) {
      const a = hi[i],
        c = to(s, o, a),
        u = no(s, o, a),
        d = fi[i];
      (s = e[d]), (o = e[d + 1]), (e[d] = c), (e[d + 1] = u);
    }
    for (let i = 0; i < 50; i += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[i + a];
      for (let a = 0; a < 10; a++)
        e[i + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (e[0] ^= fl[r]), (e[1] ^= hl[r]);
  }
  n.fill(0);
}
class Xr extends Jr {
  constructor(t, n, r, s = !1, o = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = s),
      (this.rounds = o),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      On(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = nl(this.state));
  }
  keccak() {
    Qs || eo(this.state32),
      pl(this.state32, this.rounds),
      Qs || eo(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(t) {
    _t(this);
    const { blockLen: n, state: r } = this;
    t = Gn(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const i = Math.min(n - this.pos, s - o);
      for (let a = 0; a < i; a++) r[this.pos++] ^= t[o++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: s } = this;
    (t[r] ^= n),
      n & 128 && r === s - 1 && this.keccak(),
      (t[s - 1] ^= 128),
      this.keccak();
  }
  writeInto(t) {
    _t(this, !1), un(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let s = 0, o = t.length; s < o; ) {
      this.posOut >= r && this.keccak();
      const i = Math.min(r - this.posOut, o - s);
      t.set(n.subarray(this.posOut, this.posOut + i), s),
        (this.posOut += i),
        (s += i);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return On(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((li(t, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: s,
      rounds: o,
      enableXOF: i,
    } = this;
    return (
      t || (t = new Xr(n, r, s, i, o)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = o),
      (t.suffix = r),
      (t.outputLen = s),
      (t.enableXOF = i),
      (t.destroyed = this.destroyed),
      t
    );
  }
}
const ml = (e, t, n) => di(() => new Xr(t, e, n)),
  yl = ml(1, 136, 256 / 8);
function Q(e, t) {
  const n = t || "hex",
    r = yl(ve(e, { strict: !1 }) ? Ie(e) : e);
  return n === "bytes" ? r : S(r);
}
const bl = (e) => Q(Ie(e));
function gl(e) {
  return bl(e);
}
function wl(e) {
  let t = !0,
    n = "",
    r = 0,
    s = "",
    o = !1;
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    if (
      (["(", ")", ","].includes(a) && (t = !0),
      a === "(" && r++,
      a === ")" && r--,
      !!t)
    ) {
      if (r === 0) {
        if (a === " " && ["event", "function", ""].includes(s)) s = "";
        else if (((s += a), a === ")")) {
          o = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        e[i - 1] !== "," && n !== "," && n !== ",(" && ((n = ""), (t = !1));
        continue;
      }
      (s += a), (n += a);
    }
  }
  if (!o) throw new E("Unable to normalize signature.");
  return s;
}
const vl = (e) => {
  const t = typeof e == "string" ? e : Dc(e);
  return wl(t);
};
function mi(e) {
  return gl(vl(e));
}
const Qr = mi;
class se extends E {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart.",
      ],
      name: "InvalidAddressError",
    });
  }
}
class es extends Map {
  constructor(t) {
    super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = t);
  }
  set(t, n) {
    return (
      super.set(t, n),
      this.maxSize &&
        this.size > this.maxSize &&
        this.delete(this.keys().next().value),
      this
    );
  }
}
const cr = new es(8192);
function ln(e, t) {
  if (cr.has(`${e}.${t}`)) return cr.get(`${e}.${t}`);
  const n = e.substring(2).toLowerCase(),
    r = Q(at(n), "bytes"),
    s = n.split("");
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && s[i] && (s[i] = s[i].toUpperCase()),
      (r[i >> 1] & 15) >= 8 && s[i + 1] && (s[i + 1] = s[i + 1].toUpperCase());
  const o = `0x${s.join("")}`;
  return cr.set(`${e}.${t}`, o), o;
}
function Hn(e, t) {
  if (!K(e, { strict: !1 })) throw new se({ address: e });
  return ln(e, t);
}
const xl = /^0x[a-fA-F0-9]{40}$/,
  ur = new es(8192);
function K(e, t) {
  const { strict: n = !0 } = t ?? {},
    r = `${e}.${n}`;
  if (ur.has(r)) return ur.get(r);
  const s = xl.test(e)
    ? e.toLowerCase() === e
      ? !0
      : n
        ? ln(e) === e
        : !0
    : !1;
  return ur.set(r, s), s;
}
function Oe(e) {
  return typeof e[0] == "string" ? Se(e) : El(e);
}
function El(e) {
  let t = 0;
  for (const s of e) t += s.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const s of e) n.set(s, r), (r += s.length);
  return n;
}
function Se(e) {
  return `0x${e.reduce((t, n) => t + n.replace("0x", ""), "")}`;
}
function Gt(e, t, n, { strict: r } = {}) {
  return ve(e, { strict: !1 })
    ? wi(e, t, n, { strict: r })
    : gi(e, t, n, { strict: r });
}
function yi(e, t) {
  if (typeof t == "number" && t > 0 && t > V(e) - 1)
    throw new ai({ offset: t, position: "start", size: V(e) });
}
function bi(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && V(e) !== n - t)
    throw new ai({ offset: n, position: "end", size: V(e) });
}
function gi(e, t, n, { strict: r } = {}) {
  yi(e, t);
  const s = e.slice(t, n);
  return r && bi(s, t, n), s;
}
function wi(e, t, n, { strict: r } = {}) {
  yi(e, t);
  const s = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && bi(s, t, n), s;
}
function kt(e, t) {
  if (e.length !== t.length)
    throw new Cu({ expectedLength: e.length, givenLength: t.length });
  const n = Pl({ params: e, values: t }),
    r = ns(n);
  return r.length === 0 ? "0x" : r;
}
function Pl({ params: e, values: t }) {
  const n = [];
  for (let r = 0; r < e.length; r++) n.push(ts({ param: e[r], value: t[r] }));
  return n;
}
function ts({ param: e, value: t }) {
  const n = rs(e.type);
  if (n) {
    const [r, s] = n;
    return $l(t, { length: r, param: { ...e, type: s } });
  }
  if (e.type === "tuple") return Tl(t, { param: e });
  if (e.type === "address") return _l(t);
  if (e.type === "bool") return Il(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
    const r = e.type.startsWith("int");
    return Bl(t, { signed: r });
  }
  if (e.type.startsWith("bytes")) return Al(t, { param: e });
  if (e.type === "string") return Cl(t);
  throw new Fu(e.type, { docsPath: "/docs/contract/encodeAbiParameters" });
}
function ns(e) {
  let t = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: i, encoded: a } = e[o];
    i ? (t += 32) : (t += V(a));
  }
  const n = [],
    r = [];
  let s = 0;
  for (let o = 0; o < e.length; o++) {
    const { dynamic: i, encoded: a } = e[o];
    i ? (n.push(z(t + s, { size: 32 })), r.push(a), (s += V(a))) : n.push(a);
  }
  return Oe([...n, ...r]);
}
function _l(e) {
  if (!K(e)) throw new se({ address: e });
  return { dynamic: !1, encoded: We(e.toLowerCase()) };
}
function $l(e, { length: t, param: n }) {
  const r = t === null;
  if (!Array.isArray(e)) throw new zu(e);
  if (!r && e.length !== t)
    throw new Iu({
      expectedLength: t,
      givenLength: e.length,
      type: `${n.type}[${t}]`,
    });
  let s = !1;
  const o = [];
  for (let i = 0; i < e.length; i++) {
    const a = ts({ param: n, value: e[i] });
    a.dynamic && (s = !0), o.push(a);
  }
  if (r || s) {
    const i = ns(o);
    if (r) {
      const a = z(o.length, { size: 32 });
      return { dynamic: !0, encoded: o.length > 0 ? Oe([a, i]) : a };
    }
    if (s) return { dynamic: !0, encoded: i };
  }
  return { dynamic: !1, encoded: Oe(o.map(({ encoded: i }) => i)) };
}
function Al(e, { param: t }) {
  const [, n] = t.type.split("bytes"),
    r = V(e);
  if (!n) {
    let s = e;
    return (
      r % 32 !== 0 &&
        (s = We(s, {
          dir: "right",
          size: Math.ceil((e.length - 2) / 2 / 32) * 32,
        })),
      { dynamic: !0, encoded: Oe([We(z(r, { size: 32 })), s]) }
    );
  }
  if (r !== Number.parseInt(n))
    throw new Bu({ expectedSize: Number.parseInt(n), value: e });
  return { dynamic: !1, encoded: We(e, { dir: "right" }) };
}
function Il(e) {
  if (typeof e != "boolean")
    throw new E(
      `Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`,
    );
  return { dynamic: !1, encoded: We(ui(e)) };
}
function Bl(e, { signed: t }) {
  return { dynamic: !1, encoded: z(e, { size: 32, signed: t }) };
}
function Cl(e) {
  const t = Pt(e),
    n = Math.ceil(V(t) / 32),
    r = [];
  for (let s = 0; s < n; s++)
    r.push(We(Gt(t, s * 32, (s + 1) * 32), { dir: "right" }));
  return { dynamic: !0, encoded: Oe([We(z(V(t), { size: 32 })), ...r]) };
}
function Tl(e, { param: t }) {
  let n = !1;
  const r = [];
  for (let s = 0; s < t.components.length; s++) {
    const o = t.components[s],
      i = Array.isArray(e) ? s : o.name,
      a = ts({ param: o, value: e[i] });
    r.push(a), a.dynamic && (n = !0);
  }
  return { dynamic: n, encoded: n ? ns(r) : Oe(r.map(({ encoded: s }) => s)) };
}
function rs(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0;
}
const ss = (e) => Gt(mi(e), 0, 4);
function St(e) {
  const { abi: t, args: n = [], name: r } = e,
    s = ve(r, { strict: !1 }),
    o = t.filter((a) =>
      s
        ? a.type === "function"
          ? ss(a) === r
          : a.type === "event"
            ? Qr(a) === r
            : !1
        : "name" in a && a.name === r,
    );
  if (o.length === 0) return;
  if (o.length === 1) return o[0];
  let i;
  for (const a of o) {
    if (!("inputs" in a)) continue;
    if (!n || n.length === 0) {
      if (!a.inputs || a.inputs.length === 0) return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== n.length)
      continue;
    if (
      n.every((u, d) => {
        const l = "inputs" in a && a.inputs[d];
        return l ? Ar(u, l) : !1;
      })
    ) {
      if (i && "inputs" in i && i.inputs) {
        const u = vi(a.inputs, i.inputs, n);
        if (u)
          throw new Su({ abiItem: a, type: u[0] }, { abiItem: i, type: u[1] });
      }
      i = a;
    }
  }
  return i || o[0];
}
function Ar(e, t) {
  const n = typeof e,
    r = t.type;
  switch (r) {
    case "address":
      return K(e, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in t
        ? Object.values(t.components).every((s, o) =>
            Ar(Object.values(e)[o], s),
          )
        : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
              r,
            )
          ? n === "number" || n === "bigint"
          : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)
            ? n === "string" || e instanceof Uint8Array
            : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)
              ? Array.isArray(e) &&
                e.every((s) =>
                  Ar(s, { ...t, type: r.replace(/(\[[0-9]{0,}\])$/, "") }),
                )
              : !1;
  }
}
function vi(e, t, n) {
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (
      s.type === "tuple" &&
      o.type === "tuple" &&
      "components" in s &&
      "components" in o
    )
      return vi(s.components, o.components, n[r]);
    const i = [s.type, o.type];
    if (
      i.includes("address") && i.includes("bytes20")
        ? !0
        : i.includes("address") && i.includes("string")
          ? K(n[r], { strict: !1 })
          : i.includes("address") && i.includes("bytes")
            ? K(n[r], { strict: !1 })
            : !1
    )
      return i;
  }
}
const ro = "/docs/contract/encodeEventTopics";
function dn(e) {
  let c;
  const { abi: t, eventName: n, args: r } = e;
  let s = t[0];
  if (n) {
    const u = St({ abi: t, name: n });
    if (!u) throw new Ks(n, { docsPath: ro });
    s = u;
  }
  if (s.type !== "event") throw new Ks(void 0, { docsPath: ro });
  const o = Me(s),
    i = Qr(o);
  let a = [];
  if (r && "inputs" in s) {
    const u =
        (c = s.inputs) == null
          ? void 0
          : c.filter((l) => "indexed" in l && l.indexed),
      d = Array.isArray(r)
        ? r
        : Object.values(r).length > 0
          ? ((u == null ? void 0 : u.map((l) => r[l.name])) ?? [])
          : [];
    d.length > 0 &&
      (a =
        (u == null
          ? void 0
          : u.map((l, f) =>
              Array.isArray(d[f])
                ? d[f].map((p, y) => so({ param: l, value: d[f][y] }))
                : d[f]
                  ? so({ param: l, value: d[f] })
                  : null,
            )) ?? []);
  }
  return [i, ...a];
}
function so({ param: e, value: t }) {
  if (e.type === "string" || e.type === "bytes") return Q(Ie(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/))
    throw new Ou(e.type);
  return kt([e], [t]);
}
function Vn(e, { method: t }) {
  let r, s;
  const n = {};
  return (
    e.transport.type === "fallback" &&
      ((s = (r = e.transport).onResponse) == null ||
        s.call(r, ({ method: o, response: i, status: a, transport: c }) => {
          a === "success" && t === o && (n[i] = c.request);
        })),
    (o) => n[o] || e.request
  );
}
async function xi(e, t) {
  const {
      address: n,
      abi: r,
      args: s,
      eventName: o,
      fromBlock: i,
      strict: a,
      toBlock: c,
    } = t,
    u = Vn(e, { method: "eth_newFilter" }),
    d = o ? dn({ abi: r, args: s, eventName: o }) : void 0,
    l = await e.request({
      method: "eth_newFilter",
      params: [
        {
          address: n,
          fromBlock: typeof i == "bigint" ? z(i) : i,
          toBlock: typeof c == "bigint" ? z(c) : c,
          topics: d,
        },
      ],
    });
  return {
    abi: r,
    args: s,
    eventName: o,
    id: l,
    request: u(l),
    strict: !!a,
    type: "event",
  };
}
function ye(e) {
  return typeof e == "string" ? { address: e, type: "json-rpc" } : e;
}
const oo = "/docs/contract/encodeFunctionData";
function kl(e) {
  const { abi: t, args: n, functionName: r } = e;
  let s = t[0];
  if (r) {
    const o = St({ abi: t, args: n, name: r });
    if (!o) throw new Mn(r, { docsPath: oo });
    s = o;
  }
  if (s.type !== "function") throw new Mn(void 0, { docsPath: oo });
  return { abi: [s], functionName: ss(Me(s)) };
}
function tt(e) {
  const { args: t } = e,
    { abi: n, functionName: r } = (() => {
      let a;
      return e.abi.length === 1 &&
        (a = e.functionName) != null &&
        a.startsWith("0x")
        ? e
        : kl(e);
    })(),
    s = n[0],
    o = r,
    i = "inputs" in s && s.inputs ? kt(s.inputs, t ?? []) : void 0;
  return Se([o, i ?? "0x"]);
}
const Ei = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type.",
  },
  Sl = {
    inputs: [{ name: "message", type: "string" }],
    name: "Error",
    type: "error",
  },
  Nl = {
    inputs: [{ name: "reason", type: "uint256" }],
    name: "Panic",
    type: "error",
  };
class io extends E {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError",
    });
  }
}
class Pi extends E {
  constructor({ length: t, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`, {
      name: "PositionOutOfBoundsError",
    });
  }
}
class Fl extends E {
  constructor({ count: t, limit: n }) {
    super(
      `Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`,
      { name: "RecursiveReadLimitExceededError" },
    );
  }
}
const Ll = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new Fl({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit,
      });
  },
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1)
      throw new Pi({ length: this.bytes.length, position: e });
  },
  decrementPosition(e) {
    if (e < 0) throw new io({ offset: e });
    const t = this.position - e;
    this.assertPosition(t), (this.position = t);
  },
  getReadCount(e) {
    return this.positionReadCount.get(e || this.position) || 0;
  },
  incrementPosition(e) {
    if (e < 0) throw new io({ offset: e });
    const t = this.position + e;
    this.assertPosition(t), (this.position = t);
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(e, t) {
    const n = t ?? this.position;
    return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e);
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return (
      this.assertPosition(t + 2),
      (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2)
    );
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(e) {
    this.assertPosition(this.position),
      (this.bytes[this.position] = e),
      this.position++;
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1),
      this.bytes.set(e, this.position),
      (this.position += e.length);
  },
  pushUint8(e) {
    this.assertPosition(this.position),
      (this.bytes[this.position] = e),
      this.position++;
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1),
      this.dataView.setUint16(this.position, e),
      (this.position += 2);
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2),
      this.dataView.setUint16(this.position, e >> 8),
      this.dataView.setUint8(this.position + 2, e & 255),
      (this.position += 3);
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3),
      this.dataView.setUint32(this.position, e),
      (this.position += 4);
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectByte();
    return this.position++, e;
  },
  readBytes(e, t) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(e);
    return (this.position += t ?? e), n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint8();
    return (this.position += 1), e;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint16();
    return (this.position += 2), e;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint24();
    return (this.position += 3), e;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint32();
    return (this.position += 4), e;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e) {
    const t = this.position;
    return (
      this.assertPosition(e), (this.position = e), () => (this.position = t)
    );
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const e = this.getReadCount();
    this.positionReadCount.set(this.position, e + 1),
      e > 0 && this.recursiveReadCount++;
  },
};
function os(e, { recursiveReadLimit: t = 8192 } = {}) {
  const n = Object.create(Ll);
  return (
    (n.bytes = e),
    (n.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength)),
    (n.positionReadCount = new Map()),
    (n.recursiveReadLimit = t),
    n
  );
}
function zl(e, t = {}) {
  typeof t.size < "u" && ke(e, { size: t.size });
  const n = X(e, t);
  return Y(n, t);
}
function Ml(e, t = {}) {
  let n = e;
  if (
    (typeof t.size < "u" && (ke(n, { size: t.size }), (n = Ke(n))),
    n.length > 1 || n[0] > 1)
  )
    throw new Uu(n);
  return !!n[0];
}
function ze(e, t = {}) {
  typeof t.size < "u" && ke(e, { size: t.size });
  const n = X(e, t);
  return Be(n, t);
}
function Ol(e, t = {}) {
  let n = e;
  return (
    typeof t.size < "u" &&
      (ke(n, { size: t.size }), (n = Ke(n, { dir: "right" }))),
    new TextDecoder().decode(n)
  );
}
function Zn(e, t) {
  const n = typeof t == "string" ? fe(t) : t,
    r = os(n);
  if (V(n) === 0 && e.length > 0) throw new qn();
  if (V(t) && V(t) < 32)
    throw new si({
      data: typeof t == "string" ? t : X(t),
      params: e,
      size: V(t),
    });
  let s = 0;
  const o = [];
  for (let i = 0; i < e.length; ++i) {
    const a = e[i];
    r.setPosition(s);
    const [c, u] = vt(r, a, { staticPosition: 0 });
    (s += u), o.push(c);
  }
  return o;
}
function vt(e, t, { staticPosition: n }) {
  const r = rs(t.type);
  if (r) {
    const [s, o] = r;
    return jl(e, { ...t, type: o }, { length: s, staticPosition: n });
  }
  if (t.type === "tuple") return Gl(e, t, { staticPosition: n });
  if (t.type === "address") return Rl(e);
  if (t.type === "bool") return Ul(e);
  if (t.type.startsWith("bytes")) return ql(e, t, { staticPosition: n });
  if (t.type.startsWith("uint") || t.type.startsWith("int")) return Dl(e, t);
  if (t.type === "string") return Hl(e, { staticPosition: n });
  throw new Lu(t.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
const ao = 32,
  Ir = 32;
function Rl(e) {
  const t = e.readBytes(32);
  return [ln(X(gi(t, -20))), 32];
}
function jl(e, t, { length: n, staticPosition: r }) {
  if (!n) {
    const i = ze(e.readBytes(Ir)),
      a = r + i,
      c = a + ao;
    e.setPosition(a);
    const u = ze(e.readBytes(ao)),
      d = Ht(t);
    let l = 0;
    const f = [];
    for (let p = 0; p < u; ++p) {
      e.setPosition(c + (d ? p * 32 : l));
      const [y, h] = vt(e, t, { staticPosition: c });
      (l += h), f.push(y);
    }
    return e.setPosition(r + 32), [f, 32];
  }
  if (Ht(t)) {
    const i = ze(e.readBytes(Ir)),
      a = r + i,
      c = [];
    for (let u = 0; u < n; ++u) {
      e.setPosition(a + u * 32);
      const [d] = vt(e, t, { staticPosition: a });
      c.push(d);
    }
    return e.setPosition(r + 32), [c, 32];
  }
  let s = 0;
  const o = [];
  for (let i = 0; i < n; ++i) {
    const [a, c] = vt(e, t, { staticPosition: r + s });
    (s += c), o.push(a);
  }
  return [o, s];
}
function Ul(e) {
  return [Ml(e.readBytes(32), { size: 32 }), 32];
}
function ql(e, t, { staticPosition: n }) {
  const [r, s] = t.type.split("bytes");
  if (!s) {
    const i = ze(e.readBytes(32));
    e.setPosition(n + i);
    const a = ze(e.readBytes(32));
    if (a === 0) return e.setPosition(n + 32), ["0x", 32];
    const c = e.readBytes(a);
    return e.setPosition(n + 32), [X(c), 32];
  }
  return [X(e.readBytes(Number.parseInt(s), 32)), 32];
}
function Dl(e, t) {
  const n = t.type.startsWith("int"),
    r = Number.parseInt(t.type.split("int")[1] || "256"),
    s = e.readBytes(32);
  return [r > 48 ? zl(s, { signed: n }) : ze(s, { signed: n }), 32];
}
function Gl(e, t, { staticPosition: n }) {
  const r = t.components.length === 0 || t.components.some(({ name: i }) => !i),
    s = r ? [] : {};
  let o = 0;
  if (Ht(t)) {
    const i = ze(e.readBytes(Ir)),
      a = n + i;
    for (let c = 0; c < t.components.length; ++c) {
      const u = t.components[c];
      e.setPosition(a + o);
      const [d, l] = vt(e, u, { staticPosition: a });
      (o += l), (s[r ? c : u == null ? void 0 : u.name] = d);
    }
    return e.setPosition(n + 32), [s, 32];
  }
  for (let i = 0; i < t.components.length; ++i) {
    const a = t.components[i],
      [c, u] = vt(e, a, { staticPosition: n });
    (s[r ? i : a == null ? void 0 : a.name] = c), (o += u);
  }
  return [s, o];
}
function Hl(e, { staticPosition: t }) {
  const n = ze(e.readBytes(32)),
    r = t + n;
  e.setPosition(r);
  const s = ze(e.readBytes(32));
  if (s === 0) return e.setPosition(t + 32), ["", 32];
  const o = e.readBytes(s, 32),
    i = Ol(Ke(o));
  return e.setPosition(t + 32), [i, 32];
}
function Ht(e) {
  let r;
  const { type: t } = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]")) return !0;
  if (t === "tuple") return (r = e.components) == null ? void 0 : r.some(Ht);
  const n = rs(e.type);
  return !!(n && Ht({ ...e, type: n[1] }));
}
function Vl(e) {
  const { abi: t, data: n } = e,
    r = Gt(n, 0, 4);
  if (r === "0x") throw new qn();
  const o = [...(t || []), Sl, Nl].find(
    (i) => i.type === "error" && r === ss(Me(i)),
  );
  if (!o) throw new oi(r, { docsPath: "/docs/contract/decodeErrorResult" });
  return {
    abiItem: o,
    args:
      "inputs" in o && o.inputs && o.inputs.length > 0
        ? Zn(o.inputs, Gt(n, 4))
        : void 0,
    errorName: o.name,
  };
}
const ae = (e, t, n) =>
  JSON.stringify(e, (r, s) => (typeof s == "bigint" ? s.toString() : s), n);
function _i({
  abiItem: e,
  args: t,
  includeFunctionName: n = !0,
  includeName: r = !1,
}) {
  if ("name" in e && "inputs" in e && e.inputs)
    return `${n ? e.name : ""}(${e.inputs.map((s, o) => `${r && s.name ? `${s.name}: ` : ""}${typeof t[o] == "object" ? ae(t[o]) : t[o]}`).join(", ")})`;
}
const Zl = { gwei: 9, wei: 18 },
  Wl = { ether: -9, wei: 9 };
function lt(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), (n = n.padStart(t, "0"));
  let [s, o] = [n.slice(0, n.length - t), n.slice(n.length - t)];
  return (
    (o = o.replace(/(0+)$/, "")),
    `${r ? "-" : ""}${s || "0"}${o ? `.${o}` : ""}`
  );
}
function is(e, t = "wei") {
  return lt(e, Zl[t]);
}
function he(e, t = "wei") {
  return lt(e, Wl[t]);
}
class Kl extends E {
  constructor({ address: t }) {
    super(`State for account "${t}" is set multiple times.`, {
      name: "AccountStateConflictError",
    });
  }
}
class Yl extends E {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError",
    });
  }
}
function co(e) {
  return e.reduce(
    (t, { slot: n, value: r }) => `${t}        ${n}: ${r}
`,
    "",
  );
}
function Jl(e) {
  return e
    .reduce(
      (t, { address: n, ...r }) => {
        let s = `${t}    ${n}:
`;
        return (
          r.nonce &&
            (s += `      nonce: ${r.nonce}
`),
          r.balance &&
            (s += `      balance: ${r.balance}
`),
          r.code &&
            (s += `      code: ${r.code}
`),
          r.state &&
            ((s += `      state:
`),
            (s += co(r.state))),
          r.stateDiff &&
            ((s += `      stateDiff:
`),
            (s += co(r.stateDiff))),
          s
        );
      },
      `  State Override:
`,
    )
    .slice(0, -1);
}
function fn(e) {
  const t = Object.entries(e)
      .map(([r, s]) => (s === void 0 || s === !1 ? null : [r, s]))
      .filter(Boolean),
    n = t.reduce((r, [s]) => Math.max(r, s.length), 0);
  return t.map(([r, s]) => `  ${`${r}:`.padEnd(n + 1)}  ${s}`).join(`
`);
}
class Xl extends E {
  constructor() {
    super(
      [
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.",
      ].join(`
`),
      { name: "FeeConflictError" },
    );
  }
}
class Ql extends E {
  constructor({ v: t }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError",
    });
  }
}
class ed extends E {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        fn(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`",
      ],
      name: "InvalidSerializableTransactionError",
    });
  }
}
class td extends E {
  constructor({ storageKey: t }) {
    super(
      `Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length - 2) / 2)} bytes.`,
      { name: "InvalidStorageKeySizeError" },
    );
  }
}
class nd extends E {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: o,
      gas: i,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: d,
      to: l,
      value: f,
    },
  ) {
    let y;
    const p = fn({
      chain:
        s &&
        `${s == null ? void 0 : s.name} (id: ${s == null ? void 0 : s.id})`,
      from: n == null ? void 0 : n.address,
      to: l,
      value:
        typeof f < "u" &&
        `${is(f)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || "ETH"}`,
      data: o,
      gas: i,
      gasPrice: typeof a < "u" && `${he(a)} gwei`,
      maxFeePerGas: typeof c < "u" && `${he(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${he(u)} gwei`,
      nonce: d,
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...(t.metaMessages ? [...t.metaMessages, " "] : []),
        "Request Arguments:",
        p,
      ].filter(Boolean),
      name: "TransactionExecutionError",
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = t);
  }
}
class $i extends E {
  constructor({
    blockHash: t,
    blockNumber: n,
    blockTag: r,
    hash: s,
    index: o,
  }) {
    let i = "Transaction";
    r &&
      o !== void 0 &&
      (i = `Transaction at block time "${r}" at index "${o}"`),
      t &&
        o !== void 0 &&
        (i = `Transaction at block hash "${t}" at index "${o}"`),
      n &&
        o !== void 0 &&
        (i = `Transaction at block number "${n}" at index "${o}"`),
      s && (i = `Transaction with hash "${s}"`),
      super(`${i} could not be found.`, { name: "TransactionNotFoundError" });
  }
}
class Ai extends E {
  constructor({ hash: t }) {
    super(
      `Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`,
      { name: "TransactionReceiptNotFoundError" },
    );
  }
}
class uo extends E {
  constructor({ hash: t }) {
    super(
      `Timed out while waiting for transaction with hash "${t}" to be confirmed.`,
      { name: "WaitForTransactionReceiptTimeoutError" },
    );
  }
}
const rd = (e) => e,
  as = (e) => e;
class Ii extends E {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: o,
      gas: i,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: d,
      to: l,
      value: f,
      stateOverride: p,
    },
  ) {
    let m;
    const y = n ? ye(n) : void 0;
    let h = fn({
      from: y == null ? void 0 : y.address,
      to: l,
      value:
        typeof f < "u" &&
        `${is(f)} ${((m = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : m.symbol) || "ETH"}`,
      data: o,
      gas: i,
      gasPrice: typeof a < "u" && `${he(a)} gwei`,
      maxFeePerGas: typeof c < "u" && `${he(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${he(u)} gwei`,
      nonce: d,
    });
    p &&
      (h += `
${Jl(p)}`),
      super(t.shortMessage, {
        cause: t,
        docsPath: r,
        metaMessages: [
          ...(t.metaMessages ? [...t.metaMessages, " "] : []),
          "Raw Call Arguments:",
          h,
        ].filter(Boolean),
        name: "CallExecutionError",
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = t);
  }
}
class sd extends E {
  constructor(
    t,
    {
      abi: n,
      args: r,
      contractAddress: s,
      docsPath: o,
      functionName: i,
      sender: a,
    },
  ) {
    const c = St({ abi: n, args: r, name: i }),
      u = c
        ? _i({ abiItem: c, args: r, includeFunctionName: !1, includeName: !1 })
        : void 0,
      d = c ? Me(c, { includeName: !0 }) : void 0,
      l = fn({
        address: s && rd(s),
        function: d,
        args:
          u &&
          u !== "()" &&
          `${[...Array((i == null ? void 0 : i.length) ?? 0).keys()].map(() => " ").join("")}${u}`,
        sender: a,
      });
    super(
      t.shortMessage ||
        `An unknown error occurred while executing the contract function "${i}".`,
      {
        cause: t,
        docsPath: o,
        metaMessages: [
          ...(t.metaMessages ? [...t.metaMessages, " "] : []),
          l && "Contract Call:",
          l,
        ].filter(Boolean),
        name: "ContractFunctionExecutionError",
      },
    ),
      Object.defineProperty(this, "abi", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "args", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "contractAddress", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "formattedArgs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "functionName", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "sender", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abi = n),
      (this.args = r),
      (this.cause = t),
      (this.contractAddress = s),
      (this.functionName = i),
      (this.sender = a);
  }
}
class Br extends E {
  constructor({ abi: t, data: n, functionName: r, message: s }) {
    let o, i, a, c;
    if (n && n !== "0x")
      try {
        i = Vl({ abi: t, data: n });
        const { abiItem: d, errorName: l, args: f } = i;
        if (l === "Error") c = f[0];
        else if (l === "Panic") {
          const [p] = f;
          c = Ei[p];
        } else {
          const p = d ? Me(d, { includeName: !0 }) : void 0,
            y =
              d && f
                ? _i({
                    abiItem: d,
                    args: f,
                    includeFunctionName: !1,
                    includeName: !1,
                  })
                : void 0;
          a = [
            p ? `Error: ${p}` : "",
            y && y !== "()"
              ? `       ${[...Array((l == null ? void 0 : l.length) ?? 0).keys()].map(() => " ").join("")}${y}`
              : "",
          ];
        }
      } catch (d) {
        o = d;
      }
    else s && (c = s);
    let u;
    o instanceof oi &&
      ((u = o.signature),
      (a = [
        `Unable to decode signature "${u}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`,
      ])),
      super(
        (c && c !== "execution reverted") || u
          ? [
              `The contract function "${r}" reverted with the following ${u ? "signature" : "reason"}:`,
              c || u,
            ].join(`
`)
          : `The contract function "${r}" reverted.`,
        { cause: o, metaMessages: a, name: "ContractFunctionRevertedError" },
      ),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "reason", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = i),
      (this.reason = c),
      (this.signature = u);
  }
}
class od extends E {
  constructor({ functionName: t }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${t}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract.",
      ],
      name: "ContractFunctionZeroDataError",
    });
  }
}
class id extends E {
  constructor({ factory: t }) {
    super(
      `Deployment for counterfactual contract call failed${t ? ` for factory "${t}".` : ""}`,
      {
        metaMessages: [
          "Please ensure:",
          "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
          "- The `factoryData` is a valid encoded function call for contract deployment function on the factory.",
        ],
        name: "CounterfactualDeploymentFailedError",
      },
    );
  }
}
class cs extends E {
  constructor({ data: t, message: n }) {
    super(n || "", { name: "RawContractError" }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = t);
  }
}
class qt extends E {
  constructor({
    body: t,
    cause: n,
    details: r,
    headers: s,
    status: o,
    url: i,
  }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        o && `Status: ${o}`,
        `URL: ${as(i)}`,
        t && `Request body: ${ae(t)}`,
      ].filter(Boolean),
      name: "HttpRequestError",
    }),
      Object.defineProperty(this, "body", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "url", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.body = t),
      (this.headers = s),
      (this.status = o),
      (this.url = i);
  }
}
class Bi extends E {
  constructor({ body: t, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${as(r)}`, `Request body: ${ae(t)}`],
      name: "RpcRequestError",
    }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.code = n.code);
  }
}
class lo extends E {
  constructor({ body: t, url: n }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${as(n)}`, `Request body: ${ae(t)}`],
      name: "TimeoutError",
    });
  }
}
const ad = -1;
class pe extends E {
  constructor(
    t,
    { code: n, docsPath: r, metaMessages: s, name: o, shortMessage: i },
  ) {
    super(i, {
      cause: t,
      docsPath: r,
      metaMessages: s || (t == null ? void 0 : t.metaMessages),
      name: o || "RpcError",
    }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.name = o || t.name),
      (this.code = t instanceof Bi ? t.code : (n ?? ad));
  }
}
class Nt extends pe {
  constructor(t, n) {
    super(t, n),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = n.data);
  }
}
class Vt extends pe {
  constructor(t) {
    super(t, {
      code: Vt.code,
      name: "ParseRpcError",
      shortMessage:
        "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
    });
  }
}
Object.defineProperty(Vt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700,
});
class Zt extends pe {
  constructor(t) {
    super(t, {
      code: Zt.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object.",
    });
  }
}
Object.defineProperty(Zt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600,
});
class Wt extends pe {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: Wt.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${n ? ` "${n}"` : ""} does not exist / is not available.`,
    });
  }
}
Object.defineProperty(Wt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601,
});
class Kt extends pe {
  constructor(t) {
    super(t, {
      code: Kt.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    });
  }
}
Object.defineProperty(Kt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602,
});
class dt extends pe {
  constructor(t) {
    super(t, {
      code: dt.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received.",
    });
  }
}
Object.defineProperty(dt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603,
});
class ft extends pe {
  constructor(t) {
    super(t, {
      code: ft.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    });
  }
}
Object.defineProperty(ft, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3,
});
class Yt extends pe {
  constructor(t) {
    super(t, {
      code: Yt.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ResourceNotFoundRpcError",
      });
  }
}
Object.defineProperty(Yt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001,
});
class Jt extends pe {
  constructor(t) {
    super(t, {
      code: Jt.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available.",
    });
  }
}
Object.defineProperty(Jt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002,
});
class Xt extends pe {
  constructor(t) {
    super(t, {
      code: Xt.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed.",
    });
  }
}
Object.defineProperty(Xt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003,
});
class Qt extends pe {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: Qt.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${n ? ` "${n}"` : ""} is not implemented.`,
    });
  }
}
Object.defineProperty(Qt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004,
});
class $t extends pe {
  constructor(t) {
    super(t, {
      code: $t.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit.",
    });
  }
}
Object.defineProperty($t, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005,
});
class en extends pe {
  constructor(t) {
    super(t, {
      code: en.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported.",
    });
  }
}
Object.defineProperty(en, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006,
});
class xt extends Nt {
  constructor(t) {
    super(t, {
      code: xt.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request.",
    });
  }
}
Object.defineProperty(xt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001,
});
class tn extends Nt {
  constructor(t) {
    super(t, {
      code: tn.code,
      name: "UnauthorizedProviderError",
      shortMessage:
        "The requested method and/or account has not been authorized by the user.",
    });
  }
}
Object.defineProperty(tn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100,
});
class nn extends Nt {
  constructor(t, { method: n } = {}) {
    super(t, {
      code: nn.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${n ? ` " ${n}"` : ""}.`,
    });
  }
}
Object.defineProperty(nn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200,
});
class rn extends Nt {
  constructor(t) {
    super(t, {
      code: rn.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains.",
    });
  }
}
Object.defineProperty(rn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900,
});
class sn extends Nt {
  constructor(t) {
    super(t, {
      code: sn.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain.",
    });
  }
}
Object.defineProperty(sn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901,
});
class on extends Nt {
  constructor(t) {
    super(t, {
      code: on.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain.",
    });
  }
}
Object.defineProperty(on, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902,
});
class cd extends pe {
  constructor(t) {
    super(t, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred.",
    });
  }
}
const ud = 3;
function At(
  e,
  { abi: t, address: n, args: r, docsPath: s, functionName: o, sender: i },
) {
  const {
      code: a,
      data: c,
      message: u,
      shortMessage: d,
    } = e instanceof cs
      ? e
      : e instanceof E
        ? e.walk((f) => "data" in f) || e.walk()
        : {},
    l =
      e instanceof qn
        ? new od({ functionName: o })
        : [ud, dt.code].includes(a) && (c || u || d)
          ? new Br({
              abi: t,
              data: typeof c == "object" ? c.data : c,
              functionName: o,
              message: d ?? u,
            })
          : e;
  return new sd(l, {
    abi: t,
    args: r,
    contractAddress: n,
    docsPath: s,
    functionName: o,
    sender: i,
  });
}
function Ci(e) {
  const t = Q(`0x${e.substring(4)}`).substring(26);
  return ln(`0x${t}`);
}
async function ld({ hash: e, signature: t }) {
  const n = ve(e) ? e : S(e),
    { secp256k1: r } = await Mo(
      async () => {
        const { secp256k1: i } = await Promise.resolve().then(() => th);
        return { secp256k1: i };
      },
      void 0,
      import.meta.url,
    );
  return `0x${(() => {
    if (typeof t == "object" && "r" in t && "s" in t) {
      const { r: u, s: d, v: l, yParity: f } = t,
        p = Number(f ?? l),
        y = fo(p);
      return new r.Signature(Y(u), Y(d)).addRecoveryBit(y);
    }
    const i = ve(t) ? t : S(t),
      a = Be(`0x${i.slice(130)}`),
      c = fo(a);
    return r.Signature.fromCompact(i.substring(2, 130)).addRecoveryBit(c);
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`;
}
function fo(e) {
  if (e === 0 || e === 1) return e;
  if (e === 27) return 0;
  if (e === 28) return 1;
  throw new Error("Invalid yParityOrV value");
}
async function Ti({ hash: e, signature: t }) {
  return Ci(await ld({ hash: e, signature: t }));
}
function Ye(e, t = "hex") {
  const n = ki(e),
    r = os(new Uint8Array(n.length));
  return n.encode(r), t === "hex" ? X(r.bytes) : r.bytes;
}
function ki(e) {
  return Array.isArray(e) ? dd(e.map((t) => ki(t))) : fd(e);
}
function dd(e) {
  const t = e.reduce((s, o) => s + o.length, 0),
    n = Si(t);
  return {
    length: t <= 55 ? 1 + t : 1 + n + t,
    encode(s) {
      t <= 55
        ? s.pushByte(192 + t)
        : (s.pushByte(247 + n),
          n === 1
            ? s.pushUint8(t)
            : n === 2
              ? s.pushUint16(t)
              : n === 3
                ? s.pushUint24(t)
                : s.pushUint32(t));
      for (const { encode: o } of e) o(s);
    },
  };
}
function fd(e) {
  const t = typeof e == "string" ? fe(e) : e,
    n = Si(t.length);
  return {
    length:
      t.length === 1 && t[0] < 128
        ? 1
        : t.length <= 55
          ? 1 + t.length
          : 1 + n + t.length,
    encode(s) {
      t.length === 1 && t[0] < 128
        ? s.pushBytes(t)
        : t.length <= 55
          ? (s.pushByte(128 + t.length), s.pushBytes(t))
          : (s.pushByte(183 + n),
            n === 1
              ? s.pushUint8(t.length)
              : n === 2
                ? s.pushUint16(t.length)
                : n === 3
                  ? s.pushUint24(t.length)
                  : s.pushUint32(t.length),
            s.pushBytes(t));
    },
  };
}
function Si(e) {
  if (e < 2 ** 8) return 1;
  if (e < 2 ** 16) return 2;
  if (e < 2 ** 24) return 3;
  if (e < 2 ** 32) return 4;
  throw new E("Length is too large.");
}
function Ni(e) {
  const { chainId: t, contractAddress: n, nonce: r, to: s } = e,
    o = Q(Se(["0x05", Ye([z(t), n, z(r)])]));
  return s === "bytes" ? fe(o) : o;
}
async function Fi(e) {
  const { authorization: t, signature: n } = e;
  return Ti({ hash: Ni(t), signature: n ?? t });
}
class hd extends E {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: s,
      data: o,
      gas: i,
      gasPrice: a,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      nonce: d,
      to: l,
      value: f,
    },
  ) {
    let y;
    const p = fn({
      from: n == null ? void 0 : n.address,
      to: l,
      value:
        typeof f < "u" &&
        `${is(f)} ${((y = s == null ? void 0 : s.nativeCurrency) == null ? void 0 : y.symbol) || "ETH"}`,
      data: o,
      gas: i,
      gasPrice: typeof a < "u" && `${he(a)} gwei`,
      maxFeePerGas: typeof c < "u" && `${he(c)} gwei`,
      maxPriorityFeePerGas: typeof u < "u" && `${he(u)} gwei`,
      nonce: d,
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...(t.metaMessages ? [...t.metaMessages, " "] : []),
        "Estimate Gas Arguments:",
        p,
      ].filter(Boolean),
      name: "EstimateGasExecutionError",
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = t);
  }
}
class wt extends E {
  constructor({ cause: t, message: n } = {}) {
    let s;
    const r =
      (s = n == null ? void 0 : n.replace("execution reverted: ", "")) == null
        ? void 0
        : s.replace("execution reverted", "");
    super(
      `Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`,
      { cause: t, name: "ExecutionRevertedError" },
    );
  }
}
Object.defineProperty(wt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3,
});
Object.defineProperty(wt, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/,
});
class ht extends E {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${he(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: t, name: "FeeCapTooHighError" },
    );
  }
}
Object.defineProperty(ht, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
});
class Cr extends E {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${n ? ` = ${he(n)}` : ""} gwei) cannot be lower than the block base fee.`,
      { cause: t, name: "FeeCapTooLowError" },
    );
  }
}
Object.defineProperty(Cr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
});
class Tr extends E {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`,
      { cause: t, name: "NonceTooHighError" },
    );
  }
}
Object.defineProperty(Tr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/,
});
class kr extends E {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      [
        `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`.",
      ].join(`
`),
      { cause: t, name: "NonceTooLowError" },
    );
  }
}
Object.defineProperty(kr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/,
});
class Sr extends E {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`,
      { cause: t, name: "NonceMaxValueError" },
    );
  }
}
Object.defineProperty(Sr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/,
});
class Nr extends E {
  constructor({ cause: t } = {}) {
    super(
      [
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
      ].join(`
`),
      {
        cause: t,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient.",
        ],
        name: "InsufficientFundsError",
      },
    );
  }
}
Object.defineProperty(Nr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/,
});
class Fr extends E {
  constructor({ cause: t, gas: n } = {}) {
    super(
      `The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`,
      { cause: t, name: "IntrinsicGasTooHighError" },
    );
  }
}
Object.defineProperty(Fr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/,
});
class Lr extends E {
  constructor({ cause: t, gas: n } = {}) {
    super(
      `The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`,
      { cause: t, name: "IntrinsicGasTooLowError" },
    );
  }
}
Object.defineProperty(Lr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/,
});
class zr extends E {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
      name: "TransactionTypeNotSupportedError",
    });
  }
}
Object.defineProperty(zr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/,
});
class an extends E {
  constructor({ cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${he(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${he(r)} gwei` : ""}).`,
      ].join(`
`),
      { cause: t, name: "TipAboveFeeCapError" },
    );
  }
}
Object.defineProperty(an, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
});
class Wn extends E {
  constructor({ cause: t }) {
    super(
      `An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`,
      { cause: t, name: "UnknownNodeError" },
    );
  }
}
function us(e, t) {
  const n = (e.details || "").toLowerCase(),
    r = e instanceof E ? e.walk((s) => s.code === wt.code) : e;
  return r instanceof E
    ? new wt({ cause: e, message: r.details })
    : wt.nodeMessage.test(n)
      ? new wt({ cause: e, message: e.details })
      : ht.nodeMessage.test(n)
        ? new ht({
            cause: e,
            maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
          })
        : Cr.nodeMessage.test(n)
          ? new Cr({
              cause: e,
              maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
            })
          : Tr.nodeMessage.test(n)
            ? new Tr({ cause: e, nonce: t == null ? void 0 : t.nonce })
            : kr.nodeMessage.test(n)
              ? new kr({ cause: e, nonce: t == null ? void 0 : t.nonce })
              : Sr.nodeMessage.test(n)
                ? new Sr({ cause: e, nonce: t == null ? void 0 : t.nonce })
                : Nr.nodeMessage.test(n)
                  ? new Nr({ cause: e })
                  : Fr.nodeMessage.test(n)
                    ? new Fr({ cause: e, gas: t == null ? void 0 : t.gas })
                    : Lr.nodeMessage.test(n)
                      ? new Lr({ cause: e, gas: t == null ? void 0 : t.gas })
                      : zr.nodeMessage.test(n)
                        ? new zr({ cause: e })
                        : an.nodeMessage.test(n)
                          ? new an({
                              cause: e,
                              maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
                              maxPriorityFeePerGas:
                                t == null ? void 0 : t.maxPriorityFeePerGas,
                            })
                          : new Wn({ cause: e });
}
function pd(e, { docsPath: t, ...n }) {
  const r = (() => {
    const s = us(e, n);
    return s instanceof Wn ? e : s;
  })();
  return new hd(r, { docsPath: t, ...n });
}
function ls(e, { format: t }) {
  if (!t) return {};
  const n = {};
  function r(o) {
    const i = Object.keys(o);
    for (const a of i)
      a in e && (n[a] = e[a]),
        o[a] && typeof o[a] == "object" && !Array.isArray(o[a]) && r(o[a]);
  }
  const s = t(e || {});
  return r(s), n;
}
function Kn(e, t) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (s) => {
      const o = t(s);
      if (n) for (const i of n) delete o[i];
      return { ...o, ...r(s) };
    },
    type: e,
  });
}
const md = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4",
};
function hn(e) {
  const t = {};
  return (
    typeof e.authorizationList < "u" &&
      (t.authorizationList = bd(e.authorizationList)),
    typeof e.accessList < "u" && (t.accessList = e.accessList),
    typeof e.blobVersionedHashes < "u" &&
      (t.blobVersionedHashes = e.blobVersionedHashes),
    typeof e.blobs < "u" &&
      (typeof e.blobs[0] != "string"
        ? (t.blobs = e.blobs.map((n) => X(n)))
        : (t.blobs = e.blobs)),
    typeof e.data < "u" && (t.data = e.data),
    typeof e.from < "u" && (t.from = e.from),
    typeof e.gas < "u" && (t.gas = z(e.gas)),
    typeof e.gasPrice < "u" && (t.gasPrice = z(e.gasPrice)),
    typeof e.maxFeePerBlobGas < "u" &&
      (t.maxFeePerBlobGas = z(e.maxFeePerBlobGas)),
    typeof e.maxFeePerGas < "u" && (t.maxFeePerGas = z(e.maxFeePerGas)),
    typeof e.maxPriorityFeePerGas < "u" &&
      (t.maxPriorityFeePerGas = z(e.maxPriorityFeePerGas)),
    typeof e.nonce < "u" && (t.nonce = z(e.nonce)),
    typeof e.to < "u" && (t.to = e.to),
    typeof e.type < "u" && (t.type = md[e.type]),
    typeof e.value < "u" && (t.value = z(e.value)),
    t
  );
}
const yd = Kn("transactionRequest", hn);
function bd(e) {
  return e.map((t) => ({
    address: t.contractAddress,
    r: t.r,
    s: t.s,
    chainId: z(t.chainId),
    nonce: z(t.nonce),
    ...(typeof t.yParity < "u" ? { yParity: z(t.yParity) } : {}),
    ...(typeof t.v < "u" && typeof t.yParity > "u" ? { v: z(t.v) } : {}),
  }));
}
function ho(e) {
  if (!(!e || e.length === 0))
    return e.reduce((t, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new Ys({ size: n.length, targetSize: 66, type: "hex" });
      if (r.length !== 66)
        throw new Ys({ size: r.length, targetSize: 66, type: "hex" });
      return (t[n] = r), t;
    }, {});
}
function gd(e) {
  const { balance: t, nonce: n, state: r, stateDiff: s, code: o } = e,
    i = {};
  if (
    (o !== void 0 && (i.code = o),
    t !== void 0 && (i.balance = z(t)),
    n !== void 0 && (i.nonce = z(n)),
    r !== void 0 && (i.state = ho(r)),
    s !== void 0)
  ) {
    if (i.state) throw new Yl();
    i.stateDiff = ho(s);
  }
  return i;
}
function Li(e) {
  if (!e) return;
  const t = {};
  for (const { address: n, ...r } of e) {
    if (!K(n, { strict: !1 })) throw new se({ address: n });
    if (t[n]) throw new Kl({ address: n });
    t[n] = gd(r);
  }
  return t;
}
function pn(e) {
  const {
      account: t,
      gasPrice: n,
      maxFeePerGas: r,
      maxPriorityFeePerGas: s,
      to: o,
    } = e,
    i = t ? ye(t) : void 0;
  if (i && !K(i.address)) throw new se({ address: i.address });
  if (o && !K(o)) throw new se({ address: o });
  if (typeof n < "u" && (typeof r < "u" || typeof s < "u")) throw new Xl();
  if (r && r > 2n ** 256n - 1n) throw new ht({ maxFeePerGas: r });
  if (s && r && s > r)
    throw new an({ maxFeePerGas: r, maxPriorityFeePerGas: s });
}
class wd extends E {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError",
    });
  }
}
class ds extends E {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError",
    });
  }
}
class vd extends E {
  constructor({ maxPriorityFeePerGas: t }) {
    super(
      `\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${he(t)} gwei).`,
      { name: "MaxFeePerGasTooLowError" },
    );
  }
}
class zi extends E {
  constructor({ blockHash: t, blockNumber: n }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const Mi = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702",
};
function fs(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Be(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas
      ? BigInt(e.maxPriorityFeePerGas)
      : void 0,
    nonce: e.nonce ? Be(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? Mi[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0,
  };
  return (
    e.authorizationList && (t.authorizationList = Ed(e.authorizationList)),
    (t.yParity = (() => {
      if (e.yParity) return Number(e.yParity);
      if (typeof t.v == "bigint") {
        if (t.v === 0n || t.v === 27n) return 0;
        if (t.v === 1n || t.v === 28n) return 1;
        if (t.v >= 35n) return t.v % 2n === 0n ? 1 : 0;
      }
    })()),
    t.type === "legacy" &&
      (delete t.accessList,
      delete t.maxFeePerBlobGas,
      delete t.maxFeePerGas,
      delete t.maxPriorityFeePerGas,
      delete t.yParity),
    t.type === "eip2930" &&
      (delete t.maxFeePerBlobGas,
      delete t.maxFeePerGas,
      delete t.maxPriorityFeePerGas),
    t.type === "eip1559" && delete t.maxFeePerBlobGas,
    t
  );
}
const xd = Kn("transaction", fs);
function Ed(e) {
  return e.map((t) => ({
    contractAddress: t.address,
    r: t.r,
    s: t.s,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    ...(typeof t.yParity < "u" ? { yParity: Number(t.yParity) } : {}),
    ...(typeof t.v < "u" && typeof t.yParity > "u" ? { v: Number(t.v) } : {}),
  }));
}
function hs(e) {
  let n;
  const t =
    (n = e.transactions) == null
      ? void 0
      : n.map((r) => (typeof r == "string" ? r : fs(r)));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null,
  };
}
const Pd = Kn("block", hs);
async function Je(
  e,
  { blockHash: t, blockNumber: n, blockTag: r, includeTransactions: s } = {},
) {
  let d, l, f;
  const o = r ?? "latest",
    i = s ?? !1,
    a = n !== void 0 ? z(n) : void 0;
  let c = null;
  if (
    (t
      ? (c = await e.request(
          { method: "eth_getBlockByHash", params: [t, i] },
          { dedupe: !0 },
        ))
      : (c = await e.request(
          { method: "eth_getBlockByNumber", params: [a || o, i] },
          { dedupe: !!a },
        )),
    !c)
  )
    throw new zi({ blockHash: t, blockNumber: n });
  return (
    ((f =
      (l = (d = e.chain) == null ? void 0 : d.formatters) == null
        ? void 0
        : l.block) == null
      ? void 0
      : f.format) || hs
  )(c);
}
async function ps(e) {
  const t = await e.request({ method: "eth_gasPrice" });
  return BigInt(t);
}
async function _d(e, t) {
  return Oi(e, t);
}
async function Oi(e, t) {
  let o, i, a;
  const { block: n, chain: r = e.chain, request: s } = t || {};
  if (
    typeof ((o = r == null ? void 0 : r.fees) == null
      ? void 0
      : o.defaultPriorityFee) == "function"
  ) {
    const c = n || (await O(e, Je, "getBlock")({}));
    return r.fees.defaultPriorityFee({ block: c, client: e, request: s });
  }
  if (
    typeof ((i = r == null ? void 0 : r.fees) == null
      ? void 0
      : i.defaultPriorityFee) < "u"
  )
    return (a = r == null ? void 0 : r.fees) == null
      ? void 0
      : a.defaultPriorityFee;
  try {
    const c = await e.request({ method: "eth_maxPriorityFeePerGas" });
    return Y(c);
  } catch {
    const [c, u] = await Promise.all([
      n ? Promise.resolve(n) : O(e, Je, "getBlock")({}),
      O(e, ps, "getGasPrice")({}),
    ]);
    if (typeof c.baseFeePerGas != "bigint") throw new ds();
    const d = u - c.baseFeePerGas;
    return d < 0n ? 0n : d;
  }
}
async function $d(e, t) {
  return Mr(e, t);
}
async function Mr(e, t) {
  let f, p;
  const {
      block: n,
      chain: r = e.chain,
      request: s,
      type: o = "eip1559",
    } = t || {},
    i = await (async () => {
      let y, h;
      return typeof ((y = r == null ? void 0 : r.fees) == null
        ? void 0
        : y.baseFeeMultiplier) == "function"
        ? r.fees.baseFeeMultiplier({ block: n, client: e, request: s })
        : (((h = r == null ? void 0 : r.fees) == null
            ? void 0
            : h.baseFeeMultiplier) ?? 1.2);
    })();
  if (i < 1) throw new wd();
  const c =
      10 **
      (((f = i.toString().split(".")[1]) == null ? void 0 : f.length) ?? 0),
    u = (y) => (y * BigInt(Math.ceil(i * c))) / BigInt(c),
    d = n || (await O(e, Je, "getBlock")({}));
  if (
    typeof ((p = r == null ? void 0 : r.fees) == null
      ? void 0
      : p.estimateFeesPerGas) == "function"
  ) {
    const y = await r.fees.estimateFeesPerGas({
      block: n,
      client: e,
      multiply: u,
      request: s,
      type: o,
    });
    if (y !== null) return y;
  }
  if (o === "eip1559") {
    if (typeof d.baseFeePerGas != "bigint") throw new ds();
    const y =
        typeof (s == null ? void 0 : s.maxPriorityFeePerGas) == "bigint"
          ? s.maxPriorityFeePerGas
          : await Oi(e, { block: d, chain: r, request: s }),
      h = u(d.baseFeePerGas);
    return {
      maxFeePerGas: (s == null ? void 0 : s.maxFeePerGas) ?? h + y,
      maxPriorityFeePerGas: y,
    };
  }
  return {
    gasPrice:
      (s == null ? void 0 : s.gasPrice) ?? u(await O(e, ps, "getGasPrice")({})),
  };
}
async function Ri(e, { address: t, blockTag: n = "latest", blockNumber: r }) {
  const s = await e.request(
    { method: "eth_getTransactionCount", params: [t, r ? z(r) : n] },
    { dedupe: !!r },
  );
  return Be(s);
}
function ms(e) {
  const { kzg: t } = e,
    n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"),
    r = typeof e.blobs[0] == "string" ? e.blobs.map((o) => fe(o)) : e.blobs,
    s = [];
  for (const o of r) s.push(Uint8Array.from(t.blobToKzgCommitment(o)));
  return n === "bytes" ? s : s.map((o) => X(o));
}
function ys(e) {
  const { kzg: t } = e,
    n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"),
    r = typeof e.blobs[0] == "string" ? e.blobs.map((i) => fe(i)) : e.blobs,
    s =
      typeof e.commitments[0] == "string"
        ? e.commitments.map((i) => fe(i))
        : e.commitments,
    o = [];
  for (let i = 0; i < r.length; i++) {
    const a = r[i],
      c = s[i];
    o.push(Uint8Array.from(t.computeBlobKzgProof(a, c)));
  }
  return n === "bytes" ? o : o.map((i) => X(i));
}
function Ad(e, t, n, r) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r);
  const s = BigInt(32),
    o = BigInt(4294967295),
    i = Number((n >> s) & o),
    a = Number(n & o),
    c = r ? 4 : 0,
    u = r ? 0 : 4;
  e.setUint32(t + c, i, r), e.setUint32(t + u, a, r);
}
const Id = (e, t, n) => (e & t) ^ (~e & n),
  Bd = (e, t, n) => (e & t) ^ (e & n) ^ (t & n);
class Cd extends Jr {
  constructor(t, n, r, s) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = s),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = ar(this.buffer));
  }
  update(t) {
    _t(this);
    const { view: n, buffer: r, blockLen: s } = this;
    t = Gn(t);
    const o = t.length;
    for (let i = 0; i < o; ) {
      const a = Math.min(s - this.pos, o - i);
      if (a === s) {
        const c = ar(t);
        for (; s <= o - i; i += s) this.process(c, i);
        continue;
      }
      r.set(t.subarray(i, i + a), this.pos),
        (this.pos += a),
        (i += a),
        this.pos === s && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    _t(this), li(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: s, isLE: o } = this;
    let { pos: i } = this;
    (n[i++] = 128),
      this.buffer.subarray(i).fill(0),
      this.padOffset > s - i && (this.process(r, 0), (i = 0));
    for (let l = i; l < s; l++) n[l] = 0;
    Ad(r, s - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const a = ar(t),
      c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4,
      d = this.get();
    if (u > d.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++) a.setUint32(4 * l, d[l], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: s,
      finished: o,
      destroyed: i,
      pos: a,
    } = this;
    return (
      (t.length = s),
      (t.pos = a),
      (t.finished = o),
      (t.destroyed = i),
      s % n && t.buffer.set(r),
      t
    );
  }
}
const Td = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Ve = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  Ze = new Uint32Array(64);
class kd extends Cd {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Ve[0] | 0),
      (this.B = Ve[1] | 0),
      (this.C = Ve[2] | 0),
      (this.D = Ve[3] | 0),
      (this.E = Ve[4] | 0),
      (this.F = Ve[5] | 0),
      (this.G = Ve[6] | 0),
      (this.H = Ve[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: s, E: o, F: i, G: a, H: c } = this;
    return [t, n, r, s, o, i, a, c];
  }
  set(t, n, r, s, o, i, a, c) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = s | 0),
      (this.E = o | 0),
      (this.F = i | 0),
      (this.G = a | 0),
      (this.H = c | 0);
  }
  process(t, n) {
    for (let l = 0; l < 16; l++, n += 4) Ze[l] = t.getUint32(n, !1);
    for (let l = 16; l < 64; l++) {
      const f = Ze[l - 15],
        p = Ze[l - 2],
        y = Ce(f, 7) ^ Ce(f, 18) ^ (f >>> 3),
        h = Ce(p, 17) ^ Ce(p, 19) ^ (p >>> 10);
      Ze[l] = (h + Ze[l - 7] + y + Ze[l - 16]) | 0;
    }
    let { A: r, B: s, C: o, D: i, E: a, F: c, G: u, H: d } = this;
    for (let l = 0; l < 64; l++) {
      const f = Ce(a, 6) ^ Ce(a, 11) ^ Ce(a, 25),
        p = (d + f + Id(a, c, u) + Td[l] + Ze[l]) | 0,
        h = ((Ce(r, 2) ^ Ce(r, 13) ^ Ce(r, 22)) + Bd(r, s, o)) | 0;
      (d = u),
        (u = c),
        (c = a),
        (a = (i + p) | 0),
        (i = o),
        (o = s),
        (s = r),
        (r = (p + h) | 0);
    }
    (r = (r + this.A) | 0),
      (s = (s + this.B) | 0),
      (o = (o + this.C) | 0),
      (i = (i + this.D) | 0),
      (a = (a + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (d = (d + this.H) | 0),
      this.set(r, s, o, i, a, c, u, d);
  }
  roundClean() {
    Ze.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const ji = di(() => new kd());
function Ui(e, t) {
  const n = t || "hex",
    r = ji(ve(e, { strict: !1 }) ? Ie(e) : e);
  return n === "bytes" ? r : S(r);
}
function Sd(e) {
  const { commitment: t, version: n = 1 } = e,
    r = e.to ?? (typeof t == "string" ? "hex" : "bytes"),
    s = Ui(t, "bytes");
  return s.set([n], 0), r === "bytes" ? s : X(s);
}
function qi(e) {
  const { commitments: t, version: n } = e,
    r = e.to ?? (typeof t[0] == "string" ? "hex" : "bytes"),
    s = [];
  for (const o of t) s.push(Sd({ commitment: o, to: r, version: n }));
  return s;
}
const po = 6,
  Di = 32,
  bs = 4096,
  Gi = Di * bs,
  mo = Gi * po - 1 - 1 * bs * po,
  Hi = 1;
class Nd extends E {
  constructor({ maxSize: t, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError",
    });
  }
}
class Vi extends E {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class Fd extends E {
  constructor({ hash: t, size: n }) {
    super(`Versioned hash "${t}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError",
    });
  }
}
class Ld extends E {
  constructor({ hash: t, version: n }) {
    super(`Versioned hash "${t}" version is invalid.`, {
      metaMessages: [`Expected: ${Hi}`, `Received: ${n}`],
      name: "InvalidVersionedHashVersionError",
    });
  }
}
function zd(e) {
  const t = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"),
    n = typeof e.data == "string" ? fe(e.data) : e.data,
    r = V(n);
  if (!r) throw new Vi();
  if (r > mo) throw new Nd({ maxSize: mo, size: r });
  const s = [];
  let o = !0,
    i = 0;
  for (; o; ) {
    const a = os(new Uint8Array(Gi));
    let c = 0;
    for (; c < bs; ) {
      const u = n.slice(i, i + (Di - 1));
      if ((a.pushByte(0), a.pushBytes(u), u.length < 31)) {
        a.pushByte(128), (o = !1);
        break;
      }
      c++, (i += 31);
    }
    s.push(a);
  }
  return t === "bytes" ? s.map((a) => a.bytes) : s.map((a) => X(a.bytes));
}
function Zi(e) {
  const { data: t, kzg: n, to: r } = e,
    s = e.blobs ?? zd({ data: t, to: r }),
    o = e.commitments ?? ms({ blobs: s, kzg: n, to: r }),
    i = e.proofs ?? ys({ blobs: s, commitments: o, kzg: n, to: r }),
    a = [];
  for (let c = 0; c < s.length; c++)
    a.push({ blob: s[c], commitment: o[c], proof: i[c] });
  return a;
}
function Wi(e) {
  if (e.type) return e.type;
  if (typeof e.authorizationList < "u") return "eip7702";
  if (
    typeof e.blobs < "u" ||
    typeof e.blobVersionedHashes < "u" ||
    typeof e.maxFeePerBlobGas < "u" ||
    typeof e.sidecars < "u"
  )
    return "eip4844";
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new ed({ transaction: e });
}
async function mn(e) {
  const t = await e.request({ method: "eth_chainId" }, { dedupe: !0 });
  return Be(t);
}
const Ki = ["blobVersionedHashes", "chainId", "fees", "gas", "nonce", "type"];
async function Yn(e, t) {
  const {
      account: n = e.account,
      blobs: r,
      chain: s,
      gas: o,
      kzg: i,
      nonce: a,
      parameters: c = Ki,
      type: u,
    } = t,
    d = n ? ye(n) : void 0,
    l = { ...t, ...(d ? { from: d == null ? void 0 : d.address } : {}) };
  let f;
  async function p() {
    return f || ((f = await O(e, Je, "getBlock")({ blockTag: "latest" })), f);
  }
  let y;
  async function h() {
    return (
      y ||
      (s
        ? s.id
        : typeof t.chainId < "u"
          ? t.chainId
          : ((y = await O(e, mn, "getChainId")({})), y))
    );
  }
  if ((c.includes("blobVersionedHashes") || c.includes("sidecars")) && r && i) {
    const m = ms({ blobs: r, kzg: i });
    if (c.includes("blobVersionedHashes")) {
      const b = qi({ commitments: m, to: "hex" });
      l.blobVersionedHashes = b;
    }
    if (c.includes("sidecars")) {
      const b = ys({ blobs: r, commitments: m, kzg: i }),
        g = Zi({ blobs: r, commitments: m, proofs: b, to: "hex" });
      l.sidecars = g;
    }
  }
  if (
    (c.includes("chainId") && (l.chainId = await h()),
    c.includes("nonce") && typeof a > "u" && d)
  )
    if (d.nonceManager) {
      const m = await h();
      l.nonce = await d.nonceManager.consume({
        address: d.address,
        chainId: m,
        client: e,
      });
    } else
      l.nonce = await O(
        e,
        Ri,
        "getTransactionCount",
      )({ address: d.address, blockTag: "pending" });
  if ((c.includes("fees") || c.includes("type")) && typeof u > "u")
    try {
      l.type = Wi(l);
    } catch {
      const m = await p();
      l.type =
        typeof (m == null ? void 0 : m.baseFeePerGas) == "bigint"
          ? "eip1559"
          : "legacy";
    }
  if (c.includes("fees"))
    if (l.type !== "legacy" && l.type !== "eip2930") {
      if (typeof l.maxFeePerGas > "u" || typeof l.maxPriorityFeePerGas > "u") {
        const m = await p(),
          { maxFeePerGas: b, maxPriorityFeePerGas: g } = await Mr(e, {
            block: m,
            chain: s,
            request: l,
          });
        if (
          typeof t.maxPriorityFeePerGas > "u" &&
          t.maxFeePerGas &&
          t.maxFeePerGas < g
        )
          throw new vd({ maxPriorityFeePerGas: g });
        (l.maxPriorityFeePerGas = g), (l.maxFeePerGas = b);
      }
    } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        throw new ds();
      const m = await p(),
        { gasPrice: b } = await Mr(e, {
          block: m,
          chain: s,
          request: l,
          type: "legacy",
        });
      l.gasPrice = b;
    }
  return (
    c.includes("gas") &&
      typeof o > "u" &&
      (l.gas = await O(
        e,
        gs,
        "estimateGas",
      )({
        ...l,
        account: d ? { address: d.address, type: "json-rpc" } : void 0,
      })),
    pn(l),
    delete l.parameters,
    l
  );
}
async function Yi(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const s = n ? z(n) : void 0,
    o = await e.request({ method: "eth_getBalance", params: [t, s || r] });
  return BigInt(o);
}
async function gs(e, t) {
  let s, o, i;
  const n = t.account ?? e.account,
    r = n ? ye(n) : void 0;
  try {
    const ce = function (C) {
      const { block: M, request: U, rpcStateOverride: q } = C;
      return e.request({
        method: "eth_estimateGas",
        params: q ? [U, M ?? "latest", q] : M ? [U, M] : [U],
      });
    };
    const {
        accessList: a,
        authorizationList: c,
        blobs: u,
        blobVersionedHashes: d,
        blockNumber: l,
        blockTag: f,
        data: p,
        gas: y,
        gasPrice: h,
        maxFeePerBlobGas: m,
        maxFeePerGas: b,
        maxPriorityFeePerGas: g,
        nonce: w,
        value: v,
        stateOverride: P,
        ...x
      } = await Yn(e, {
        ...t,
        parameters:
          (r == null ? void 0 : r.type) === "local"
            ? void 0
            : ["blobVersionedHashes"],
      }),
      $ = (l ? z(l) : void 0) || f,
      k = Li(P),
      B = await (async () => {
        if (x.to) return x.to;
        if (c && c.length > 0)
          return await Fi({ authorization: c[0] }).catch(() => {
            throw new E(
              "`to` is required. Could not infer from `authorizationList`",
            );
          });
      })();
    pn(t);
    const T =
        (i =
          (o = (s = e.chain) == null ? void 0 : s.formatters) == null
            ? void 0
            : o.transactionRequest) == null
          ? void 0
          : i.format,
      G = (T || hn)({
        ...ls(x, { format: T }),
        from: r == null ? void 0 : r.address,
        accessList: a,
        authorizationList: c,
        blobs: u,
        blobVersionedHashes: d,
        data: p,
        gas: y,
        gasPrice: h,
        maxFeePerBlobGas: m,
        maxFeePerGas: b,
        maxPriorityFeePerGas: g,
        nonce: w,
        to: B,
        value: v,
      });
    let I = BigInt(await ce({ block: $, request: G, rpcStateOverride: k }));
    if (c) {
      const C = await Yi(e, { address: G.from }),
        M = await Promise.all(
          c.map(async (U) => {
            const { contractAddress: q } = U,
              H = await ce({
                block: $,
                request: {
                  authorizationList: void 0,
                  data: p,
                  from: r == null ? void 0 : r.address,
                  to: q,
                  value: z(C),
                },
                rpcStateOverride: k,
              }).catch(() => 100000n);
            return 2n * BigInt(H);
          }),
        );
      I += M.reduce((U, q) => U + q, 0n);
    }
    return I;
  } catch (a) {
    throw pd(a, { ...t, account: r, chain: e.chain });
  }
}
async function Md(e, t) {
  const { abi: n, address: r, args: s, functionName: o, ...i } = t,
    a = tt({ abi: n, args: s, functionName: o });
  try {
    return await O(e, gs, "estimateGas")({ data: a, to: r, ...i });
  } catch (c) {
    const u = i.account ? ye(i.account) : void 0;
    throw At(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: o,
      sender: u == null ? void 0 : u.address,
    });
  }
}
function ws(e, t) {
  if (!K(e, { strict: !1 })) throw new se({ address: e });
  if (!K(t, { strict: !1 })) throw new se({ address: t });
  return e.toLowerCase() === t.toLowerCase();
}
const yo = "/docs/contract/decodeEventLog";
function vs(e) {
  const { abi: t, data: n, strict: r, topics: s } = e,
    o = r ?? !0,
    [i, ...a] = s;
  if (!i) throw new Tu({ docsPath: yo });
  const c = t.find((h) => h.type === "event" && i === Qr(Me(h)));
  if (!(c && "name" in c) || c.type !== "event")
    throw new ii(i, { docsPath: yo });
  const { name: u, inputs: d } = c,
    l = d == null ? void 0 : d.some((h) => !("name" in h && h.name));
  let f = l ? [] : {};
  const p = d.filter((h) => "indexed" in h && h.indexed);
  for (let h = 0; h < p.length; h++) {
    const m = p[h],
      b = a[h];
    if (!b) throw new Dn({ abiItem: c, param: m });
    f[l ? h : m.name || h] = Od({ param: m, value: b });
  }
  const y = d.filter((h) => !("indexed" in h && h.indexed));
  if (y.length > 0) {
    if (n && n !== "0x")
      try {
        const h = Zn(y, n);
        if (h)
          if (l) f = [...f, ...h];
          else for (let m = 0; m < y.length; m++) f[y[m].name] = h[m];
      } catch (h) {
        if (o)
          throw h instanceof si || h instanceof Pi
            ? new Dt({ abiItem: c, data: n, params: y, size: V(n) })
            : h;
      }
    else if (o) throw new Dt({ abiItem: c, data: "0x", params: y, size: 0 });
  }
  return { eventName: u, args: Object.values(f).length > 0 ? f : void 0 };
}
function Od({ param: e, value: t }) {
  return e.type === "string" ||
    e.type === "bytes" ||
    e.type === "tuple" ||
    e.type.match(/^(.*)\[(\d+)?\]$/)
    ? t
    : (Zn([e], t) || [])[0];
}
function xs(e) {
  const { abi: t, args: n, logs: r, strict: s = !0 } = e,
    o = (() => {
      if (e.eventName)
        return Array.isArray(e.eventName) ? e.eventName : [e.eventName];
    })();
  return r
    .map((i) => {
      let a;
      try {
        const c = St({ abi: t, name: i.topics[0] });
        if (!c) return null;
        const u = vs({ ...i, abi: [c], strict: s });
        return (o && !o.includes(u.eventName)) ||
          !Rd({ args: u.args, inputs: c.inputs, matchArgs: n })
          ? null
          : { ...u, ...i };
      } catch (c) {
        let u, d;
        if (c instanceof ii) return null;
        if (c instanceof Dt || c instanceof Dn) {
          if (s) return null;
          (u = c.abiItem.name),
            (d =
              (a = c.abiItem.inputs) == null
                ? void 0
                : a.some((l) => !("name" in l && l.name)));
        }
        return { ...i, args: d ? [] : {}, eventName: u };
      }
    })
    .filter(Boolean);
}
function Rd(e) {
  const { args: t, inputs: n, matchArgs: r } = e;
  if (!r) return !0;
  if (!t) return !1;
  function s(o, i, a) {
    try {
      return o.type === "address"
        ? ws(i, a)
        : o.type === "string" || o.type === "bytes"
          ? Q(Ie(i)) === a
          : i === a;
    } catch {
      return !1;
    }
  }
  return Array.isArray(t) && Array.isArray(r)
    ? r.every((o, i) => {
        if (!o) return !0;
        const a = n[i];
        return a ? (Array.isArray(o) ? o : [o]).some((u) => s(a, u, t[i])) : !1;
      })
    : typeof t == "object" &&
        !Array.isArray(t) &&
        typeof r == "object" &&
        !Array.isArray(r)
      ? Object.entries(r).every(([o, i]) => {
          if (!i) return !0;
          const a = n.find((u) => u.name === o);
          return a
            ? (Array.isArray(i) ? i : [i]).some((u) => s(a, u, t[o]))
            : !1;
        })
      : !1;
}
function Re(e, { args: t, eventName: n } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...(n ? { args: t, eventName: n } : {}),
  };
}
async function Es(
  e,
  {
    address: t,
    blockHash: n,
    fromBlock: r,
    toBlock: s,
    event: o,
    events: i,
    args: a,
    strict: c,
  } = {},
) {
  const u = c ?? !1,
    d = i ?? (o ? [o] : void 0);
  let l = [];
  d &&
    ((l = [
      d.flatMap((h) =>
        dn({ abi: [h], eventName: h.name, args: i ? void 0 : a }),
      ),
    ]),
    o && (l = l[0]));
  let f;
  n
    ? (f = await e.request({
        method: "eth_getLogs",
        params: [{ address: t, topics: l, blockHash: n }],
      }))
    : (f = await e.request({
        method: "eth_getLogs",
        params: [
          {
            address: t,
            topics: l,
            fromBlock: typeof r == "bigint" ? z(r) : r,
            toBlock: typeof s == "bigint" ? z(s) : s,
          },
        ],
      }));
  const p = f.map((y) => Re(y));
  return d ? xs({ abi: d, args: a, logs: p, strict: u }) : p;
}
async function Ji(e, t) {
  const {
      abi: n,
      address: r,
      args: s,
      blockHash: o,
      eventName: i,
      fromBlock: a,
      toBlock: c,
      strict: u,
    } = t,
    d = i ? St({ abi: n, name: i }) : void 0,
    l = d ? void 0 : n.filter((f) => f.type === "event");
  return O(
    e,
    Es,
    "getLogs",
  )({
    address: r,
    args: s,
    blockHash: o,
    event: d,
    events: l,
    fromBlock: a,
    toBlock: c,
    strict: u,
  });
}
const lr = "/docs/contract/decodeFunctionResult";
function Ft(e) {
  const { abi: t, args: n, functionName: r, data: s } = e;
  let o = t[0];
  if (r) {
    const a = St({ abi: t, args: n, name: r });
    if (!a) throw new Mn(r, { docsPath: lr });
    o = a;
  }
  if (o.type !== "function") throw new Mn(void 0, { docsPath: lr });
  if (!o.outputs) throw new ku(o.name, { docsPath: lr });
  const i = Zn(o.outputs, s);
  if (i && i.length > 1) return i;
  if (i && i.length === 1) return i[0];
}
const Or = [
    {
      inputs: [
        {
          components: [
            { name: "target", type: "address" },
            { name: "allowFailure", type: "bool" },
            { name: "callData", type: "bytes" },
          ],
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            { name: "success", type: "bool" },
            { name: "returnData", type: "bytes" },
          ],
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Xi = [
    { inputs: [], name: "ResolverNotFound", type: "error" },
    { inputs: [], name: "ResolverWildcardNotSupported", type: "error" },
    { inputs: [], name: "ResolverNotContract", type: "error" },
    {
      inputs: [{ name: "returnData", type: "bytes" }],
      name: "ResolverError",
      type: "error",
    },
    {
      inputs: [
        {
          components: [
            { name: "status", type: "uint16" },
            { name: "message", type: "string" },
          ],
          name: "errors",
          type: "tuple[]",
        },
      ],
      name: "HttpError",
      type: "error",
    },
  ],
  Qi = [
    ...Xi,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" },
      ],
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" },
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" },
      ],
    },
  ],
  jd = [
    ...Xi,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" },
      ],
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" },
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" },
      ],
    },
  ],
  bo = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" },
      ],
      outputs: [{ name: "", type: "string" }],
    },
  ],
  go = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }],
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bytes" }],
    },
  ],
  Ud = [
    {
      inputs: [
        { name: "_signer", type: "address" },
        { name: "_hash", type: "bytes32" },
        { name: "_signature", type: "bytes" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
  ],
  qd = "0x82ad56cb",
  Dd =
    "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe",
  Gd =
    "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe",
  Hd =
    "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
class Rr extends E {
  constructor({ blockNumber: t, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...(t && r.blockCreated && r.blockCreated > t
          ? [
              `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`,
            ]
          : [`- The chain does not have the contract "${r.name}" configured.`]),
      ],
      name: "ChainDoesNotSupportContract",
    });
  }
}
class Vd extends E {
  constructor({ chain: t, currentChainId: n }) {
    super(
      `The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id}  ${t.name}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${n}`,
          `Expected Chain ID: ${t.id}  ${t.name}`,
        ],
        name: "ChainMismatchError",
      },
    );
  }
}
class Zd extends E {
  constructor() {
    super(
      [
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.",
      ].join(`
`),
      { name: "ChainNotFoundError" },
    );
  }
}
class ea extends E {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError",
    });
  }
}
class yn extends E {
  constructor({ chainId: t }) {
    super(
      typeof t == "number"
        ? `Chain ID "${t}" is invalid.`
        : "Chain ID is invalid.",
      { name: "InvalidChainIdError" },
    );
  }
}
const dr = "/docs/contract/encodeDeployData";
function Jn(e) {
  const { abi: t, args: n, bytecode: r } = e;
  if (!n || n.length === 0) return r;
  const s = t.find((i) => "type" in i && i.type === "constructor");
  if (!s) throw new Au({ docsPath: dr });
  if (!("inputs" in s)) throw new Ws({ docsPath: dr });
  if (!s.inputs || s.inputs.length === 0) throw new Ws({ docsPath: dr });
  const o = kt(s.inputs, n);
  return Se([r, o]);
}
function Lt({ blockNumber: e, chain: t, contract: n }) {
  let s;
  const r = (s = t == null ? void 0 : t.contracts) == null ? void 0 : s[n];
  if (!r) throw new Rr({ chain: t, contract: { name: n } });
  if (e && r.blockCreated && r.blockCreated > e)
    throw new Rr({
      blockNumber: e,
      chain: t,
      contract: { name: n, blockCreated: r.blockCreated },
    });
  return r.address;
}
function Wd(e, { docsPath: t, ...n }) {
  const r = (() => {
    const s = us(e, n);
    return s instanceof Wn ? e : s;
  })();
  return new Ii(r, { docsPath: t, ...n });
}
const fr = new Map();
function ta({ fn: e, id: t, shouldSplitBatch: n, wait: r = 0, sort: s }) {
  const o = async () => {
      const d = c();
      i();
      const l = d.map(({ args: f }) => f);
      l.length !== 0 &&
        e(l)
          .then((f) => {
            let p;
            s && Array.isArray(f) && f.sort(s);
            for (let y = 0; y < d.length; y++) {
              const { pendingPromise: h } = d[y];
              (p = h.resolve) == null || p.call(h, [f[y], f]);
            }
          })
          .catch((f) => {
            let p;
            for (let y = 0; y < d.length; y++) {
              const { pendingPromise: h } = d[y];
              (p = h.reject) == null || p.call(h, f);
            }
          });
    },
    i = () => fr.delete(t),
    a = () => c().map(({ args: d }) => d),
    c = () => fr.get(t) || [],
    u = (d) => fr.set(t, [...c(), d]);
  return {
    flush: i,
    async schedule(d) {
      const l = {},
        f = new Promise((h, m) => {
          (l.resolve = h), (l.reject = m);
        });
      return (
        (n == null ? void 0 : n([...a(), d])) && o(),
        c().length > 0
          ? (u({ args: d, pendingPromise: l }), f)
          : (u({ args: d, pendingPromise: l }), setTimeout(o, r), f)
      );
    },
  };
}
async function Xn(e, t) {
  let T, L, G, ce;
  const {
      account: n = e.account,
      batch: r = !!((T = e.batch) != null && T.multicall),
      blockNumber: s,
      blockTag: o = "latest",
      accessList: i,
      blobs: a,
      code: c,
      data: u,
      factory: d,
      factoryData: l,
      gas: f,
      gasPrice: p,
      maxFeePerBlobGas: y,
      maxFeePerGas: h,
      maxPriorityFeePerGas: m,
      nonce: b,
      to: g,
      value: w,
      stateOverride: v,
      ...P
    } = t,
    x = n ? ye(n) : void 0;
  if (c && (d || l))
    throw new E(
      "Cannot provide both `code` & `factory`/`factoryData` as parameters.",
    );
  if (c && g) throw new E("Cannot provide both `code` & `to` as parameters.");
  const _ = c && u,
    $ = d && l && g && u,
    k = _ || $,
    B = _
      ? Jd({ code: c, data: u })
      : $
        ? Xd({ data: u, factory: d, factoryData: l, to: g })
        : u;
  try {
    pn(t);
    const C = (s ? z(s) : void 0) || o,
      M = Li(v),
      U =
        (ce =
          (G = (L = e.chain) == null ? void 0 : L.formatters) == null
            ? void 0
            : G.transactionRequest) == null
          ? void 0
          : ce.format,
      H = (U || hn)({
        ...ls(P, { format: U }),
        from: x == null ? void 0 : x.address,
        accessList: i,
        blobs: a,
        data: B,
        gas: f,
        gasPrice: p,
        maxFeePerBlobGas: y,
        maxFeePerGas: h,
        maxPriorityFeePerGas: m,
        nonce: b,
        to: k ? void 0 : g,
        value: w,
      });
    if (r && Kd({ request: H }) && !M)
      try {
        return await Yd(e, { ...H, blockNumber: s, blockTag: o });
      } catch (te) {
        if (!(te instanceof ea) && !(te instanceof Rr)) throw te;
      }
    const oe = await e.request({
      method: "eth_call",
      params: M ? [H, C, M] : [H, C],
    });
    return oe === "0x" ? { data: void 0 } : { data: oe };
  } catch (I) {
    const C = Qd(I),
      { offchainLookup: M, offchainLookupSignature: U } = await Mo(
        async () => {
          const { offchainLookup: q, offchainLookupSignature: H } =
            await import("./CntDG-S9.js");
          return { offchainLookup: q, offchainLookupSignature: H };
        },
        __vite__mapDeps([0, 1, 2]),
        import.meta.url,
      );
    if (e.ccipRead !== !1 && (C == null ? void 0 : C.slice(0, 10)) === U && g)
      return { data: await M(e, { data: C, to: g }) };
    throw k && (C == null ? void 0 : C.slice(0, 10)) === "0x101bb98d"
      ? new id({ factory: d })
      : Wd(I, { ...t, account: x, chain: e.chain });
  }
}
function Kd({ request: e }) {
  const { data: t, to: n, ...r } = e;
  return !(
    !t ||
    t.startsWith(qd) ||
    !n ||
    Object.values(r).filter((s) => typeof s < "u").length > 0
  );
}
async function Yd(e, t) {
  let h;
  const { batchSize: n = 1024, wait: r = 0 } =
      typeof ((h = e.batch) == null ? void 0 : h.multicall) == "object"
        ? e.batch.multicall
        : {},
    {
      blockNumber: s,
      blockTag: o = "latest",
      data: i,
      multicallAddress: a,
      to: c,
    } = t;
  let u = a;
  if (!u) {
    if (!e.chain) throw new ea();
    u = Lt({ blockNumber: s, chain: e.chain, contract: "multicall3" });
  }
  const l = (s ? z(s) : void 0) || o,
    { schedule: f } = ta({
      id: `${e.uid}.${l}`,
      wait: r,
      shouldSplitBatch(m) {
        return m.reduce((g, { data: w }) => g + (w.length - 2), 0) > n * 2;
      },
      fn: async (m) => {
        const b = m.map((v) => ({
            allowFailure: !0,
            callData: v.data,
            target: v.to,
          })),
          g = tt({ abi: Or, args: [b], functionName: "aggregate3" }),
          w = await e.request({
            method: "eth_call",
            params: [{ data: g, to: u }, l],
          });
        return Ft({
          abi: Or,
          args: [b],
          functionName: "aggregate3",
          data: w || "0x",
        });
      },
    }),
    [{ returnData: p, success: y }] = await f({ data: i, to: c });
  if (!y) throw new cs({ data: p });
  return p === "0x" ? { data: void 0 } : { data: p };
}
function Jd(e) {
  const { code: t, data: n } = e;
  return Jn({
    abi: ti(["constructor(bytes, bytes)"]),
    bytecode: Dd,
    args: [t, n],
  });
}
function Xd(e) {
  const { data: t, factory: n, factoryData: r, to: s } = e;
  return Jn({
    abi: ti(["constructor(address, bytes, address, bytes)"]),
    bytecode: Gd,
    args: [s, t, n, r],
  });
}
function Qd(e) {
  let n;
  if (!(e instanceof E)) return;
  const t = e.walk();
  return typeof (t == null ? void 0 : t.data) == "object"
    ? (n = t.data) == null
      ? void 0
      : n.data
    : t.data;
}
async function je(e, t) {
  const { abi: n, address: r, args: s, functionName: o, ...i } = t,
    a = tt({ abi: n, args: s, functionName: o });
  try {
    const { data: c } = await O(e, Xn, "call")({ ...i, data: a, to: r });
    return Ft({ abi: n, args: s, functionName: o, data: c || "0x" });
  } catch (c) {
    throw At(c, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/readContract",
      functionName: o,
    });
  }
}
async function ef(e, t) {
  const {
      abi: n,
      address: r,
      args: s,
      dataSuffix: o,
      functionName: i,
      ...a
    } = t,
    c = a.account ? ye(a.account) : e.account,
    u = tt({ abi: n, args: s, functionName: i });
  try {
    const { data: d } = await O(
        e,
        Xn,
        "call",
      )({
        batch: !1,
        data: `${u}${o ? o.replace("0x", "") : ""}`,
        to: r,
        ...a,
        account: c,
      }),
      l = Ft({ abi: n, args: s, functionName: i, data: d || "0x" }),
      f = n.filter((p) => "name" in p && p.name === t.functionName);
    return {
      result: l,
      request: {
        abi: f,
        address: r,
        args: s,
        dataSuffix: o,
        functionName: i,
        ...a,
        account: c,
      },
    };
  } catch (d) {
    throw At(d, {
      abi: n,
      address: r,
      args: s,
      docsPath: "/docs/contract/simulateContract",
      functionName: i,
      sender: c == null ? void 0 : c.address,
    });
  }
}
const hr = new Map(),
  wo = new Map();
let tf = 0;
function Xe(e, t, n) {
  const r = ++tf,
    s = () => hr.get(e) || [],
    o = () => {
      const d = s();
      hr.set(
        e,
        d.filter((l) => l.id !== r),
      );
    },
    i = () => {
      const d = wo.get(e);
      s().length === 1 && d && d(), o();
    },
    a = s();
  if ((hr.set(e, [...a, { id: r, fns: t }]), a && a.length > 0)) return i;
  const c = {};
  for (const d in t)
    c[d] = (...l) => {
      let p, y;
      const f = s();
      if (f.length !== 0)
        for (const h of f) (y = (p = h.fns)[d]) == null || y.call(p, ...l);
    };
  const u = n(c);
  return typeof u == "function" && wo.set(e, u), i;
}
async function jr(e) {
  return new Promise((t) => setTimeout(t, e));
}
function bn(e, { emitOnBegin: t, initialWaitTime: n, interval: r }) {
  let s = !0;
  const o = () => (s = !1);
  return (
    (async () => {
      let a;
      t && (a = await e({ unpoll: o }));
      const c = (await (n == null ? void 0 : n(a))) ?? r;
      await jr(c);
      const u = async () => {
        s && (await e({ unpoll: o }), await jr(r), u());
      };
      u();
    })(),
    o
  );
}
const nf = new Map(),
  rf = new Map();
function sf(e) {
  const t = (s, o) => ({
      clear: () => o.delete(s),
      get: () => o.get(s),
      set: (i) => o.set(s, i),
    }),
    n = t(e, nf),
    r = t(e, rf);
  return {
    clear: () => {
      n.clear(), r.clear();
    },
    promise: n,
    response: r,
  };
}
async function of(e, { cacheKey: t, cacheTime: n = Number.POSITIVE_INFINITY }) {
  const r = sf(t),
    s = r.response.get();
  if (s && n > 0 && new Date().getTime() - s.created.getTime() < n)
    return s.data;
  let o = r.promise.get();
  o || ((o = e()), r.promise.set(o));
  try {
    const i = await o;
    return r.response.set({ created: new Date(), data: i }), i;
  } finally {
    r.promise.clear();
  }
}
const af = (e) => `blockNumber.${e}`;
async function gn(e, { cacheTime: t = e.cacheTime } = {}) {
  const n = await of(() => e.request({ method: "eth_blockNumber" }), {
    cacheKey: af(e.uid),
    cacheTime: t,
  });
  return BigInt(n);
}
async function Qn(e, { filter: t }) {
  const n = "strict" in t && t.strict,
    r = await t.request({ method: "eth_getFilterChanges", params: [t.id] });
  if (typeof r[0] == "string") return r;
  const s = r.map((o) => Re(o));
  return !("abi" in t) || !t.abi ? s : xs({ abi: t.abi, logs: s, strict: n });
}
async function er(e, { filter: t }) {
  return t.request({ method: "eth_uninstallFilter", params: [t.id] });
}
function cf(e, t) {
  const {
    abi: n,
    address: r,
    args: s,
    batch: o = !0,
    eventName: i,
    fromBlock: a,
    onError: c,
    onLogs: u,
    poll: d,
    pollingInterval: l = e.pollingInterval,
    strict: f,
  } = t;
  return (
    typeof d < "u"
      ? d
      : typeof a == "bigint"
        ? !0
        : !(
            e.transport.type === "webSocket" ||
            (e.transport.type === "fallback" &&
              e.transport.transports[0].config.type === "webSocket")
          )
  )
    ? (() => {
        const m = f ?? !1,
          b = ae(["watchContractEvent", r, s, o, e.uid, i, l, m, a]);
        return Xe(b, { onLogs: u, onError: c }, (g) => {
          let w;
          a !== void 0 && (w = a - 1n);
          let v,
            P = !1;
          const x = bn(
            async () => {
              let _;
              if (!P) {
                try {
                  v = await O(
                    e,
                    xi,
                    "createContractEventFilter",
                  )({
                    abi: n,
                    address: r,
                    args: s,
                    eventName: i,
                    strict: m,
                    fromBlock: a,
                  });
                } catch {}
                P = !0;
                return;
              }
              try {
                let $;
                if (v) $ = await O(e, Qn, "getFilterChanges")({ filter: v });
                else {
                  const k = await O(e, gn, "getBlockNumber")({});
                  w && w < k
                    ? ($ = await O(
                        e,
                        Ji,
                        "getContractEvents",
                      )({
                        abi: n,
                        address: r,
                        args: s,
                        eventName: i,
                        fromBlock: w + 1n,
                        toBlock: k,
                        strict: m,
                      }))
                    : ($ = []),
                    (w = k);
                }
                if ($.length === 0) return;
                if (o) g.onLogs($);
                else for (const k of $) g.onLogs([k]);
              } catch ($) {
                v && $ instanceof ft && (P = !1),
                  (_ = g.onError) == null || _.call(g, $);
              }
            },
            { emitOnBegin: !0, interval: l },
          );
          return async () => {
            v && (await O(e, er, "uninstallFilter")({ filter: v })), x();
          };
        });
      })()
    : (() => {
        const m = f ?? !1,
          b = ae(["watchContractEvent", r, s, o, e.uid, i, l, m]);
        let g = !0,
          w = () => (g = !1);
        return Xe(
          b,
          { onLogs: u, onError: c },
          (v) => (
            (async () => {
              try {
                const P = (() => {
                    if (e.transport.type === "fallback") {
                      const $ = e.transport.transports.find(
                        (k) => k.config.type === "webSocket",
                      );
                      return $ ? $.value : e.transport;
                    }
                    return e.transport;
                  })(),
                  x = i ? dn({ abi: n, eventName: i, args: s }) : [],
                  { unsubscribe: _ } = await P.subscribe({
                    params: ["logs", { address: r, topics: x }],
                    onData($) {
                      let B;
                      if (!g) return;
                      const k = $.result;
                      try {
                        const { eventName: T, args: L } = vs({
                            abi: n,
                            data: k.data,
                            topics: k.topics,
                            strict: f,
                          }),
                          G = Re(k, { args: L, eventName: T });
                        v.onLogs([G]);
                      } catch (T) {
                        let L, G;
                        if (T instanceof Dt || T instanceof Dn) {
                          if (f) return;
                          (L = T.abiItem.name),
                            (G =
                              (B = T.abiItem.inputs) == null
                                ? void 0
                                : B.some((I) => !("name" in I && I.name)));
                        }
                        const ce = Re(k, { args: G ? [] : {}, eventName: L });
                        v.onLogs([ce]);
                      }
                    },
                    onError($) {
                      let k;
                      (k = v.onError) == null || k.call(v, $);
                    },
                  });
                (w = _), g || w();
              } catch (P) {
                c == null || c(P);
              }
            })(),
            () => w()
          ),
        );
      })();
}
class wn extends E {
  constructor({ docsPath: t } = {}) {
    super(
      [
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.",
      ].join(`
`),
      { docsPath: t, docsSlug: "account", name: "AccountNotFoundError" },
    );
  }
}
class pr extends E {
  constructor({ docsPath: t, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: t,
      metaMessages: n,
      name: "AccountTypeNotSupportedError",
    });
  }
}
function na({ chain: e, currentChainId: t }) {
  if (!e) throw new Zd();
  if (t !== e.id) throw new Vd({ chain: e, currentChainId: t });
}
function uf(e, { docsPath: t, ...n }) {
  const r = (() => {
    const s = us(e, n);
    return s instanceof Wn ? e : s;
  })();
  return new nd(r, { docsPath: t, ...n });
}
async function Ps(e, { serializedTransaction: t }) {
  return e.request(
    { method: "eth_sendRawTransaction", params: [t] },
    { retryCount: 0 },
  );
}
async function _s(e, t) {
  let b, g, w, v;
  const {
    account: n = e.account,
    chain: r = e.chain,
    accessList: s,
    authorizationList: o,
    blobs: i,
    data: a,
    gas: c,
    gasPrice: u,
    maxFeePerBlobGas: d,
    maxFeePerGas: l,
    maxPriorityFeePerGas: f,
    nonce: p,
    value: y,
    ...h
  } = t;
  if (!n) throw new wn({ docsPath: "/docs/actions/wallet/sendTransaction" });
  const m = ye(n);
  try {
    pn(t);
    const P = await (async () => {
      if (t.to) return t.to;
      if (o && o.length > 0)
        return await Fi({ authorization: o[0] }).catch(() => {
          throw new E(
            "`to` is required. Could not infer from `authorizationList`.",
          );
        });
    })();
    if (m.type === "json-rpc") {
      let x;
      r !== null &&
        ((x = await O(e, mn, "getChainId")({})),
        na({ currentChainId: x, chain: r }));
      const _ =
          (w =
            (g = (b = e.chain) == null ? void 0 : b.formatters) == null
              ? void 0
              : g.transactionRequest) == null
            ? void 0
            : w.format,
        k = (_ || hn)({
          ...ls(h, { format: _ }),
          accessList: s,
          authorizationList: o,
          blobs: i,
          chainId: x,
          data: a,
          from: m.address,
          gas: c,
          gasPrice: u,
          maxFeePerBlobGas: d,
          maxFeePerGas: l,
          maxPriorityFeePerGas: f,
          nonce: p,
          to: P,
          value: y,
        });
      return await e.request(
        { method: "eth_sendTransaction", params: [k] },
        { retryCount: 0 },
      );
    }
    if (m.type === "local") {
      const x = await O(
          e,
          Yn,
          "prepareTransactionRequest",
        )({
          account: m,
          accessList: s,
          authorizationList: o,
          blobs: i,
          chain: r,
          data: a,
          gas: c,
          gasPrice: u,
          maxFeePerBlobGas: d,
          maxFeePerGas: l,
          maxPriorityFeePerGas: f,
          nonce: p,
          parameters: [...Ki, "sidecars"],
          value: y,
          ...h,
          to: P,
        }),
        _ =
          (v = r == null ? void 0 : r.serializers) == null
            ? void 0
            : v.transaction,
        $ = await m.signTransaction(x, { serializer: _ });
      return await O(e, Ps, "sendRawTransaction")({ serializedTransaction: $ });
    }
    throw m.type === "smart"
      ? new pr({
          metaMessages: [
            "Consider using the `sendUserOperation` Action instead.",
          ],
          docsPath: "/docs/actions/bundler/sendUserOperation",
          type: "smart",
        })
      : new pr({
          docsPath: "/docs/actions/wallet/sendTransaction",
          type: m.type,
        });
  } catch (P) {
    throw P instanceof pr
      ? P
      : uf(P, { ...t, account: m, chain: t.chain || void 0 });
  }
}
async function lf(e, t) {
  const {
    abi: n,
    account: r = e.account,
    address: s,
    args: o,
    dataSuffix: i,
    functionName: a,
    ...c
  } = t;
  if (!r) throw new wn({ docsPath: "/docs/contract/writeContract" });
  const u = ye(r),
    d = tt({ abi: n, args: o, functionName: a });
  try {
    return await O(
      e,
      _s,
      "sendTransaction",
    )({ data: `${d}${i ? i.replace("0x", "") : ""}`, to: s, account: u, ...c });
  } catch (l) {
    throw At(l, {
      abi: n,
      address: s,
      args: o,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: u.address,
    });
  }
}
class df extends E {
  constructor({ address: t }) {
    super(`No EIP-712 domain found on contract "${t}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${t}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification.",
      ],
      name: "Eip712DomainNotFoundError",
    });
  }
}
async function ff(e, t) {
  const { address: n, factory: r, factoryData: s } = t;
  try {
    const [o, i, a, c, u, d, l] = await O(
      e,
      je,
      "readContract",
    )({
      abi: hf,
      address: n,
      functionName: "eip712Domain",
      factory: r,
      factoryData: s,
    });
    return {
      domain: {
        name: i,
        version: a,
        chainId: Number(c),
        verifyingContract: u,
        salt: d,
      },
      extensions: l,
      fields: o,
    };
  } catch (o) {
    const i = o;
    throw i.name === "ContractFunctionExecutionError" &&
      i.cause.name === "ContractFunctionZeroDataError"
      ? new df({ address: n })
      : i;
  }
}
const hf = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" },
    ],
    stateMutability: "view",
    type: "function",
  },
];
async function pf(e, { chain: t }) {
  const {
    id: n,
    name: r,
    nativeCurrency: s,
    rpcUrls: o,
    blockExplorers: i,
  } = t;
  await e.request(
    {
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: z(n),
          chainName: r,
          nativeCurrency: s,
          rpcUrls: o.default.http,
          blockExplorerUrls: i
            ? Object.values(i).map(({ url: a }) => a)
            : void 0,
        },
      ],
    },
    { dedupe: !0, retryCount: 0 },
  );
}
const Ur = 256;
let Tn = Ur,
  kn;
function ra(e = 11) {
  if (!kn || Tn + e > Ur * 2) {
    (kn = ""), (Tn = 0);
    for (let t = 0; t < Ur; t++)
      kn += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
  }
  return kn.substring(Tn, Tn++ + e);
}
function mf(e) {
  const {
      batch: t,
      cacheTime: n = e.pollingInterval ?? 4e3,
      ccipRead: r,
      key: s = "base",
      name: o = "Base Client",
      pollingInterval: i = 4e3,
      type: a = "base",
    } = e,
    c = e.chain,
    u = e.account ? ye(e.account) : void 0,
    {
      config: d,
      request: l,
      value: f,
    } = e.transport({ chain: c, pollingInterval: i }),
    p = { ...d, ...f },
    y = {
      account: u,
      batch: t,
      cacheTime: n,
      ccipRead: r,
      chain: c,
      key: s,
      name: o,
      pollingInterval: i,
      request: l,
      transport: p,
      type: a,
      uid: ra(),
    };
  function h(m) {
    return (b) => {
      const g = b(m);
      for (const v in y) delete g[v];
      const w = { ...m, ...g };
      return Object.assign(w, { extend: h(w) });
    };
  }
  return Object.assign(y, { extend: h(y) });
}
const Sn = new es(8192);
function yf(e, { enabled: t = !0, id: n }) {
  if (!t || !n) return e();
  if (Sn.get(n)) return Sn.get(n);
  const r = e().finally(() => Sn.delete(n));
  return Sn.set(n, r), r;
}
function qr(
  e,
  { delay: t = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {},
) {
  return new Promise((s, o) => {
    const i = async ({ count: a = 0 } = {}) => {
      const c = async ({ error: u }) => {
        const d = typeof t == "function" ? t({ count: a, error: u }) : t;
        d && (await jr(d)), i({ count: a + 1 });
      };
      try {
        const u = await e();
        s(u);
      } catch (u) {
        if (a < n && (await r({ count: a, error: u }))) return c({ error: u });
        o(u);
      }
    };
    i();
  });
}
function bf(e, t = {}) {
  return async (n, r = {}) => {
    const {
        dedupe: s = !1,
        retryDelay: o = 150,
        retryCount: i = 3,
        uid: a,
      } = { ...t, ...r },
      c = s ? Q(Pt(`${a}.${ae(n)}`)) : void 0;
    return yf(
      () =>
        qr(
          async () => {
            try {
              return await e(n);
            } catch (u) {
              const d = u;
              switch (d.code) {
                case Vt.code:
                  throw new Vt(d);
                case Zt.code:
                  throw new Zt(d);
                case Wt.code:
                  throw new Wt(d, { method: n.method });
                case Kt.code:
                  throw new Kt(d);
                case dt.code:
                  throw new dt(d);
                case ft.code:
                  throw new ft(d);
                case Yt.code:
                  throw new Yt(d);
                case Jt.code:
                  throw new Jt(d);
                case Xt.code:
                  throw new Xt(d);
                case Qt.code:
                  throw new Qt(d, { method: n.method });
                case $t.code:
                  throw new $t(d);
                case en.code:
                  throw new en(d);
                case xt.code:
                  throw new xt(d);
                case tn.code:
                  throw new tn(d);
                case nn.code:
                  throw new nn(d);
                case rn.code:
                  throw new rn(d);
                case sn.code:
                  throw new sn(d);
                case on.code:
                  throw new on(d);
                case 5e3:
                  throw new xt(d);
                default:
                  throw u instanceof E ? u : new cd(d);
              }
            }
          },
          {
            delay: ({ count: u, error: d }) => {
              let l;
              if (d && d instanceof qt) {
                const f =
                  (l = d == null ? void 0 : d.headers) == null
                    ? void 0
                    : l.get("Retry-After");
                if (f != null && f.match(/\d/)) return Number.parseInt(f) * 1e3;
              }
              return ~~(1 << u) * o;
            },
            retryCount: i,
            shouldRetry: ({ error: u }) => gf(u),
          },
        ),
      { enabled: s, id: c },
    );
  };
}
function gf(e) {
  return "code" in e && typeof e.code == "number"
    ? e.code === -1 || e.code === $t.code || e.code === dt.code
    : e instanceof qt && e.status
      ? e.status === 403 ||
        e.status === 408 ||
        e.status === 413 ||
        e.status === 429 ||
        e.status === 500 ||
        e.status === 502 ||
        e.status === 503 ||
        e.status === 504
      : !0;
}
function wf(
  {
    key: e,
    name: t,
    request: n,
    retryCount: r = 3,
    retryDelay: s = 150,
    timeout: o,
    type: i,
  },
  a,
) {
  const c = ra();
  return {
    config: {
      key: e,
      name: t,
      request: n,
      retryCount: r,
      retryDelay: s,
      timeout: o,
      type: i,
    },
    request: bf(n, { retryCount: r, retryDelay: s, uid: c }),
    value: a,
  };
}
class vf extends E {
  constructor() {
    super(
      "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
      { docsPath: "/docs/clients/intro", name: "UrlRequiredError" },
    );
  }
}
function xf(
  e,
  { errorInstance: t = new Error("timed out"), timeout: n, signal: r },
) {
  return new Promise((s, o) => {
    (async () => {
      let i;
      try {
        const a = new AbortController();
        n > 0 &&
          (i = setTimeout(() => {
            r ? a.abort() : o(t);
          }, n)),
          s(await e({ signal: (a == null ? void 0 : a.signal) || null }));
      } catch (a) {
        (a == null ? void 0 : a.name) === "AbortError" && o(t), o(a);
      } finally {
        clearTimeout(i);
      }
    })();
  });
}
function Ef() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    },
  };
}
const vo = Ef();
function Pf(e, t = {}) {
  return {
    async request(n) {
      let l;
      const {
          body: r,
          onRequest: s = t.onRequest,
          onResponse: o = t.onResponse,
          timeout: i = t.timeout ?? 1e4,
        } = n,
        a = { ...(t.fetchOptions ?? {}), ...(n.fetchOptions ?? {}) },
        { headers: c, method: u, signal: d } = a;
      try {
        const f = await xf(
          async ({ signal: y }) => {
            const h = {
                ...a,
                body: Array.isArray(r)
                  ? ae(
                      r.map((g) => ({
                        jsonrpc: "2.0",
                        id: g.id ?? vo.take(),
                        ...g,
                      })),
                    )
                  : ae({ jsonrpc: "2.0", id: r.id ?? vo.take(), ...r }),
                headers: { "Content-Type": "application/json", ...c },
                method: u || "POST",
                signal: d || (i > 0 ? y : null),
              },
              m = new Request(e, h);
            return s && (await s(m)), await fetch(e, h);
          },
          {
            errorInstance: new lo({ body: r, url: e }),
            timeout: i,
            signal: !0,
          },
        );
        o && (await o(f));
        let p;
        if (
          ((l = f.headers.get("Content-Type")) != null &&
          l.startsWith("application/json")
            ? (p = await f.json())
            : ((p = await f.text()), (p = JSON.parse(p || "{}"))),
          !f.ok)
        )
          throw new qt({
            body: r,
            details: ae(p.error) || f.statusText,
            headers: f.headers,
            status: f.status,
            url: e,
          });
        return p;
      } catch (f) {
        throw f instanceof qt || f instanceof lo
          ? f
          : new qt({ body: r, cause: f, url: e });
      }
    },
  };
}
function _f(e, t = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: s = "http",
    name: o = "HTTP JSON-RPC",
    onFetchRequest: i,
    onFetchResponse: a,
    retryDelay: c,
  } = t;
  return ({ chain: u, retryCount: d, timeout: l }) => {
    const { batchSize: f = 1e3, wait: p = 0 } = typeof n == "object" ? n : {},
      y = t.retryCount ?? d,
      h = l ?? t.timeout ?? 1e4,
      m = u == null ? void 0 : u.rpcUrls.default.http[0];
    if (!m) throw new vf();
    const b = Pf(m, {
      fetchOptions: r,
      onRequest: i,
      onResponse: a,
      timeout: h,
    });
    return wf(
      {
        key: s,
        name: o,
        async request({ method: g, params: w }) {
          const v = { method: g, params: w },
            { schedule: P } = ta({
              id: m,
              wait: p,
              shouldSplitBatch(k) {
                return k.length > f;
              },
              fn: (k) => b.request({ body: k }),
              sort: (k, B) => k.id - B.id,
            }),
            x = async (k) => (n ? P(k) : [await b.request({ body: k })]),
            [{ error: _, result: $ }] = await x(v);
          if (_) throw new Bi({ body: v, error: _, url: m });
          return $;
        },
        retryCount: y,
        retryDelay: c,
        timeout: h,
        type: "http",
      },
      { fetchOptions: r, url: m },
    );
  };
}
function $s(e, t) {
  let r, s, o, i, a, c;
  if (!(e instanceof E)) return !1;
  const n = e.walk((u) => u instanceof Br);
  return n instanceof Br
    ? !!(
        ((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" ||
        ((s = n.data) == null ? void 0 : s.errorName) ===
          "ResolverWildcardNotSupported" ||
        ((o = n.data) == null ? void 0 : o.errorName) ===
          "ResolverNotContract" ||
        ((i = n.data) == null ? void 0 : i.errorName) === "ResolverError" ||
        ((a = n.data) == null ? void 0 : a.errorName) === "HttpError" ||
        ((c = n.reason) != null &&
          c.includes("Wildcard on non-extended resolvers is not supported")) ||
        (t === "reverse" && n.reason === Ei[50])
      )
    : !1;
}
function sa(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65)
    return null;
  const t = `0x${e.slice(1, 65)}`;
  return ve(t) ? t : null;
}
function Nn(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e) return X(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const s = sa(n[r]),
      o = s ? Ie(s) : Q(at(n[r]), "bytes");
    t = Q(Oe([t, o]), "bytes");
  }
  return X(t);
}
function $f(e) {
  return `[${e.slice(2)}]`;
}
function Af(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? sa(e) || Q(at(e)) : X(t);
}
function tr(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0) return new Uint8Array(1);
  const n = new Uint8Array(at(t).byteLength + 2);
  let r = 0;
  const s = t.split(".");
  for (let o = 0; o < s.length; o++) {
    let i = at(s[o]);
    i.byteLength > 255 && (i = at($f(Af(s[o])))),
      (n[r] = i.length),
      n.set(i, r + 1),
      (r += i.length + 1);
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n;
}
async function If(
  e,
  {
    blockNumber: t,
    blockTag: n,
    coinType: r,
    name: s,
    gatewayUrls: o,
    strict: i,
    universalResolverAddress: a,
  },
) {
  let c = a;
  if (!c) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required.",
      );
    c = Lt({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  try {
    const u = tt({
        abi: go,
        functionName: "addr",
        ...(r != null ? { args: [Nn(s), BigInt(r)] } : { args: [Nn(s)] }),
      }),
      d = {
        address: c,
        abi: Qi,
        functionName: "resolve",
        args: [S(tr(s)), u],
        blockNumber: t,
        blockTag: n,
      },
      l = O(e, je, "readContract"),
      f = o ? await l({ ...d, args: [...d.args, o] }) : await l(d);
    if (f[0] === "0x") return null;
    const p = Ft({
      abi: go,
      args: r != null ? [Nn(s), BigInt(r)] : void 0,
      functionName: "addr",
      data: f[0],
    });
    return p === "0x" || Ke(p) === "0x00" ? null : p;
  } catch (u) {
    if (i) throw u;
    if ($s(u, "resolve")) return null;
    throw u;
  }
}
class Bf extends E {
  constructor({ data: t }) {
    super(
      "Unable to extract image from metadata. The metadata may be malformed or invalid.",
      {
        metaMessages: [
          "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
          "",
          `Provided data: ${JSON.stringify(t)}`,
        ],
        name: "EnsAvatarInvalidMetadataError",
      },
    );
  }
}
class Rt extends E {
  constructor({ reason: t }) {
    super(`ENS NFT avatar URI is invalid. ${t}`, {
      name: "EnsAvatarInvalidNftUriError",
    });
  }
}
class As extends E {
  constructor({ uri: t }) {
    super(
      `Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`,
      { name: "EnsAvatarUriResolutionError" },
    );
  }
}
class Cf extends E {
  constructor({ namespace: t }) {
    super(
      `ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`,
      { name: "EnsAvatarUnsupportedNamespaceError" },
    );
  }
}
const Tf =
    /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
  kf =
    /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
  Sf = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
  Nf = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function Ff(e) {
  try {
    const t = await fetch(e, { method: "HEAD" });
    if (t.status === 200) {
      const n = t.headers.get("content-type");
      return n == null ? void 0 : n.startsWith("image/");
    }
    return !1;
  } catch (t) {
    return (typeof t == "object" && typeof t.response < "u") ||
      !globalThis.hasOwnProperty("Image")
      ? !1
      : new Promise((n) => {
          const r = new Image();
          (r.onload = () => {
            n(!0);
          }),
            (r.onerror = () => {
              n(!1);
            }),
            (r.src = e);
        });
  }
}
function xo(e, t) {
  return e ? (e.endsWith("/") ? e.slice(0, -1) : e) : t;
}
function oa({ uri: e, gatewayUrls: t }) {
  const n = Sf.test(e);
  if (n) return { uri: e, isOnChain: !0, isEncoded: n };
  const r = xo(t == null ? void 0 : t.ipfs, "https://ipfs.io"),
    s = xo(t == null ? void 0 : t.arweave, "https://arweave.net"),
    o = e.match(Tf),
    {
      protocol: i,
      subpath: a,
      target: c,
      subtarget: u = "",
    } = (o == null ? void 0 : o.groups) || {},
    d = i === "ipns:/" || a === "ipns/",
    l = i === "ipfs:/" || a === "ipfs/" || kf.test(e);
  if (e.startsWith("http") && !d && !l) {
    let p = e;
    return (
      t != null &&
        t.arweave &&
        (p = e.replace(
          /https:\/\/arweave.net/g,
          t == null ? void 0 : t.arweave,
        )),
      { uri: p, isOnChain: !1, isEncoded: !1 }
    );
  }
  if ((d || l) && c)
    return {
      uri: `${r}/${d ? "ipns" : "ipfs"}/${c}${u}`,
      isOnChain: !1,
      isEncoded: !1,
    };
  if (i === "ar:/" && c)
    return { uri: `${s}/${c}${u || ""}`, isOnChain: !1, isEncoded: !1 };
  let f = e.replace(Nf, "");
  if (
    (f.startsWith("<svg") && (f = `data:image/svg+xml;base64,${btoa(f)}`),
    f.startsWith("data:") || f.startsWith("{"))
  )
    return { uri: f, isOnChain: !0, isEncoded: !1 };
  throw new As({ uri: e });
}
function ia(e) {
  if (
    typeof e != "object" ||
    (!("image" in e) && !("image_url" in e) && !("image_data" in e))
  )
    throw new Bf({ data: e });
  return e.image || e.image_url || e.image_data;
}
async function Lf({ gatewayUrls: e, uri: t }) {
  try {
    const n = await fetch(t).then((s) => s.json());
    return await Is({ gatewayUrls: e, uri: ia(n) });
  } catch {
    throw new As({ uri: t });
  }
}
async function Is({ gatewayUrls: e, uri: t }) {
  const { uri: n, isOnChain: r } = oa({ uri: t, gatewayUrls: e });
  if (r || (await Ff(n))) return n;
  throw new As({ uri: t });
}
function zf(e) {
  let t = e;
  t.startsWith("did:nft:") &&
    (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, r, s] = t.split("/"),
    [o, i] = n.split(":"),
    [a, c] = r.split(":");
  if (!o || o.toLowerCase() !== "eip155")
    throw new Rt({ reason: "Only EIP-155 supported" });
  if (!i) throw new Rt({ reason: "Chain ID not found" });
  if (!c) throw new Rt({ reason: "Contract address not found" });
  if (!s) throw new Rt({ reason: "Token ID not found" });
  if (!a) throw new Rt({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(i),
    namespace: a.toLowerCase(),
    contractAddress: c,
    tokenID: s,
  };
}
async function Mf(e, { nft: t }) {
  if (t.namespace === "erc721")
    return je(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }],
        },
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)],
    });
  if (t.namespace === "erc1155")
    return je(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }],
        },
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)],
    });
  throw new Cf({ namespace: t.namespace });
}
async function Of(e, { gatewayUrls: t, record: n }) {
  return /eip155:/i.test(n)
    ? Rf(e, { gatewayUrls: t, record: n })
    : Is({ uri: n, gatewayUrls: t });
}
async function Rf(e, { gatewayUrls: t, record: n }) {
  const r = zf(n),
    s = await Mf(e, { nft: r }),
    { uri: o, isOnChain: i, isEncoded: a } = oa({ uri: s, gatewayUrls: t });
  if (i && (o.includes("data:application/json;base64,") || o.startsWith("{"))) {
    const u = a ? atob(o.replace("data:application/json;base64,", "")) : o,
      d = JSON.parse(u);
    return Is({ uri: ia(d), gatewayUrls: t });
  }
  let c = r.tokenID;
  return (
    r.namespace === "erc1155" && (c = c.replace("0x", "").padStart(64, "0")),
    Lf({ gatewayUrls: t, uri: o.replace(/(?:0x)?{id}/, c) })
  );
}
async function aa(
  e,
  {
    blockNumber: t,
    blockTag: n,
    name: r,
    key: s,
    gatewayUrls: o,
    strict: i,
    universalResolverAddress: a,
  },
) {
  let c = a;
  if (!c) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required.",
      );
    c = Lt({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  try {
    const u = {
        address: c,
        abi: Qi,
        functionName: "resolve",
        args: [
          S(tr(r)),
          tt({ abi: bo, functionName: "text", args: [Nn(r), s] }),
        ],
        blockNumber: t,
        blockTag: n,
      },
      d = O(e, je, "readContract"),
      l = o ? await d({ ...u, args: [...u.args, o] }) : await d(u);
    if (l[0] === "0x") return null;
    const f = Ft({ abi: bo, functionName: "text", data: l[0] });
    return f === "" ? null : f;
  } catch (u) {
    if (i) throw u;
    if ($s(u, "resolve")) return null;
    throw u;
  }
}
async function jf(
  e,
  {
    blockNumber: t,
    blockTag: n,
    assetGatewayUrls: r,
    name: s,
    gatewayUrls: o,
    strict: i,
    universalResolverAddress: a,
  },
) {
  const c = await O(
    e,
    aa,
    "getEnsText",
  )({
    blockNumber: t,
    blockTag: n,
    key: "avatar",
    name: s,
    universalResolverAddress: a,
    gatewayUrls: o,
    strict: i,
  });
  if (!c) return null;
  try {
    return await Of(e, { record: c, gatewayUrls: r });
  } catch {
    return null;
  }
}
async function Uf(
  e,
  {
    address: t,
    blockNumber: n,
    blockTag: r,
    gatewayUrls: s,
    strict: o,
    universalResolverAddress: i,
  },
) {
  let a = i;
  if (!a) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required.",
      );
    a = Lt({
      blockNumber: n,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  const c = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const u = {
        address: a,
        abi: jd,
        functionName: "reverse",
        args: [S(tr(c))],
        blockNumber: n,
        blockTag: r,
      },
      d = O(e, je, "readContract"),
      [l, f] = s ? await d({ ...u, args: [...u.args, s] }) : await d(u);
    return t.toLowerCase() !== f.toLowerCase() ? null : l;
  } catch (u) {
    if (o) throw u;
    if ($s(u, "reverse")) return null;
    throw u;
  }
}
async function qf(
  e,
  { blockNumber: t, blockTag: n, name: r, universalResolverAddress: s },
) {
  let o = s;
  if (!o) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required.",
      );
    o = Lt({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  const [i] = await O(
    e,
    je,
    "readContract",
  )({
    address: o,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function",
      },
    ],
    functionName: "findResolver",
    args: [S(tr(r))],
    blockNumber: t,
    blockTag: n,
  });
  return i;
}
async function Df(e) {
  const t = Vn(e, { method: "eth_newBlockFilter" }),
    n = await e.request({ method: "eth_newBlockFilter" });
  return { id: n, request: t(n), type: "block" };
}
async function ca(
  e,
  {
    address: t,
    args: n,
    event: r,
    events: s,
    fromBlock: o,
    strict: i,
    toBlock: a,
  } = {},
) {
  const c = s ?? (r ? [r] : void 0),
    u = Vn(e, { method: "eth_newFilter" });
  let d = [];
  c &&
    ((d = [c.flatMap((p) => dn({ abi: [p], eventName: p.name, args: n }))]),
    r && (d = d[0]));
  const l = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: t,
        fromBlock: typeof o == "bigint" ? z(o) : o,
        toBlock: typeof a == "bigint" ? z(a) : a,
        ...(d.length ? { topics: d } : {}),
      },
    ],
  });
  return {
    abi: c,
    args: n,
    eventName: r ? r.name : void 0,
    fromBlock: o,
    id: l,
    request: u(l),
    strict: !!i,
    toBlock: a,
    type: "event",
  };
}
async function ua(e) {
  const t = Vn(e, { method: "eth_newPendingTransactionFilter" }),
    n = await e.request({ method: "eth_newPendingTransactionFilter" });
  return { id: n, request: t(n), type: "transaction" };
}
async function Gf(e) {
  const t = await e.request({ method: "eth_blobBaseFee" });
  return BigInt(t);
}
async function Hf(
  e,
  { blockHash: t, blockNumber: n, blockTag: r = "latest" } = {},
) {
  const s = n !== void 0 ? z(n) : void 0;
  let o;
  return (
    t
      ? (o = await e.request(
          { method: "eth_getBlockTransactionCountByHash", params: [t] },
          { dedupe: !0 },
        ))
      : (o = await e.request(
          { method: "eth_getBlockTransactionCountByNumber", params: [s || r] },
          { dedupe: !!s },
        )),
    Be(o)
  );
}
async function Eo(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const s = n !== void 0 ? z(n) : void 0,
    o = await e.request(
      { method: "eth_getCode", params: [t, s || r] },
      { dedupe: !!s },
    );
  if (o !== "0x") return o;
}
function Vf(e) {
  let t;
  return {
    baseFeePerGas: e.baseFeePerGas.map((n) => BigInt(n)),
    gasUsedRatio: e.gasUsedRatio,
    oldestBlock: BigInt(e.oldestBlock),
    reward:
      (t = e.reward) == null ? void 0 : t.map((n) => n.map((r) => BigInt(r))),
  };
}
async function Zf(
  e,
  {
    blockCount: t,
    blockNumber: n,
    blockTag: r = "latest",
    rewardPercentiles: s,
  },
) {
  const o = n ? z(n) : void 0,
    i = await e.request(
      { method: "eth_feeHistory", params: [z(t), o || r, s] },
      { dedupe: !!o },
    );
  return Vf(i);
}
async function Wf(e, { filter: t }) {
  const n = t.strict ?? !1,
    s = (await t.request({ method: "eth_getFilterLogs", params: [t.id] })).map(
      (o) => Re(o),
    );
  return t.abi ? xs({ abi: t.abi, logs: s, strict: n }) : s;
}
function la(e) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...e };
}
const Kf = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  Yf =
    /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function da(e) {
  const { domain: t = {}, message: n, primaryType: r } = e,
    s = { EIP712Domain: ba({ domain: t }), ...e.types };
  ya({ domain: t, message: n, primaryType: r, types: s });
  const o = ["0x1901"];
  return (
    t && o.push(Jf({ domain: t, types: s })),
    r !== "EIP712Domain" && o.push(fa({ data: n, primaryType: r, types: s })),
    Q(Oe(o))
  );
}
function Jf({ domain: e, types: t }) {
  return fa({ data: e, primaryType: "EIP712Domain", types: t });
}
function fa({ data: e, primaryType: t, types: n }) {
  const r = ha({ data: e, primaryType: t, types: n });
  return Q(r);
}
function ha({ data: e, primaryType: t, types: n }) {
  const r = [{ type: "bytes32" }],
    s = [Xf({ primaryType: t, types: n })];
  for (const o of n[t]) {
    const [i, a] = ma({
      types: n,
      name: o.name,
      type: o.type,
      value: e[o.name],
    });
    r.push(i), s.push(a);
  }
  return kt(r, s);
}
function Xf({ primaryType: e, types: t }) {
  const n = S(Qf({ primaryType: e, types: t }));
  return Q(n);
}
function Qf({ primaryType: e, types: t }) {
  let n = "";
  const r = pa({ primaryType: e, types: t });
  r.delete(e);
  const s = [e, ...Array.from(r).sort()];
  for (const o of s)
    n += `${o}(${t[o].map(({ name: i, type: a }) => `${a} ${i}`).join(",")})`;
  return n;
}
function pa({ primaryType: e, types: t }, n = new Set()) {
  const r = e.match(/^\w*/u),
    s = r == null ? void 0 : r[0];
  if (n.has(s) || t[s] === void 0) return n;
  n.add(s);
  for (const o of t[s]) pa({ primaryType: o.type, types: t }, n);
  return n;
}
function ma({ types: e, name: t, type: n, value: r }) {
  if (e[n] !== void 0)
    return [{ type: "bytes32" }, Q(ha({ data: r, primaryType: n, types: e }))];
  if (n === "bytes")
    return (
      (r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`),
      [{ type: "bytes32" }, Q(r)]
    );
  if (n === "string") return [{ type: "bytes32" }, Q(S(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const s = n.slice(0, n.lastIndexOf("[")),
      o = r.map((i) => ma({ name: t, type: s, types: e, value: i }));
    return [
      { type: "bytes32" },
      Q(
        kt(
          o.map(([i]) => i),
          o.map(([, i]) => i),
        ),
      ),
    ];
  }
  return [{ type: n }, r];
}
function e0(e) {
  const { domain: t, message: n, primaryType: r, types: s } = e,
    o = (c, u) => {
      const d = { ...u };
      for (const l of c) {
        const { name: f, type: p } = l;
        p === "address" && (d[f] = d[f].toLowerCase());
      }
      return d;
    },
    i = s.EIP712Domain ? (t ? o(s.EIP712Domain, t) : {}) : {},
    a = (() => {
      if (r !== "EIP712Domain") return o(s[r], n);
    })();
  return ae({ domain: i, message: a, primaryType: r, types: s });
}
function ya(e) {
  const { domain: t, message: n, primaryType: r, types: s } = e,
    o = (i, a) => {
      for (const c of i) {
        const { name: u, type: d } = c,
          l = a[u],
          f = d.match(Yf);
        if (f && (typeof l == "number" || typeof l == "bigint")) {
          const [h, m, b] = f;
          z(l, { signed: m === "int", size: Number.parseInt(b) / 8 });
        }
        if (d === "address" && typeof l == "string" && !K(l))
          throw new se({ address: l });
        const p = d.match(Kf);
        if (p) {
          const [h, m] = p;
          if (m && V(l) !== Number.parseInt(m))
            throw new Nu({ expectedSize: Number.parseInt(m), givenSize: V(l) });
        }
        const y = s[d];
        y && o(y, l);
      }
    };
  s.EIP712Domain && t && o(s.EIP712Domain, t),
    r !== "EIP712Domain" && o(s[r], n);
}
function ba({ domain: e }) {
  return [
    typeof (e == null ? void 0 : e.name) == "string" && {
      name: "name",
      type: "string",
    },
    (e == null ? void 0 : e.version) && { name: "version", type: "string" },
    typeof (e == null ? void 0 : e.chainId) == "number" && {
      name: "chainId",
      type: "uint256",
    },
    (e == null ? void 0 : e.verifyingContract) && {
      name: "verifyingContract",
      type: "address",
    },
    (e == null ? void 0 : e.salt) && { name: "salt", type: "bytes32" },
  ].filter(Boolean);
}
const t0 = { "0x0": "reverted", "0x1": "success" };
function ga(e) {
  const t = {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((n) => Re(n)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Be(e.transactionIndex) : null,
    status: e.status ? t0[e.status] : null,
    type: e.type ? Mi[e.type] || e.type : null,
  };
  return (
    e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)),
    e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)),
    t
  );
}
const n0 = Kn("transactionReceipt", ga),
  r0 = `Ethereum Signed Message:
`;
function s0(e) {
  const t =
      typeof e == "string"
        ? Pt(e)
        : typeof e.raw == "string"
          ? e.raw
          : X(e.raw),
    n = Pt(`${r0}${V(t)}`);
  return Oe([n, t]);
}
function Bs(e, t) {
  return Q(s0(e), t);
}
const wa = "0x6492649264926492649264926492649264926492649264926492649264926492";
function o0(e) {
  return wi(e, -32) === wa;
}
function i0(e) {
  const { address: t, data: n, signature: r, to: s = "hex" } = e,
    o = Se([
      kt(
        [{ type: "address" }, { type: "bytes" }, { type: "bytes" }],
        [t, n, r],
      ),
      wa,
    ]);
  return s === "hex" ? o : fe(o);
}
function a0(e) {
  const { authorizationList: t } = e;
  if (t)
    for (const n of t) {
      const { contractAddress: r, chainId: s } = n;
      if (!K(r)) throw new se({ address: r });
      if (s <= 0) throw new yn({ chainId: s });
    }
  Cs(e);
}
function c0(e) {
  const { blobVersionedHashes: t } = e;
  if (t) {
    if (t.length === 0) throw new Vi();
    for (const n of t) {
      const r = V(n),
        s = Be(Gt(n, 0, 1));
      if (r !== 32) throw new Fd({ hash: n, size: r });
      if (s !== Hi) throw new Ld({ hash: n, version: s });
    }
  }
  Cs(e);
}
function Cs(e) {
  const { chainId: t, maxPriorityFeePerGas: n, maxFeePerGas: r, to: s } = e;
  if (t <= 0) throw new yn({ chainId: t });
  if (s && !K(s)) throw new se({ address: s });
  if (r && r > 2n ** 256n - 1n) throw new ht({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new an({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function u0(e) {
  const {
    chainId: t,
    maxPriorityFeePerGas: n,
    gasPrice: r,
    maxFeePerGas: s,
    to: o,
  } = e;
  if (t <= 0) throw new yn({ chainId: t });
  if (o && !K(o)) throw new se({ address: o });
  if (n || s)
    throw new E(
      "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.",
    );
  if (r && r > 2n ** 256n - 1n) throw new ht({ maxFeePerGas: r });
}
function l0(e) {
  const {
    chainId: t,
    maxPriorityFeePerGas: n,
    gasPrice: r,
    maxFeePerGas: s,
    to: o,
  } = e;
  if (o && !K(o)) throw new se({ address: o });
  if (typeof t < "u" && t <= 0) throw new yn({ chainId: t });
  if (n || s)
    throw new E(
      "`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.",
    );
  if (r && r > 2n ** 256n - 1n) throw new ht({ maxFeePerGas: r });
}
function d0(e) {
  if (!e || e.length === 0) return [];
  const t = [];
  for (const n of e) {
    const { contractAddress: r, chainId: s, nonce: o, ...i } = n;
    t.push([S(s), r, S(o), ...vn({}, i)]);
  }
  return t;
}
function nr(e) {
  if (!e || e.length === 0) return [];
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const { address: r, storageKeys: s } = e[n];
    for (let o = 0; o < s.length; o++)
      if (s[o].length - 2 !== 64) throw new td({ storageKey: s[o] });
    if (!K(r, { strict: !1 })) throw new se({ address: r });
    t.push([r, s]);
  }
  return t;
}
function va(e, t) {
  const n = Wi(e);
  return n === "eip1559"
    ? p0(e, t)
    : n === "eip2930"
      ? m0(e, t)
      : n === "eip4844"
        ? h0(e, t)
        : n === "eip7702"
          ? f0(e, t)
          : y0(e, t);
}
function f0(e, t) {
  const {
    authorizationList: n,
    chainId: r,
    gas: s,
    nonce: o,
    to: i,
    value: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: u,
    accessList: d,
    data: l,
  } = e;
  a0(e);
  const f = nr(d),
    p = d0(n);
  return Se([
    "0x04",
    Ye([
      S(r),
      o ? S(o) : "0x",
      u ? S(u) : "0x",
      c ? S(c) : "0x",
      s ? S(s) : "0x",
      i ?? "0x",
      a ? S(a) : "0x",
      l ?? "0x",
      f,
      p,
      ...vn(e, t),
    ]),
  ]);
}
function h0(e, t) {
  const {
    chainId: n,
    gas: r,
    nonce: s,
    to: o,
    value: i,
    maxFeePerBlobGas: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: u,
    accessList: d,
    data: l,
  } = e;
  c0(e);
  let f = e.blobVersionedHashes,
    p = e.sidecars;
  if (e.blobs && (typeof f > "u" || typeof p > "u")) {
    const w =
        typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((x) => X(x)),
      v = e.kzg,
      P = ms({ blobs: w, kzg: v });
    if ((typeof f > "u" && (f = qi({ commitments: P })), typeof p > "u")) {
      const x = ys({ blobs: w, commitments: P, kzg: v });
      p = Zi({ blobs: w, commitments: P, proofs: x });
    }
  }
  const y = nr(d),
    h = [
      S(n),
      s ? S(s) : "0x",
      u ? S(u) : "0x",
      c ? S(c) : "0x",
      r ? S(r) : "0x",
      o ?? "0x",
      i ? S(i) : "0x",
      l ?? "0x",
      y,
      a ? S(a) : "0x",
      f ?? [],
      ...vn(e, t),
    ],
    m = [],
    b = [],
    g = [];
  if (p)
    for (let w = 0; w < p.length; w++) {
      const { blob: v, commitment: P, proof: x } = p[w];
      m.push(v), b.push(P), g.push(x);
    }
  return Se(["0x03", Ye(p ? [h, m, b, g] : h)]);
}
function p0(e, t) {
  const {
    chainId: n,
    gas: r,
    nonce: s,
    to: o,
    value: i,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    accessList: u,
    data: d,
  } = e;
  Cs(e);
  const l = nr(u),
    f = [
      S(n),
      s ? S(s) : "0x",
      c ? S(c) : "0x",
      a ? S(a) : "0x",
      r ? S(r) : "0x",
      o ?? "0x",
      i ? S(i) : "0x",
      d ?? "0x",
      l,
      ...vn(e, t),
    ];
  return Se(["0x02", Ye(f)]);
}
function m0(e, t) {
  const {
    chainId: n,
    gas: r,
    data: s,
    nonce: o,
    to: i,
    value: a,
    accessList: c,
    gasPrice: u,
  } = e;
  u0(e);
  const d = nr(c),
    l = [
      S(n),
      o ? S(o) : "0x",
      u ? S(u) : "0x",
      r ? S(r) : "0x",
      i ?? "0x",
      a ? S(a) : "0x",
      s ?? "0x",
      d,
      ...vn(e, t),
    ];
  return Se(["0x01", Ye(l)]);
}
function y0(e, t) {
  const {
    chainId: n = 0,
    gas: r,
    data: s,
    nonce: o,
    to: i,
    value: a,
    gasPrice: c,
  } = e;
  l0(e);
  let u = [
    o ? S(o) : "0x",
    c ? S(c) : "0x",
    r ? S(r) : "0x",
    i ?? "0x",
    a ? S(a) : "0x",
    s ?? "0x",
  ];
  if (t) {
    const d = (() => {
        if (t.v >= 35n)
          return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
        if (n > 0) return BigInt(n * 2) + BigInt(35n + t.v - 27n);
        const p = 27n + (t.v === 27n ? 0n : 1n);
        if (t.v !== p) throw new Ql({ v: t.v });
        return p;
      })(),
      l = Ke(t.r),
      f = Ke(t.s);
    u = [...u, S(d), l === "0x00" ? "0x" : l, f === "0x00" ? "0x" : f];
  } else n > 0 && (u = [...u, S(n), "0x", "0x"]);
  return Ye(u);
}
function vn(e, t) {
  const n = t ?? e,
    { v: r, yParity: s } = n;
  if (typeof n.r > "u") return [];
  if (typeof n.s > "u") return [];
  if (typeof r > "u" && typeof s > "u") return [];
  const o = Ke(n.r),
    i = Ke(n.s);
  return [
    typeof s == "number"
      ? s
        ? S(1)
        : "0x"
      : r === 0n
        ? "0x"
        : r === 1n
          ? S(1)
          : r === 27n
            ? "0x"
            : S(1),
    o === "0x00" ? "0x" : o,
    i === "0x00" ? "0x" : i,
  ];
}
function b0(e) {
  return e.map((t) => ({ ...t, value: BigInt(t.value) }));
}
function g0(e) {
  return {
    ...e,
    balance: e.balance ? BigInt(e.balance) : void 0,
    nonce: e.nonce ? Be(e.nonce) : void 0,
    storageProof: e.storageProof ? b0(e.storageProof) : void 0,
  };
}
async function w0(
  e,
  { address: t, blockNumber: n, blockTag: r, storageKeys: s },
) {
  const o = r ?? "latest",
    i = n !== void 0 ? z(n) : void 0,
    a = await e.request({ method: "eth_getProof", params: [t, s, i || o] });
  return g0(a);
}
async function v0(
  e,
  { address: t, blockNumber: n, blockTag: r = "latest", slot: s },
) {
  const o = n !== void 0 ? z(n) : void 0;
  return await e.request({
    method: "eth_getStorageAt",
    params: [t, s, o || r],
  });
}
async function Ts(
  e,
  { blockHash: t, blockNumber: n, blockTag: r, hash: s, index: o },
) {
  let d, l, f;
  const i = r || "latest",
    a = n !== void 0 ? z(n) : void 0;
  let c = null;
  if (
    (s
      ? (c = await e.request(
          { method: "eth_getTransactionByHash", params: [s] },
          { dedupe: !0 },
        ))
      : t
        ? (c = await e.request(
            {
              method: "eth_getTransactionByBlockHashAndIndex",
              params: [t, z(o)],
            },
            { dedupe: !0 },
          ))
        : (a || i) &&
          (c = await e.request(
            {
              method: "eth_getTransactionByBlockNumberAndIndex",
              params: [a || i, z(o)],
            },
            { dedupe: !!a },
          )),
    !c)
  )
    throw new $i({
      blockHash: t,
      blockNumber: n,
      blockTag: i,
      hash: s,
      index: o,
    });
  return (
    ((f =
      (l = (d = e.chain) == null ? void 0 : d.formatters) == null
        ? void 0
        : l.transaction) == null
      ? void 0
      : f.format) || fs
  )(c);
}
async function x0(e, { hash: t, transactionReceipt: n }) {
  const [r, s] = await Promise.all([
      O(e, gn, "getBlockNumber")({}),
      t ? O(e, Ts, "getTransaction")({ hash: t }) : void 0,
    ]),
    o =
      (n == null ? void 0 : n.blockNumber) ||
      (s == null ? void 0 : s.blockNumber);
  return o ? r - o + 1n : 0n;
}
async function Dr(e, { hash: t }) {
  let s, o, i;
  const n = await e.request(
    { method: "eth_getTransactionReceipt", params: [t] },
    { dedupe: !0 },
  );
  if (!n) throw new Ai({ hash: t });
  return (
    ((i =
      (o = (s = e.chain) == null ? void 0 : s.formatters) == null
        ? void 0
        : o.transactionReceipt) == null
      ? void 0
      : i.format) || ga
  )(n);
}
async function E0(e, t) {
  let m;
  const {
      allowFailure: n = !0,
      batchSize: r,
      blockNumber: s,
      blockTag: o,
      multicallAddress: i,
      stateOverride: a,
    } = t,
    c = t.contracts,
    u =
      r ??
      ((typeof ((m = e.batch) == null ? void 0 : m.multicall) == "object" &&
        e.batch.multicall.batchSize) ||
        1024);
  let d = i;
  if (!d) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. multicallAddress is required.",
      );
    d = Lt({ blockNumber: s, chain: e.chain, contract: "multicall3" });
  }
  const l = [[]];
  let f = 0,
    p = 0;
  for (let b = 0; b < c.length; b++) {
    const { abi: g, address: w, args: v, functionName: P } = c[b];
    try {
      const x = tt({ abi: g, args: v, functionName: P });
      (p += (x.length - 2) / 2),
        u > 0 &&
          p > u &&
          l[f].length > 0 &&
          (f++, (p = (x.length - 2) / 2), (l[f] = [])),
        (l[f] = [...l[f], { allowFailure: !0, callData: x, target: w }]);
    } catch (x) {
      const _ = At(x, {
        abi: g,
        address: w,
        args: v,
        docsPath: "/docs/contract/multicall",
        functionName: P,
      });
      if (!n) throw _;
      l[f] = [...l[f], { allowFailure: !0, callData: "0x", target: w }];
    }
  }
  const y = await Promise.allSettled(
      l.map((b) =>
        O(
          e,
          je,
          "readContract",
        )({
          abi: Or,
          address: d,
          args: [b],
          blockNumber: s,
          blockTag: o,
          functionName: "aggregate3",
          stateOverride: a,
        }),
      ),
    ),
    h = [];
  for (let b = 0; b < y.length; b++) {
    const g = y[b];
    if (g.status === "rejected") {
      if (!n) throw g.reason;
      for (let v = 0; v < l[b].length; v++)
        h.push({ status: "failure", error: g.reason, result: void 0 });
      continue;
    }
    const w = g.value;
    for (let v = 0; v < w.length; v++) {
      const { returnData: P, success: x } = w[v],
        { callData: _ } = l[b][v],
        { abi: $, address: k, functionName: B, args: T } = c[h.length];
      try {
        if (_ === "0x") throw new qn();
        if (!x) throw new cs({ data: P });
        const L = Ft({ abi: $, args: T, data: P, functionName: B });
        h.push(n ? { result: L, status: "success" } : L);
      } catch (L) {
        const G = At(L, {
          abi: $,
          address: k,
          args: T,
          docsPath: "/docs/contract/multicall",
          functionName: B,
        });
        if (!n) throw G;
        h.push({ error: G, result: void 0, status: "failure" });
      }
    }
  }
  if (h.length !== c.length) throw new E("multicall results mismatch");
  return h;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const xa =
    BigInt(0),
  rr = BigInt(1),
  P0 = BigInt(2);
function pt(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
  );
}
function xn(e) {
  if (!pt(e)) throw new Error("Uint8Array expected");
}
const _0 = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0"),
);
function It(e) {
  xn(e);
  let t = "";
  for (let n = 0; n < e.length; n++) t += _0[e[n]];
  return t;
}
function Ea(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function ks(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const Fe = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Po(e) {
  if (e >= Fe._0 && e <= Fe._9) return e - Fe._0;
  if (e >= Fe._A && e <= Fe._F) return e - (Fe._A - 10);
  if (e >= Fe._a && e <= Fe._f) return e - (Fe._a - 10);
}
function Bt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length,
    n = t / 2;
  if (t % 2)
    throw new Error(
      "padded hex string expected, got unpadded hex of length " + t,
    );
  const r = new Uint8Array(n);
  for (let s = 0, o = 0; s < n; s++, o += 2) {
    const i = Po(e.charCodeAt(o)),
      a = Po(e.charCodeAt(o + 1));
    if (i === void 0 || a === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + c + '" at index ' + o,
      );
    }
    r[s] = i * 16 + a;
  }
  return r;
}
function ct(e) {
  return ks(It(e));
}
function Ss(e) {
  return xn(e), ks(It(Uint8Array.from(e).reverse()));
}
function Ct(e, t) {
  return Bt(e.toString(16).padStart(t * 2, "0"));
}
function Ns(e, t) {
  return Ct(e, t).reverse();
}
function $0(e) {
  return Bt(Ea(e));
}
function $e(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = Bt(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (pt(t)) r = Uint8Array.from(t);
  else throw new Error(`${e} must be hex string or Uint8Array`);
  const s = r.length;
  if (typeof n == "number" && s !== n)
    throw new Error(`${e} expected ${n} bytes, got ${s}`);
  return r;
}
function cn(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    xn(s), (t += s.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, s = 0; r < e.length; r++) {
    const o = e[r];
    n.set(o, s), (s += o.length);
  }
  return n;
}
function Pa(e, t) {
  if (e.length !== t.length) return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return n === 0;
}
function A0(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function I0(e) {
  let t;
  for (t = 0; e > xa; e >>= rr, t += 1);
  return t;
}
function B0(e, t) {
  return (e >> BigInt(t)) & rr;
}
function C0(e, t, n) {
  return e | ((n ? rr : xa) << BigInt(t));
}
const Fs = (e) => (P0 << BigInt(e - 1)) - rr,
  mr = (e) => new Uint8Array(e),
  _o = (e) => Uint8Array.from(e);
function _a(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = mr(e),
    s = mr(e),
    o = 0;
  const i = () => {
      r.fill(1), s.fill(0), (o = 0);
    },
    a = (...l) => n(s, r, ...l),
    c = (l = mr()) => {
      (s = a(_o([0]), l)),
        (r = a()),
        l.length !== 0 && ((s = a(_o([1]), l)), (r = a()));
    },
    u = () => {
      if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let l = 0;
      const f = [];
      for (; l < t; ) {
        r = a();
        const p = r.slice();
        f.push(p), (l += r.length);
      }
      return cn(...f);
    };
  return (l, f) => {
    i(), c(l);
    let p;
    for (; !(p = f(u())); ) c();
    return i(), p;
  };
}
const T0 = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || pt(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen),
};
function En(e, t, n = {}) {
  const r = (s, o, i) => {
    const a = T0[o];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const c = e[s];
    if (!(i && c === void 0) && !a(c, e))
      throw new Error(
        `Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`,
      );
  };
  for (const [s, o] of Object.entries(t)) r(s, o, !1);
  for (const [s, o] of Object.entries(n)) r(s, o, !0);
  return e;
}
const k0 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      abytes: xn,
      bitGet: B0,
      bitLen: I0,
      bitMask: Fs,
      bitSet: C0,
      bytesToHex: It,
      bytesToNumberBE: ct,
      bytesToNumberLE: Ss,
      concatBytes: cn,
      createHmacDrbg: _a,
      ensureBytes: $e,
      equalBytes: Pa,
      hexToBytes: Bt,
      hexToNumber: ks,
      isBytes: pt,
      numberToBytesBE: Ct,
      numberToBytesLE: Ns,
      numberToHexUnpadded: Ea,
      numberToVarBytesBE: $0,
      utf8ToBytes: A0,
      validateObject: En,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
function S0(e, t) {
  const n = ve(e) ? Ie(e) : e,
    r = ve(t) ? Ie(t) : t;
  return Pa(n, r);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const re =
    BigInt(0),
  W = BigInt(1),
  st = BigInt(2),
  N0 = BigInt(3),
  Gr = BigInt(4),
  $o = BigInt(5),
  Ao = BigInt(8);
BigInt(9);
BigInt(16);
function ue(e, t) {
  const n = e % t;
  return n >= re ? n : t + n;
}
function F0(e, t, n) {
  if (n <= re || t < re) throw new Error("Expected power/modulo > 0");
  if (n === W) return re;
  let r = W;
  for (; t > re; ) t & W && (r = (r * e) % n), (e = (e * e) % n), (t >>= W);
  return r;
}
function be(e, t, n) {
  let r = e;
  for (; t-- > re; ) (r *= r), (r %= n);
  return r;
}
function Hr(e, t) {
  if (e === re || t <= re)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = ue(e, t),
    r = t,
    s = re,
    o = W;
  for (; n !== re; ) {
    const a = r / n,
      c = r % n,
      u = s - o * a;
    (r = n), (n = c), (s = o), (o = u);
  }
  if (r !== W) throw new Error("invert: does not exist");
  return ue(s, t);
}
function L0(e) {
  const t = (e - W) / st;
  let n, r, s;
  for (n = e - W, r = 0; n % st === re; n /= st, r++);
  for (s = st; s < e && F0(s, t, e) !== e - W; s++);
  if (r === 1) {
    const i = (e + W) / Gr;
    return function (c, u) {
      const d = c.pow(u, i);
      if (!c.eql(c.sqr(d), u)) throw new Error("Cannot find square root");
      return d;
    };
  }
  const o = (n + W) / st;
  return function (a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = r,
      d = a.pow(a.mul(a.ONE, s), n),
      l = a.pow(c, o),
      f = a.pow(c, n);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO)) return a.ZERO;
      let p = 1;
      for (let h = a.sqr(f); p < u && !a.eql(h, a.ONE); p++) h = a.sqr(h);
      const y = a.pow(d, W << BigInt(u - p - 1));
      (d = a.sqr(y)), (l = a.mul(l, y)), (f = a.mul(f, d)), (u = p);
    }
    return l;
  };
}
function z0(e) {
  if (e % Gr === N0) {
    const t = (e + W) / Gr;
    return function (r, s) {
      const o = r.pow(s, t);
      if (!r.eql(r.sqr(o), s)) throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % Ao === $o) {
    const t = (e - $o) / Ao;
    return function (r, s) {
      const o = r.mul(s, st),
        i = r.pow(o, t),
        a = r.mul(s, i),
        c = r.mul(r.mul(a, st), i),
        u = r.mul(a, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(u), s)) throw new Error("Cannot find square root");
      return u;
    };
  }
  return L0(e);
}
const M0 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function O0(e) {
  const t = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = M0.reduce((r, s) => ((r[s] = "function"), r), t);
  return En(e, n);
}
function R0(e, t, n) {
  if (n < re) throw new Error("Expected power > 0");
  if (n === re) return e.ONE;
  if (n === W) return t;
  let r = e.ONE,
    s = t;
  for (; n > re; ) n & W && (r = e.mul(r, s)), (s = e.sqr(s)), (n >>= W);
  return r;
}
function j0(e, t) {
  const n = new Array(t.length),
    r = t.reduce(
      (o, i, a) => (e.is0(i) ? o : ((n[a] = o), e.mul(o, i))),
      e.ONE,
    ),
    s = e.inv(r);
  return (
    t.reduceRight(
      (o, i, a) => (e.is0(i) ? o : ((n[a] = e.mul(o, n[a])), e.mul(o, i))),
      s,
    ),
    n
  );
}
function $a(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function U0(e, t, n = !1, r = {}) {
  if (e <= re) throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: s, nByteLength: o } = $a(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const i = z0(e),
    a = Object.freeze({
      ORDER: e,
      BITS: s,
      BYTES: o,
      MASK: Fs(s),
      ZERO: re,
      ONE: W,
      create: (c) => ue(c, e),
      isValid: (c) => {
        if (typeof c != "bigint")
          throw new Error(
            `Invalid field element: expected bigint, got ${typeof c}`,
          );
        return re <= c && c < e;
      },
      is0: (c) => c === re,
      isOdd: (c) => (c & W) === W,
      neg: (c) => ue(-c, e),
      eql: (c, u) => c === u,
      sqr: (c) => ue(c * c, e),
      add: (c, u) => ue(c + u, e),
      sub: (c, u) => ue(c - u, e),
      mul: (c, u) => ue(c * u, e),
      pow: (c, u) => R0(a, c, u),
      div: (c, u) => ue(c * Hr(u, e), e),
      sqrN: (c) => c * c,
      addN: (c, u) => c + u,
      subN: (c, u) => c - u,
      mulN: (c, u) => c * u,
      inv: (c) => Hr(c, e),
      sqrt: r.sqrt || ((c) => i(a, c)),
      invertBatch: (c) => j0(a, c),
      cmov: (c, u, d) => (d ? u : c),
      toBytes: (c) => (n ? Ns(c, o) : Ct(c, o)),
      fromBytes: (c) => {
        if (c.length !== o)
          throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);
        return n ? Ss(c) : ct(c);
      },
    });
  return Object.freeze(a);
}
function Aa(e) {
  if (typeof e != "bigint") throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Ia(e) {
  const t = Aa(e);
  return t + Math.ceil(t / 2);
}
function q0(e, t, n = !1) {
  const r = e.length,
    s = Aa(t),
    o = Ia(t);
  if (r < 16 || r < o || r > 1024)
    throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
  const i = n ? ct(e) : Ss(e),
    a = ue(i, t - W) + W;
  return n ? Ns(a, s) : Ct(a, s);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const D0 =
    BigInt(0),
  yr = BigInt(1);
function G0(e, t) {
  const n = (s, o) => {
      const i = o.negate();
      return s ? i : o;
    },
    r = (s) => {
      const o = Math.ceil(t / s) + 1,
        i = 2 ** (s - 1);
      return { windows: o, windowSize: i };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(s, o) {
      let i = e.ZERO,
        a = s;
      for (; o > D0; ) o & yr && (i = i.add(a)), (a = a.double()), (o >>= yr);
      return i;
    },
    precomputeWindow(s, o) {
      const { windows: i, windowSize: a } = r(o),
        c = [];
      let u = s,
        d = u;
      for (let l = 0; l < i; l++) {
        (d = u), c.push(d);
        for (let f = 1; f < a; f++) (d = d.add(u)), c.push(d);
        u = d.double();
      }
      return c;
    },
    wNAF(s, o, i) {
      const { windows: a, windowSize: c } = r(s);
      let u = e.ZERO,
        d = e.BASE;
      const l = BigInt(2 ** s - 1),
        f = 2 ** s,
        p = BigInt(s);
      for (let y = 0; y < a; y++) {
        const h = y * c;
        let m = Number(i & l);
        (i >>= p), m > c && ((m -= f), (i += yr));
        const b = h,
          g = h + Math.abs(m) - 1,
          w = y % 2 !== 0,
          v = m < 0;
        m === 0 ? (d = d.add(n(w, o[b]))) : (u = u.add(n(v, o[g])));
      }
      return { p: u, f: d };
    },
    wNAFCached(s, o, i, a) {
      const c = s._WINDOW_SIZE || 1;
      let u = o.get(s);
      return (
        u || ((u = this.precomputeWindow(s, c)), c !== 1 && o.set(s, a(u))),
        this.wNAF(c, u, i)
      );
    },
  };
}
function Ba(e) {
  return (
    O0(e.Fp),
    En(
      e,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" },
    ),
    Object.freeze({ ...$a(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function H0(
  e,
) {
  const t = Ba(e);
  En(
    t,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    },
  );
  const { endo: n, Fp: r, a: s } = t;
  if (n) {
    if (!r.eql(s, r.ZERO))
      throw new Error(
        "Endomorphism can only be defined for Koblitz curves that have a=0",
      );
    if (
      typeof n != "object" ||
      typeof n.beta != "bigint" ||
      typeof n.splitScalar != "function"
    )
      throw new Error(
        "Expected endomorphism with beta: bigint and splitScalar: function",
      );
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: V0, hexToBytes: Z0 } = k0,
  ot = {
    Err: class extends Error {
      constructor(t = "") {
        super(t);
      }
    },
    _parseInt(e) {
      const { Err: t } = ot;
      if (e.length < 2 || e[0] !== 2)
        throw new t("Invalid signature integer tag");
      const n = e[1],
        r = e.subarray(2, n + 2);
      if (!n || r.length !== n)
        throw new t("Invalid signature integer: wrong length");
      if (r[0] & 128) throw new t("Invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return { d: V0(r), l: e.subarray(n + 2) };
    },
    toSig(e) {
      const { Err: t } = ot,
        n = typeof e == "string" ? Z0(e) : e;
      xn(n);
      const r = n.length;
      if (r < 2 || n[0] != 48) throw new t("Invalid signature tag");
      if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
      const { d: s, l: o } = ot._parseInt(n.subarray(2)),
        { d: i, l: a } = ot._parseInt(o);
      if (a.length) throw new t("Invalid signature: left bytes after parsing");
      return { r: s, s: i };
    },
    hexFromSig(e) {
      const t = (u) => (Number.parseInt(u[0], 16) & 8 ? "00" + u : u),
        n = (u) => {
          const d = u.toString(16);
          return d.length & 1 ? `0${d}` : d;
        },
        r = t(n(e.s)),
        s = t(n(e.r)),
        o = r.length / 2,
        i = s.length / 2,
        a = n(o),
        c = n(i);
      return `30${n(i + o + 4)}02${c}${s}02${a}${r}`;
    },
  },
  Le = BigInt(0),
  ge = BigInt(1);
BigInt(2);
const Io = BigInt(3);
BigInt(4);
function W0(e) {
  const t = H0(e),
    { Fp: n } = t,
    r =
      t.toBytes ||
      ((y, h, m) => {
        const b = h.toAffine();
        return cn(Uint8Array.from([4]), n.toBytes(b.x), n.toBytes(b.y));
      }),
    s =
      t.fromBytes ||
      ((y) => {
        const h = y.subarray(1),
          m = n.fromBytes(h.subarray(0, n.BYTES)),
          b = n.fromBytes(h.subarray(n.BYTES, 2 * n.BYTES));
        return { x: m, y: b };
      });
  function o(y) {
    const { a: h, b: m } = t,
      b = n.sqr(y),
      g = n.mul(b, y);
    return n.add(n.add(g, n.mul(y, h)), m);
  }
  if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function i(y) {
    return typeof y == "bigint" && Le < y && y < t.n;
  }
  function a(y) {
    if (!i(y)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const {
      allowedPrivateKeyLengths: h,
      nByteLength: m,
      wrapPrivateKey: b,
      n: g,
    } = t;
    if (h && typeof y != "bigint") {
      if ((pt(y) && (y = It(y)), typeof y != "string" || !h.includes(y.length)))
        throw new Error("Invalid key");
      y = y.padStart(m * 2, "0");
    }
    let w;
    try {
      w = typeof y == "bigint" ? y : ct($e("private key", y, m));
    } catch {
      throw new Error(
        `private key must be ${m} bytes, hex or bigint, not ${typeof y}`,
      );
    }
    return b && (w = ue(w, g)), a(w), w;
  }
  const u = new Map();
  function d(y) {
    if (!(y instanceof l)) throw new Error("ProjectivePoint expected");
  }
  class l {
    constructor(h, m, b) {
      if (
        ((this.px = h),
        (this.py = m),
        (this.pz = b),
        h == null || !n.isValid(h))
      )
        throw new Error("x required");
      if (m == null || !n.isValid(m)) throw new Error("y required");
      if (b == null || !n.isValid(b)) throw new Error("z required");
    }
    static fromAffine(h) {
      const { x: m, y: b } = h || {};
      if (!h || !n.isValid(m) || !n.isValid(b))
        throw new Error("invalid affine point");
      if (h instanceof l) throw new Error("projective point not allowed");
      const g = (w) => n.eql(w, n.ZERO);
      return g(m) && g(b) ? l.ZERO : new l(m, b, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(h) {
      const m = n.invertBatch(h.map((b) => b.pz));
      return h.map((b, g) => b.toAffine(m[g])).map(l.fromAffine);
    }
    static fromHex(h) {
      const m = l.fromAffine(s($e("pointHex", h)));
      return m.assertValidity(), m;
    }
    static fromPrivateKey(h) {
      return l.BASE.multiply(c(h));
    }
    _setWindowSize(h) {
      (this._WINDOW_SIZE = h), u.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !n.is0(this.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: h, y: m } = this.toAffine();
      if (!n.isValid(h) || !n.isValid(m))
        throw new Error("bad point: x or y not FE");
      const b = n.sqr(m),
        g = o(h);
      if (!n.eql(b, g)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: h } = this.toAffine();
      if (n.isOdd) return !n.isOdd(h);
      throw new Error("Field doesn't support isOdd");
    }
    equals(h) {
      d(h);
      const { px: m, py: b, pz: g } = this,
        { px: w, py: v, pz: P } = h,
        x = n.eql(n.mul(m, P), n.mul(w, g)),
        _ = n.eql(n.mul(b, P), n.mul(v, g));
      return x && _;
    }
    negate() {
      return new l(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: h, b: m } = t,
        b = n.mul(m, Io),
        { px: g, py: w, pz: v } = this;
      let P = n.ZERO,
        x = n.ZERO,
        _ = n.ZERO,
        $ = n.mul(g, g),
        k = n.mul(w, w),
        B = n.mul(v, v),
        T = n.mul(g, w);
      return (
        (T = n.add(T, T)),
        (_ = n.mul(g, v)),
        (_ = n.add(_, _)),
        (P = n.mul(h, _)),
        (x = n.mul(b, B)),
        (x = n.add(P, x)),
        (P = n.sub(k, x)),
        (x = n.add(k, x)),
        (x = n.mul(P, x)),
        (P = n.mul(T, P)),
        (_ = n.mul(b, _)),
        (B = n.mul(h, B)),
        (T = n.sub($, B)),
        (T = n.mul(h, T)),
        (T = n.add(T, _)),
        (_ = n.add($, $)),
        ($ = n.add(_, $)),
        ($ = n.add($, B)),
        ($ = n.mul($, T)),
        (x = n.add(x, $)),
        (B = n.mul(w, v)),
        (B = n.add(B, B)),
        ($ = n.mul(B, T)),
        (P = n.sub(P, $)),
        (_ = n.mul(B, k)),
        (_ = n.add(_, _)),
        (_ = n.add(_, _)),
        new l(P, x, _)
      );
    }
    add(h) {
      d(h);
      const { px: m, py: b, pz: g } = this,
        { px: w, py: v, pz: P } = h;
      let x = n.ZERO,
        _ = n.ZERO,
        $ = n.ZERO;
      const k = t.a,
        B = n.mul(t.b, Io);
      let T = n.mul(m, w),
        L = n.mul(b, v),
        G = n.mul(g, P),
        ce = n.add(m, b),
        I = n.add(w, v);
      (ce = n.mul(ce, I)),
        (I = n.add(T, L)),
        (ce = n.sub(ce, I)),
        (I = n.add(m, g));
      let C = n.add(w, P);
      return (
        (I = n.mul(I, C)),
        (C = n.add(T, G)),
        (I = n.sub(I, C)),
        (C = n.add(b, g)),
        (x = n.add(v, P)),
        (C = n.mul(C, x)),
        (x = n.add(L, G)),
        (C = n.sub(C, x)),
        ($ = n.mul(k, I)),
        (x = n.mul(B, G)),
        ($ = n.add(x, $)),
        (x = n.sub(L, $)),
        ($ = n.add(L, $)),
        (_ = n.mul(x, $)),
        (L = n.add(T, T)),
        (L = n.add(L, T)),
        (G = n.mul(k, G)),
        (I = n.mul(B, I)),
        (L = n.add(L, G)),
        (G = n.sub(T, G)),
        (G = n.mul(k, G)),
        (I = n.add(I, G)),
        (T = n.mul(L, I)),
        (_ = n.add(_, T)),
        (T = n.mul(C, I)),
        (x = n.mul(ce, x)),
        (x = n.sub(x, T)),
        (T = n.mul(ce, L)),
        ($ = n.mul(C, $)),
        ($ = n.add($, T)),
        new l(x, _, $)
      );
    }
    subtract(h) {
      return this.add(h.negate());
    }
    is0() {
      return this.equals(l.ZERO);
    }
    wNAF(h) {
      return p.wNAFCached(this, u, h, (m) => {
        const b = n.invertBatch(m.map((g) => g.pz));
        return m.map((g, w) => g.toAffine(b[w])).map(l.fromAffine);
      });
    }
    multiplyUnsafe(h) {
      const m = l.ZERO;
      if (h === Le) return m;
      if ((a(h), h === ge)) return this;
      const { endo: b } = t;
      if (!b) return p.unsafeLadder(this, h);
      let { k1neg: g, k1: w, k2neg: v, k2: P } = b.splitScalar(h),
        x = m,
        _ = m,
        $ = this;
      for (; w > Le || P > Le; )
        w & ge && (x = x.add($)),
          P & ge && (_ = _.add($)),
          ($ = $.double()),
          (w >>= ge),
          (P >>= ge);
      return (
        g && (x = x.negate()),
        v && (_ = _.negate()),
        (_ = new l(n.mul(_.px, b.beta), _.py, _.pz)),
        x.add(_)
      );
    }
    multiply(h) {
      a(h);
      let m = h,
        b,
        g;
      const { endo: w } = t;
      if (w) {
        const { k1neg: v, k1: P, k2neg: x, k2: _ } = w.splitScalar(m);
        let { p: $, f: k } = this.wNAF(P),
          { p: B, f: T } = this.wNAF(_);
        ($ = p.constTimeNegate(v, $)),
          (B = p.constTimeNegate(x, B)),
          (B = new l(n.mul(B.px, w.beta), B.py, B.pz)),
          (b = $.add(B)),
          (g = k.add(T));
      } else {
        const { p: v, f: P } = this.wNAF(m);
        (b = v), (g = P);
      }
      return l.normalizeZ([b, g])[0];
    }
    multiplyAndAddUnsafe(h, m, b) {
      const g = l.BASE,
        w = (P, x) =>
          x === Le || x === ge || !P.equals(g)
            ? P.multiplyUnsafe(x)
            : P.multiply(x),
        v = w(this, m).add(w(h, b));
      return v.is0() ? void 0 : v;
    }
    toAffine(h) {
      const { px: m, py: b, pz: g } = this,
        w = this.is0();
      h == null && (h = w ? n.ONE : n.inv(g));
      const v = n.mul(m, h),
        P = n.mul(b, h),
        x = n.mul(g, h);
      if (w) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(x, n.ONE)) throw new Error("invZ was invalid");
      return { x: v, y: P };
    }
    isTorsionFree() {
      const { h, isTorsionFree: m } = t;
      if (h === ge) return !0;
      if (m) return m(l, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve",
      );
    }
    clearCofactor() {
      const { h, clearCofactor: m } = t;
      return h === ge ? this : m ? m(l, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(h = !0) {
      return this.assertValidity(), r(l, this, h);
    }
    toHex(h = !0) {
      return It(this.toRawBytes(h));
    }
  }
  (l.BASE = new l(t.Gx, t.Gy, n.ONE)), (l.ZERO = new l(n.ZERO, n.ONE, n.ZERO));
  const f = t.nBitLength,
    p = G0(l, t.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: t,
    ProjectivePoint: l,
    normPrivateKeyToScalar: c,
    weierstrassEquation: o,
    isWithinCurveOrder: i,
  };
}
function K0(e) {
  const t = Ba(e);
  return (
    En(
      t,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" },
    ),
    Object.freeze({ lowS: !0, ...t })
  );
}
function Y0(e) {
  const t = K0(e),
    { Fp: n, n: r } = t,
    s = n.BYTES + 1,
    o = 2 * n.BYTES + 1;
  function i(I) {
    return Le < I && I < n.ORDER;
  }
  function a(I) {
    return ue(I, r);
  }
  function c(I) {
    return Hr(I, r);
  }
  const {
      ProjectivePoint: u,
      normPrivateKeyToScalar: d,
      weierstrassEquation: l,
      isWithinCurveOrder: f,
    } = W0({
      ...t,
      toBytes(I, C, M) {
        const U = C.toAffine(),
          q = n.toBytes(U.x),
          H = cn;
        return M
          ? H(Uint8Array.from([C.hasEvenY() ? 2 : 3]), q)
          : H(Uint8Array.from([4]), q, n.toBytes(U.y));
      },
      fromBytes(I) {
        const C = I.length,
          M = I[0],
          U = I.subarray(1);
        if (C === s && (M === 2 || M === 3)) {
          const q = ct(U);
          if (!i(q)) throw new Error("Point is not on curve");
          const H = l(q);
          let oe;
          try {
            oe = n.sqrt(H);
          } catch (Pe) {
            const De = Pe instanceof Error ? ": " + Pe.message : "";
            throw new Error("Point is not on curve" + De);
          }
          const te = (oe & ge) === ge;
          return ((M & 1) === 1) !== te && (oe = n.neg(oe)), { x: q, y: oe };
        } else if (C === o && M === 4) {
          const q = n.fromBytes(U.subarray(0, n.BYTES)),
            H = n.fromBytes(U.subarray(n.BYTES, 2 * n.BYTES));
          return { x: q, y: H };
        } else
          throw new Error(
            `Point of length ${C} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`,
          );
      },
    }),
    p = (I) => It(Ct(I, t.nByteLength));
  function y(I) {
    const C = r >> ge;
    return I > C;
  }
  function h(I) {
    return y(I) ? a(-I) : I;
  }
  const m = (I, C, M) => ct(I.slice(C, M));
  class b {
    constructor(C, M, U) {
      (this.r = C), (this.s = M), (this.recovery = U), this.assertValidity();
    }
    static fromCompact(C) {
      const M = t.nByteLength;
      return (
        (C = $e("compactSignature", C, M * 2)),
        new b(m(C, 0, M), m(C, M, 2 * M))
      );
    }
    static fromDER(C) {
      const { r: M, s: U } = ot.toSig($e("DER", C));
      return new b(M, U);
    }
    assertValidity() {
      if (!f(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!f(this.s)) throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(C) {
      return new b(this.r, this.s, C);
    }
    recoverPublicKey(C) {
      const { r: M, s: U, recovery: q } = this,
        H = _($e("msgHash", C));
      if (q == null || ![0, 1, 2, 3].includes(q))
        throw new Error("recovery id invalid");
      const oe = q === 2 || q === 3 ? M + t.n : M;
      if (oe >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const te = q & 1 ? "03" : "02",
        qe = u.fromHex(te + p(oe)),
        Pe = c(oe),
        De = a(-H * Pe),
        zt = a(U * Pe),
        Ge = u.BASE.multiplyAndAddUnsafe(qe, De, zt);
      if (!Ge) throw new Error("point at infinify");
      return Ge.assertValidity(), Ge;
    }
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, a(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Bt(this.toDERHex());
    }
    toDERHex() {
      return ot.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Bt(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const g = {
    isValidPrivateKey(I) {
      try {
        return d(I), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: d,
    randomPrivateKey: () => {
      const I = Ia(t.n);
      return q0(t.randomBytes(I), t.n);
    },
    precompute(I = 8, C = u.BASE) {
      return C._setWindowSize(I), C.multiply(BigInt(3)), C;
    },
  };
  function w(I, C = !0) {
    return u.fromPrivateKey(I).toRawBytes(C);
  }
  function v(I) {
    const C = pt(I),
      M = typeof I == "string",
      U = (C || M) && I.length;
    return C
      ? U === s || U === o
      : M
        ? U === 2 * s || U === 2 * o
        : I instanceof u;
  }
  function P(I, C, M = !0) {
    if (v(I)) throw new Error("first arg must be private key");
    if (!v(C)) throw new Error("second arg must be public key");
    return u.fromHex(C).multiply(d(I)).toRawBytes(M);
  }
  const x =
      t.bits2int ||
      function (I) {
        const C = ct(I),
          M = I.length * 8 - t.nBitLength;
        return M > 0 ? C >> BigInt(M) : C;
      },
    _ =
      t.bits2int_modN ||
      function (I) {
        return a(x(I));
      },
    $ = Fs(t.nBitLength);
  function k(I) {
    if (typeof I != "bigint") throw new Error("bigint expected");
    if (!(Le <= I && I < $))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ct(I, t.nByteLength);
  }
  function B(I, C, M = T) {
    if (["recovered", "canonical"].some((nt) => nt in M))
      throw new Error("sign() legacy options not supported");
    const { hash: U, randomBytes: q } = t;
    let { lowS: H, prehash: oe, extraEntropy: te } = M;
    H == null && (H = !0),
      (I = $e("msgHash", I)),
      oe && (I = $e("prehashed msgHash", U(I)));
    const qe = _(I),
      Pe = d(C),
      De = [k(Pe), k(qe)];
    if (te != null && te !== !1) {
      const nt = te === !0 ? q(n.BYTES) : te;
      De.push($e("extraEntropy", nt));
    }
    const zt = cn(...De),
      Ge = qe;
    function sr(nt) {
      const yt = x(nt);
      if (!f(yt)) return;
      const qs = c(yt),
        bt = u.BASE.multiply(yt).toAffine(),
        _e = a(bt.x);
      if (_e === Le) return;
      const gt = a(qs * a(Ge + _e * Pe));
      if (gt === Le) return;
      let Ds = (bt.x === _e ? 0 : 2) | Number(bt.y & ge),
        Gs = gt;
      return H && y(gt) && ((Gs = h(gt)), (Ds ^= 1)), new b(_e, Gs, Ds);
    }
    return { seed: zt, k2sig: sr };
  }
  const T = { lowS: t.lowS, prehash: !1 },
    L = { lowS: t.lowS, prehash: !1 };
  function G(I, C, M = T) {
    const { seed: U, k2sig: q } = B(I, C, M),
      H = t;
    return _a(H.hash.outputLen, H.nByteLength, H.hmac)(U, q);
  }
  u.BASE._setWindowSize(8);
  function ce(I, C, M, U = L) {
    let bt;
    const q = I;
    if (((C = $e("msgHash", C)), (M = $e("publicKey", M)), "strict" in U))
      throw new Error("options.strict was renamed to lowS");
    const { lowS: H, prehash: oe } = U;
    let te, qe;
    try {
      if (typeof q == "string" || pt(q))
        try {
          te = b.fromDER(q);
        } catch (_e) {
          if (!(_e instanceof ot.Err)) throw _e;
          te = b.fromCompact(q);
        }
      else if (
        typeof q == "object" &&
        typeof q.r == "bigint" &&
        typeof q.s == "bigint"
      ) {
        const { r: _e, s: gt } = q;
        te = new b(_e, gt);
      } else throw new Error("PARSE");
      qe = u.fromHex(M);
    } catch (_e) {
      if (_e.message === "PARSE")
        throw new Error(
          "signature must be Signature instance, Uint8Array or hex string",
        );
      return !1;
    }
    if (H && te.hasHighS()) return !1;
    oe && (C = t.hash(C));
    const { r: Pe, s: De } = te,
      zt = _(C),
      Ge = c(De),
      sr = a(zt * Ge),
      nt = a(Pe * Ge),
      yt =
        (bt = u.BASE.multiplyAndAddUnsafe(qe, sr, nt)) == null
          ? void 0
          : bt.toAffine();
    return yt ? a(yt.x) === Pe : !1;
  }
  return {
    CURVE: t,
    getPublicKey: w,
    getSharedSecret: P,
    sign: G,
    verify: ce,
    ProjectivePoint: u,
    Signature: b,
    utils: g,
  };
}
class Ca extends Jr {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), Ku(t);
    const r = Gn(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const s = this.blockLen,
      o = new Uint8Array(s);
    o.set(r.length > s ? t.create().update(r).digest() : r);
    for (let i = 0; i < o.length; i++) o[i] ^= 54;
    this.iHash.update(o), (this.oHash = t.create());
    for (let i = 0; i < o.length; i++) o[i] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return _t(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    _t(this),
      un(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: s,
      destroyed: o,
      blockLen: i,
      outputLen: a,
    } = this;
    return (
      (t = t),
      (t.finished = s),
      (t.destroyed = o),
      (t.blockLen = i),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const Ta = (e, t, n) => new Ca(e, t).update(n).digest();
Ta.create = (e, t) => new Ca(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function J0(
  e,
) {
  return { hash: e, hmac: (t, ...n) => Ta(e, t, ol(...n)), randomBytes: il };
}
function X0(e, t) {
  const n = (r) => Y0({ ...e, ...J0(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ka =
    BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    ),
  Bo = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  ),
  Q0 = BigInt(1),
  Vr = BigInt(2),
  Co = (e, t) => (e + t / Vr) / t;
function eh(e) {
  const t = ka,
    n = BigInt(3),
    r = BigInt(6),
    s = BigInt(11),
    o = BigInt(22),
    i = BigInt(23),
    a = BigInt(44),
    c = BigInt(88),
    u = (e * e * e) % t,
    d = (u * u * e) % t,
    l = (be(d, n, t) * d) % t,
    f = (be(l, n, t) * d) % t,
    p = (be(f, Vr, t) * u) % t,
    y = (be(p, s, t) * p) % t,
    h = (be(y, o, t) * y) % t,
    m = (be(h, a, t) * h) % t,
    b = (be(m, c, t) * m) % t,
    g = (be(b, a, t) * h) % t,
    w = (be(g, n, t) * d) % t,
    v = (be(w, i, t) * y) % t,
    P = (be(v, r, t) * u) % t,
    x = be(P, Vr, t);
  if (!Zr.eql(Zr.sqr(x), e)) throw new Error("Cannot find square root");
  return x;
}
const Zr = U0(ka, void 0, void 0, { sqrt: eh }),
  Pn = X0(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: Zr,
      n: Bo,
      Gx: BigInt(
        "55066263022277343669578718895168534326250603453777594175500187360389116729240",
      ),
      Gy: BigInt(
        "32670510020758816978083085130507043184471273380659243275938904335757337482424",
      ),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt(
          "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        ),
        splitScalar: (e) => {
          const t = Bo,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -Q0 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            o = n,
            i = BigInt("0x100000000000000000000000000000000"),
            a = Co(o * e, t),
            c = Co(-r * e, t);
          let u = ue(e - a * n - c * s, t),
            d = ue(-a * r - c * o, t);
          const l = u > i,
            f = d > i;
          if ((l && (u = t - u), f && (d = t - d), u > i || d > i))
            throw new Error("splitScalar: Endomorphism failed, k=" + e);
          return { k1neg: l, k1: u, k2neg: f, k2: d };
        },
      },
    },
    ji,
  );
BigInt(0);
Pn.ProjectivePoint;
const th = Object.freeze(
  Object.defineProperty(
    { __proto__: null, secp256k1: Pn },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
function Sa({ r: e, s: t, to: n = "hex", v: r, yParity: s }) {
  const o = (() => {
      if (s === 0 || s === 1) return s;
      if (r && (r === 27n || r === 28n || r >= 35n))
        return r % 2n === 0n ? 1 : 0;
      throw new Error("Invalid `v` or `yParity` value");
    })(),
    i = `0x${new Pn.Signature(Y(e), Y(t)).toCompactHex()}${o === 0 ? "1b" : "1c"}`;
  return n === "hex" ? i : fe(i);
}
async function Ls(e, t) {
  const {
      address: n,
      factory: r,
      factoryData: s,
      hash: o,
      signature: i,
      ...a
    } = t,
    c = ve(i) ? i : typeof i == "object" && "r" in i && "s" in i ? Sa(i) : X(i),
    u = await (async () =>
      (!r && !s) || o0(c) ? c : i0({ address: r, data: s, signature: c }))();
  try {
    const { data: d } = await O(
      e,
      Xn,
      "call",
    )({ data: Jn({ abi: Ud, args: [n, o, u], bytecode: Hd }), ...a });
    return S0(d ?? "0x0", "0x1");
  } catch (d) {
    try {
      if (ws(Hn(n), await Ti({ hash: o, signature: i }))) return !0;
    } catch {}
    if (d instanceof Ii) return !1;
    throw d;
  }
}
async function nh(
  e,
  { address: t, message: n, factory: r, factoryData: s, signature: o, ...i },
) {
  const a = Bs(n);
  return Ls(e, {
    address: t,
    factory: r,
    factoryData: s,
    hash: a,
    signature: o,
    ...i,
  });
}
async function rh(e, t) {
  const {
      address: n,
      factory: r,
      factoryData: s,
      signature: o,
      message: i,
      primaryType: a,
      types: c,
      domain: u,
      ...d
    } = t,
    l = da({ message: i, primaryType: a, types: c, domain: u });
  return Ls(e, {
    address: n,
    factory: r,
    factoryData: s,
    hash: l,
    signature: o,
    ...d,
  });
}
function Na(
  e,
  {
    emitOnBegin: t = !1,
    emitMissed: n = !1,
    onBlockNumber: r,
    onError: s,
    poll: o,
    pollingInterval: i = e.pollingInterval,
  },
) {
  const a =
    typeof o < "u"
      ? o
      : !(
          e.transport.type === "webSocket" ||
          (e.transport.type === "fallback" &&
            e.transport.transports[0].config.type === "webSocket")
        );
  let c;
  return a
    ? (() => {
        const l = ae(["watchBlockNumber", e.uid, t, n, i]);
        return Xe(l, { onBlockNumber: r, onError: s }, (f) =>
          bn(
            async () => {
              let p;
              try {
                const y = await O(e, gn, "getBlockNumber")({ cacheTime: 0 });
                if (c) {
                  if (y === c) return;
                  if (y - c > 1 && n)
                    for (let h = c + 1n; h < y; h++)
                      f.onBlockNumber(h, c), (c = h);
                }
                (!c || y > c) && (f.onBlockNumber(y, c), (c = y));
              } catch (y) {
                (p = f.onError) == null || p.call(f, y);
              }
            },
            { emitOnBegin: t, interval: i },
          ),
        );
      })()
    : (() => {
        const l = ae(["watchBlockNumber", e.uid, t, n]);
        return Xe(l, { onBlockNumber: r, onError: s }, (f) => {
          let p = !0,
            y = () => (p = !1);
          return (
            (async () => {
              try {
                const h = (() => {
                    if (e.transport.type === "fallback") {
                      const b = e.transport.transports.find(
                        (g) => g.config.type === "webSocket",
                      );
                      return b ? b.value : e.transport;
                    }
                    return e.transport;
                  })(),
                  { unsubscribe: m } = await h.subscribe({
                    params: ["newHeads"],
                    onData(b) {
                      let w;
                      if (!p) return;
                      const g = Y((w = b.result) == null ? void 0 : w.number);
                      f.onBlockNumber(g, c), (c = g);
                    },
                    onError(b) {
                      let g;
                      (g = f.onError) == null || g.call(f, b);
                    },
                  });
                (y = m), p || y();
              } catch (h) {
                s == null || s(h);
              }
            })(),
            () => y()
          );
        });
      })();
}
async function sh(
  e,
  {
    confirmations: t = 1,
    hash: n,
    onReplaced: r,
    pollingInterval: s = e.pollingInterval,
    retryCount: o = 6,
    retryDelay: i = ({ count: c }) => ~~(1 << c) * 200,
    timeout: a,
  },
) {
  const c = ae(["waitForTransactionReceipt", e.uid, n]);
  let u = 0,
    d,
    l,
    f,
    p = !1;
  return new Promise((y, h) => {
    a && setTimeout(() => h(new uo({ hash: n })), a);
    const m = Xe(c, { onReplaced: r, resolve: y, reject: h }, (b) => {
      const g = O(
        e,
        Na,
        "watchBlockNumber",
      )({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: s,
        async onBlockNumber(w) {
          const v = (x) => {
            g(), x(), m();
          };
          let P = w;
          if (!p) {
            u > o && v(() => b.reject(new uo({ hash: n })));
            try {
              if (f) {
                if (t > 1 && (!f.blockNumber || P - f.blockNumber + 1n < t))
                  return;
                v(() => b.resolve(f));
                return;
              }
              if (
                (d ||
                  ((p = !0),
                  await qr(
                    async () => {
                      (d = await O(e, Ts, "getTransaction")({ hash: n })),
                        d.blockNumber && (P = d.blockNumber);
                    },
                    { delay: i, retryCount: o },
                  ),
                  (p = !1)),
                (f = await O(e, Dr, "getTransactionReceipt")({ hash: n })),
                t > 1 && (!f.blockNumber || P - f.blockNumber + 1n < t))
              )
                return;
              v(() => b.resolve(f));
            } catch (x) {
              if (x instanceof $i || x instanceof Ai) {
                if (!d) {
                  p = !1;
                  return;
                }
                try {
                  (l = d), (p = !0);
                  const _ = await qr(
                    () =>
                      O(
                        e,
                        Je,
                        "getBlock",
                      )({ blockNumber: P, includeTransactions: !0 }),
                    {
                      delay: i,
                      retryCount: o,
                      shouldRetry: ({ error: B }) => B instanceof zi,
                    },
                  );
                  p = !1;
                  const $ = _.transactions.find(
                    ({ from: B, nonce: T }) => B === l.from && T === l.nonce,
                  );
                  if (
                    !$ ||
                    ((f = await O(
                      e,
                      Dr,
                      "getTransactionReceipt",
                    )({ hash: $.hash })),
                    t > 1 && (!f.blockNumber || P - f.blockNumber + 1n < t))
                  )
                    return;
                  let k = "replaced";
                  $.to === l.to && $.value === l.value
                    ? (k = "repriced")
                    : $.from === $.to && $.value === 0n && (k = "cancelled"),
                    v(() => {
                      let B;
                      (B = b.onReplaced) == null ||
                        B.call(b, {
                          reason: k,
                          replacedTransaction: l,
                          transaction: $,
                          transactionReceipt: f,
                        }),
                        b.resolve(f);
                    });
                } catch (_) {
                  v(() => b.reject(_));
                }
              } else v(() => b.reject(x));
            } finally {
              u++;
            }
          }
        },
      });
    });
  });
}
function oh(
  e,
  {
    blockTag: t = "latest",
    emitMissed: n = !1,
    emitOnBegin: r = !1,
    onBlock: s,
    onError: o,
    includeTransactions: i,
    poll: a,
    pollingInterval: c = e.pollingInterval,
  },
) {
  const u =
      typeof a < "u"
        ? a
        : !(
            e.transport.type === "webSocket" ||
            (e.transport.type === "fallback" &&
              e.transport.transports[0].config.type === "webSocket")
          ),
    d = i ?? !1;
  let l;
  return u
    ? (() => {
        const y = ae(["watchBlocks", e.uid, t, n, r, d, c]);
        return Xe(y, { onBlock: s, onError: o }, (h) =>
          bn(
            async () => {
              let m;
              try {
                const b = await O(
                  e,
                  Je,
                  "getBlock",
                )({ blockTag: t, includeTransactions: d });
                if (b.number && l != null && l.number) {
                  if (b.number === l.number) return;
                  if (b.number - l.number > 1 && n)
                    for (
                      let g = (l == null ? void 0 : l.number) + 1n;
                      g < b.number;
                      g++
                    ) {
                      const w = await O(
                        e,
                        Je,
                        "getBlock",
                      )({ blockNumber: g, includeTransactions: d });
                      h.onBlock(w, l), (l = w);
                    }
                }
                (!(l != null && l.number) ||
                  (t === "pending" && !(b != null && b.number)) ||
                  (b.number && b.number > l.number)) &&
                  (h.onBlock(b, l), (l = b));
              } catch (b) {
                (m = h.onError) == null || m.call(h, b);
              }
            },
            { emitOnBegin: r, interval: c },
          ),
        );
      })()
    : (() => {
        let y = !0,
          h = () => (y = !1);
        return (
          (async () => {
            try {
              const m = (() => {
                  if (e.transport.type === "fallback") {
                    const g = e.transport.transports.find(
                      (w) => w.config.type === "webSocket",
                    );
                    return g ? g.value : e.transport;
                  }
                  return e.transport;
                })(),
                { unsubscribe: b } = await m.subscribe({
                  params: ["newHeads"],
                  onData(g) {
                    let P, x, _;
                    if (!y) return;
                    const v = (
                      ((_ =
                        (x = (P = e.chain) == null ? void 0 : P.formatters) ==
                        null
                          ? void 0
                          : x.block) == null
                        ? void 0
                        : _.format) || hs
                    )(g.result);
                    s(v, l), (l = v);
                  },
                  onError(g) {
                    o == null || o(g);
                  },
                });
              (h = b), y || h();
            } catch (m) {
              o == null || o(m);
            }
          })(),
          () => h()
        );
      })();
}
function ih(
  e,
  {
    address: t,
    args: n,
    batch: r = !0,
    event: s,
    events: o,
    fromBlock: i,
    onError: a,
    onLogs: c,
    poll: u,
    pollingInterval: d = e.pollingInterval,
    strict: l,
  },
) {
  const f =
      typeof u < "u"
        ? u
        : typeof i == "bigint"
          ? !0
          : !(
              e.transport.type === "webSocket" ||
              (e.transport.type === "fallback" &&
                e.transport.transports[0].config.type === "webSocket")
            ),
    p = l ?? !1;
  return f
    ? (() => {
        const m = ae(["watchEvent", t, n, r, e.uid, s, d, i]);
        return Xe(m, { onLogs: c, onError: a }, (b) => {
          let g;
          i !== void 0 && (g = i - 1n);
          let w,
            v = !1;
          const P = bn(
            async () => {
              let x;
              if (!v) {
                try {
                  w = await O(
                    e,
                    ca,
                    "createEventFilter",
                  )({
                    address: t,
                    args: n,
                    event: s,
                    events: o,
                    strict: p,
                    fromBlock: i,
                  });
                } catch {}
                v = !0;
                return;
              }
              try {
                let _;
                if (w) _ = await O(e, Qn, "getFilterChanges")({ filter: w });
                else {
                  const $ = await O(e, gn, "getBlockNumber")({});
                  g && g !== $
                    ? (_ = await O(
                        e,
                        Es,
                        "getLogs",
                      )({
                        address: t,
                        args: n,
                        event: s,
                        events: o,
                        fromBlock: g + 1n,
                        toBlock: $,
                      }))
                    : (_ = []),
                    (g = $);
                }
                if (_.length === 0) return;
                if (r) b.onLogs(_);
                else for (const $ of _) b.onLogs([$]);
              } catch (_) {
                w && _ instanceof ft && (v = !1),
                  (x = b.onError) == null || x.call(b, _);
              }
            },
            { emitOnBegin: !0, interval: d },
          );
          return async () => {
            w && (await O(e, er, "uninstallFilter")({ filter: w })), P();
          };
        });
      })()
    : (() => {
        let m = !0,
          b = () => (m = !1);
        return (
          (async () => {
            try {
              const g = (() => {
                  if (e.transport.type === "fallback") {
                    const x = e.transport.transports.find(
                      (_) => _.config.type === "webSocket",
                    );
                    return x ? x.value : e.transport;
                  }
                  return e.transport;
                })(),
                w = o ?? (s ? [s] : void 0);
              let v = [];
              w &&
                ((v = [
                  w.flatMap((_) =>
                    dn({ abi: [_], eventName: _.name, args: n }),
                  ),
                ]),
                s && (v = v[0]));
              const { unsubscribe: P } = await g.subscribe({
                params: ["logs", { address: t, topics: v }],
                onData(x) {
                  let $;
                  if (!m) return;
                  const _ = x.result;
                  try {
                    const { eventName: k, args: B } = vs({
                        abi: w ?? [],
                        data: _.data,
                        topics: _.topics,
                        strict: p,
                      }),
                      T = Re(_, { args: B, eventName: k });
                    c([T]);
                  } catch (k) {
                    let B, T;
                    if (k instanceof Dt || k instanceof Dn) {
                      if (l) return;
                      (B = k.abiItem.name),
                        (T =
                          ($ = k.abiItem.inputs) == null
                            ? void 0
                            : $.some((G) => !("name" in G && G.name)));
                    }
                    const L = Re(_, { args: T ? [] : {}, eventName: B });
                    c([L]);
                  }
                },
                onError(x) {
                  a == null || a(x);
                },
              });
              (b = P), m || b();
            } catch (g) {
              a == null || a(g);
            }
          })(),
          () => b()
        );
      })();
}
function ah(
  e,
  {
    batch: t = !0,
    onError: n,
    onTransactions: r,
    poll: s,
    pollingInterval: o = e.pollingInterval,
  },
) {
  return (typeof s < "u" ? s : e.transport.type !== "webSocket")
    ? (() => {
        const u = ae(["watchPendingTransactions", e.uid, t, o]);
        return Xe(u, { onTransactions: r, onError: n }, (d) => {
          let l;
          const f = bn(
            async () => {
              let p;
              try {
                if (!l)
                  try {
                    l = await O(e, ua, "createPendingTransactionFilter")({});
                    return;
                  } catch (h) {
                    throw (f(), h);
                  }
                const y = await O(e, Qn, "getFilterChanges")({ filter: l });
                if (y.length === 0) return;
                if (t) d.onTransactions(y);
                else for (const h of y) d.onTransactions([h]);
              } catch (y) {
                (p = d.onError) == null || p.call(d, y);
              }
            },
            { emitOnBegin: !0, interval: o },
          );
          return async () => {
            l && (await O(e, er, "uninstallFilter")({ filter: l })), f();
          };
        });
      })()
    : (() => {
        let u = !0,
          d = () => (u = !1);
        return (
          (async () => {
            try {
              const { unsubscribe: l } = await e.transport.subscribe({
                params: ["newPendingTransactions"],
                onData(f) {
                  if (!u) return;
                  const p = f.result;
                  r([p]);
                },
                onError(f) {
                  n == null || n(f);
                },
              });
              (d = l), u || d();
            } catch (l) {
              n == null || n(l);
            }
          })(),
          () => d()
        );
      })();
}
function ch(e) {
  let l, f, p;
  const {
      scheme: t,
      statement: n,
      ...r
    } = ((l = e.match(uh)) == null ? void 0 : l.groups) ?? {},
    {
      chainId: s,
      expirationTime: o,
      issuedAt: i,
      notBefore: a,
      requestId: c,
      ...u
    } = ((f = e.match(lh)) == null ? void 0 : f.groups) ?? {},
    d =
      (p = e.split("Resources:")[1]) == null
        ? void 0
        : p
            .split(
              `
- `,
            )
            .slice(1);
  return {
    ...r,
    ...u,
    ...(s ? { chainId: Number(s) } : {}),
    ...(o ? { expirationTime: new Date(o) } : {}),
    ...(i ? { issuedAt: new Date(i) } : {}),
    ...(a ? { notBefore: new Date(a) } : {}),
    ...(c ? { requestId: c } : {}),
    ...(d ? { resources: d } : {}),
    ...(t ? { scheme: t } : {}),
    ...(n ? { statement: n } : {}),
  };
}
const uh =
    /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/,
  lh =
    /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function dh(e) {
  const {
    address: t,
    domain: n,
    message: r,
    nonce: s,
    scheme: o,
    time: i = new Date(),
  } = e;
  if (
    (n && r.domain !== n) ||
    (s && r.nonce !== s) ||
    (o && r.scheme !== o) ||
    (r.expirationTime && i >= r.expirationTime) ||
    (r.notBefore && i < r.notBefore)
  )
    return !1;
  try {
    if (!r.address || (t && !ws(r.address, t))) return !1;
  } catch {
    return !1;
  }
  return !0;
}
async function fh(e, t) {
  const {
      address: n,
      domain: r,
      message: s,
      nonce: o,
      scheme: i,
      signature: a,
      time: c = new Date(),
      ...u
    } = t,
    d = ch(s);
  if (
    !d.address ||
    !dh({ address: n, domain: r, message: d, nonce: o, scheme: i, time: c })
  )
    return !1;
  const f = Bs(s);
  return Ls(e, { address: d.address, hash: f, signature: a, ...u });
}
function hh(e) {
  return {
    call: (t) => Xn(e, t),
    createBlockFilter: () => Df(e),
    createContractEventFilter: (t) => xi(e, t),
    createEventFilter: (t) => ca(e, t),
    createPendingTransactionFilter: () => ua(e),
    estimateContractGas: (t) => Md(e, t),
    estimateGas: (t) => gs(e, t),
    getBalance: (t) => Yi(e, t),
    getBlobBaseFee: () => Gf(e),
    getBlock: (t) => Je(e, t),
    getBlockNumber: (t) => gn(e, t),
    getBlockTransactionCount: (t) => Hf(e, t),
    getBytecode: (t) => Eo(e, t),
    getChainId: () => mn(e),
    getCode: (t) => Eo(e, t),
    getContractEvents: (t) => Ji(e, t),
    getEip712Domain: (t) => ff(e, t),
    getEnsAddress: (t) => If(e, t),
    getEnsAvatar: (t) => jf(e, t),
    getEnsName: (t) => Uf(e, t),
    getEnsResolver: (t) => qf(e, t),
    getEnsText: (t) => aa(e, t),
    getFeeHistory: (t) => Zf(e, t),
    estimateFeesPerGas: (t) => $d(e, t),
    getFilterChanges: (t) => Qn(e, t),
    getFilterLogs: (t) => Wf(e, t),
    getGasPrice: () => ps(e),
    getLogs: (t) => Es(e, t),
    getProof: (t) => w0(e, t),
    estimateMaxPriorityFeePerGas: (t) => _d(e, t),
    getStorageAt: (t) => v0(e, t),
    getTransaction: (t) => Ts(e, t),
    getTransactionConfirmations: (t) => x0(e, t),
    getTransactionCount: (t) => Ri(e, t),
    getTransactionReceipt: (t) => Dr(e, t),
    multicall: (t) => E0(e, t),
    prepareTransactionRequest: (t) => Yn(e, t),
    readContract: (t) => je(e, t),
    sendRawTransaction: (t) => Ps(e, t),
    simulateContract: (t) => ef(e, t),
    verifyMessage: (t) => nh(e, t),
    verifySiweMessage: (t) => fh(e, t),
    verifyTypedData: (t) => rh(e, t),
    uninstallFilter: (t) => er(e, t),
    waitForTransactionReceipt: (t) => sh(e, t),
    watchBlocks: (t) => oh(e, t),
    watchBlockNumber: (t) => Na(e, t),
    watchContractEvent: (t) => cf(e, t),
    watchEvent: (t) => ih(e, t),
    watchPendingTransactions: (t) => ah(e, t),
  };
}
function ph(e, t) {
  const { abi: n, args: r, bytecode: s, ...o } = t,
    i = Jn({ abi: n, args: r, bytecode: s });
  return _s(e, { ...o, data: i });
}
async function mh(e) {
  let n;
  return ((n = e.account) == null ? void 0 : n.type) === "local"
    ? [e.account.address]
    : (await e.request({ method: "eth_accounts" }, { dedupe: !0 })).map((r) =>
        ln(r),
      );
}
async function yh(e) {
  return await e.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function bh(e) {
  return (
    await e.request(
      { method: "eth_requestAccounts" },
      { dedupe: !0, retryCount: 0 },
    )
  ).map((n) => Hn(n));
}
async function gh(e, t) {
  return e.request(
    { method: "wallet_requestPermissions", params: [t] },
    { retryCount: 0 },
  );
}
async function wh(e, { account: t = e.account, message: n }) {
  if (!t) throw new wn({ docsPath: "/docs/actions/wallet/signMessage" });
  const r = ye(t);
  if (r.signMessage) return r.signMessage({ message: n });
  const s =
    typeof n == "string"
      ? Pt(n)
      : n.raw instanceof Uint8Array
        ? S(n.raw)
        : n.raw;
  return e.request(
    { method: "personal_sign", params: [s, r.address] },
    { retryCount: 0 },
  );
}
async function vh(e, t) {
  let u, d, l, f;
  const { account: n = e.account, chain: r = e.chain, ...s } = t;
  if (!n) throw new wn({ docsPath: "/docs/actions/wallet/signTransaction" });
  const o = ye(n);
  pn({ account: o, ...t });
  const i = await O(e, mn, "getChainId")({});
  r !== null && na({ currentChainId: i, chain: r });
  const a =
      (r == null ? void 0 : r.formatters) ||
      ((u = e.chain) == null ? void 0 : u.formatters),
    c =
      ((d = a == null ? void 0 : a.transactionRequest) == null
        ? void 0
        : d.format) || hn;
  return o.signTransaction
    ? o.signTransaction(
        { ...s, chainId: i },
        {
          serializer:
            (f = (l = e.chain) == null ? void 0 : l.serializers) == null
              ? void 0
              : f.transaction,
        },
      )
    : await e.request(
        {
          method: "eth_signTransaction",
          params: [{ ...c(s), chainId: z(i), from: o.address }],
        },
        { retryCount: 0 },
      );
}
async function xh(e, t) {
  const { account: n = e.account, domain: r, message: s, primaryType: o } = t;
  if (!n) throw new wn({ docsPath: "/docs/actions/wallet/signTypedData" });
  const i = ye(n),
    a = { EIP712Domain: ba({ domain: r }), ...t.types };
  if (
    (ya({ domain: r, message: s, primaryType: o, types: a }), i.signTypedData)
  )
    return i.signTypedData({ domain: r, message: s, primaryType: o, types: a });
  const c = e0({ domain: r, message: s, primaryType: o, types: a });
  return e.request(
    { method: "eth_signTypedData_v4", params: [i.address, c] },
    { retryCount: 0 },
  );
}
async function Eh(e, { id: t }) {
  await e.request(
    { method: "wallet_switchEthereumChain", params: [{ chainId: z(t) }] },
    { retryCount: 0 },
  );
}
async function Ph(e, t) {
  return await e.request(
    { method: "wallet_watchAsset", params: t },
    { retryCount: 0 },
  );
}
function _h(e) {
  return {
    addChain: (t) => pf(e, t),
    deployContract: (t) => ph(e, t),
    getAddresses: () => mh(e),
    getChainId: () => mn(e),
    getPermissions: () => yh(e),
    prepareTransactionRequest: (t) => Yn(e, t),
    requestAddresses: () => bh(e),
    requestPermissions: (t) => gh(e, t),
    sendRawTransaction: (t) => Ps(e, t),
    sendTransaction: (t) => _s(e, t),
    signMessage: (t) => wh(e, t),
    signTransaction: (t) => vh(e, t),
    signTypedData: (t) => xh(e, t),
    switchChain: (t) => Eh(e, t),
    watchAsset: (t) => Ph(e, t),
    writeContract: (t) => lf(e, t),
  };
}
function $h(e) {
  const { key: t = "wallet", name: n = "Wallet Client", transport: r } = e;
  return mf({
    ...e,
    key: t,
    name: n,
    transport: r,
    type: "walletClient",
  }).extend(_h);
}
const Ah = 2n ** 16n - 1n;
function Ih(e) {
  if (typeof e == "string") {
    if (!K(e, { strict: !1 })) throw new se({ address: e });
    return { address: e, type: "json-rpc" };
  }
  if (!K(e.address, { strict: !1 })) throw new se({ address: e.address });
  return {
    address: e.address,
    nonceManager: e.nonceManager,
    sign: e.sign,
    experimental_signAuthorization: e.experimental_signAuthorization,
    signMessage: e.signMessage,
    signTransaction: e.signTransaction,
    signTypedData: e.signTypedData,
    source: "custom",
    type: "local",
  };
}
async function _n({ hash: e, privateKey: t, to: n = "object" }) {
  const { r, s, recovery: o } = Pn.sign(e.slice(2), t.slice(2)),
    i = {
      r: z(r, { size: 32 }),
      s: z(s, { size: 32 }),
      v: o ? 28n : 27n,
      yParity: o,
    };
  return n === "bytes" || n === "hex" ? Sa({ ...i, to: n }) : i;
}
async function Bh(e) {
  const {
      contractAddress: t,
      chainId: n,
      nonce: r,
      privateKey: s,
      to: o = "object",
    } = e,
    i = await _n({
      hash: Ni({ contractAddress: t, chainId: n, nonce: r }),
      privateKey: s,
      to: o,
    });
  return o === "object"
    ? { contractAddress: t, chainId: n, nonce: r, ...i }
    : i;
}
async function Ch({ message: e, privateKey: t }) {
  return await _n({ hash: Bs(e), privateKey: t, to: "hex" });
}
async function Th(e) {
  const { privateKey: t, transaction: n, serializer: r = va } = e,
    s = n.type === "eip4844" ? { ...n, sidecars: !1 } : n,
    o = await _n({ hash: Q(r(s)), privateKey: t });
  return r(n, o);
}
async function kh(e) {
  const { privateKey: t, ...n } = e;
  return await _n({ hash: da(n), privateKey: t, to: "hex" });
}
function Sh(e, t = {}) {
  const { nonceManager: n } = t,
    r = S(Pn.getPublicKey(e.slice(2), !1)),
    s = Ci(r);
  return {
    ...Ih({
      address: s,
      nonceManager: n,
      async sign({ hash: i }) {
        return _n({ hash: i, privateKey: e, to: "hex" });
      },
      async experimental_signAuthorization(i) {
        return Bh({ ...i, privateKey: e });
      },
      async signMessage({ message: i }) {
        return Ch({ message: i, privateKey: e });
      },
      async signTransaction(i, { serializer: a } = {}) {
        return Th({ privateKey: e, transaction: i, serializer: a });
      },
      async signTypedData(i) {
        return kh({ ...i, privateKey: e });
      },
    }),
    publicKey: r,
    source: "privateKey",
  };
}
const zs = 50000n,
  To = Ah * 32n,
  Fa = {
    block: Pd({
      format(e) {
        let n;
        const t =
          (n = e.transactions) == null
            ? void 0
            : n.map((r) => {
                let o;
                if (typeof r == "string") return r;
                const s = (o = Fa.transaction) == null ? void 0 : o.format(r);
                return (
                  s.typeHex === "0x71"
                    ? (s.type = "eip712")
                    : s.typeHex === "0xff" && (s.type = "priority"),
                  s
                );
              });
        return {
          l1BatchNumber: e.l1BatchNumber ? Y(e.l1BatchNumber) : null,
          l1BatchTimestamp: e.l1BatchTimestamp ? Y(e.l1BatchTimestamp) : null,
          transactions: t,
        };
      },
    }),
    transaction: xd({
      format(e) {
        const t = {};
        return (
          e.type === "0x71"
            ? (t.type = "eip712")
            : e.type === "0xff" && (t.type = "priority"),
          {
            ...t,
            l1BatchNumber: e.l1BatchNumber ? Y(e.l1BatchNumber) : null,
            l1BatchTxIndex: e.l1BatchTxIndex ? Y(e.l1BatchTxIndex) : null,
          }
        );
      },
    }),
    transactionReceipt: n0({
      format(e) {
        return {
          l1BatchNumber: e.l1BatchNumber ? Y(e.l1BatchNumber) : null,
          l1BatchTxIndex: e.l1BatchTxIndex ? Y(e.l1BatchTxIndex) : null,
          logs: e.logs.map((t) => ({
            ...Re(t),
            l1BatchNumber: t.l1BatchNumber ? Y(t.l1BatchNumber) : null,
            transactionLogIndex: Be(t.transactionLogIndex),
            logType: t.logType,
          })),
          l2ToL1Logs: e.l2ToL1Logs.map((t) => ({
            blockNumber: Y(t.blockHash),
            blockHash: t.blockHash,
            l1BatchNumber: Y(t.l1BatchNumber),
            transactionIndex: Y(t.transactionIndex),
            shardId: Y(t.shardId),
            isService: t.isService,
            sender: t.sender,
            key: t.key,
            value: t.value,
            transactionHash: t.transactionHash,
            logIndex: Y(t.logIndex),
          })),
        };
      },
    }),
    transactionRequest: yd({
      exclude: [
        "customSignature",
        "factoryDeps",
        "gasPerPubdata",
        "paymaster",
        "paymasterInput",
      ],
      format(e) {
        return e.gasPerPubdata ||
          (e.paymaster && e.paymasterInput) ||
          e.factoryDeps ||
          e.customSignature
          ? {
              eip712Meta: {
                ...(e.gasPerPubdata
                  ? { gasPerPubdata: S(e.gasPerPubdata) }
                  : { gasPerPubdata: S(zs) }),
                ...(e.paymaster && e.paymasterInput
                  ? {
                      paymasterParams: {
                        paymaster: e.paymaster,
                        paymasterInput: Array.from(fe(e.paymasterInput)),
                      },
                    }
                  : {}),
                ...(e.factoryDeps
                  ? { factoryDeps: e.factoryDeps.map((t) => Array.from(fe(t))) }
                  : {}),
                ...(e.customSignature
                  ? { customSignature: Array.from(fe(e.customSignature)) }
                  : {}),
              },
              type: "0x71",
            }
          : {};
      },
    }),
  };
class Nh extends E {
  constructor() {
    super(
      [
        "Transaction is not an EIP712 transaction.",
        "",
        "Transaction must:",
        '  - include `type: "eip712"`',
        "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`",
      ].join(`
`),
      { name: "InvalidEip712TransactionError" },
    );
  }
}
function La(e) {
  return !!(
    e.type === "eip712" ||
    ("customSignature" in e && e.customSignature) ||
    ("paymaster" in e && e.paymaster) ||
    ("paymasterInput" in e && e.paymasterInput) ||
    ("gasPerPubdata" in e && typeof e.gasPerPubdata == "bigint") ||
    ("factoryDeps" in e && e.factoryDeps)
  );
}
function za(e) {
  const { chainId: t, to: n, from: r, paymaster: s, paymasterInput: o } = e;
  if (!La(e)) throw new Nh();
  if (!t || t <= 0) throw new yn({ chainId: t });
  if (n && !K(n)) throw new se({ address: n });
  if (r && !K(r)) throw new se({ address: r });
  if (s && !K(s)) throw new se({ address: s });
  if (s && !o)
    throw new E(
      "`paymasterInput` must be provided when `paymaster` is defined",
    );
  if (!s && o)
    throw new E(
      "`paymaster` must be provided when `paymasterInput` is defined",
    );
}
function Fh(e, t) {
  return La(e) ? zh(e) : va(e, t);
}
const Lh = { transaction: Fh };
function zh(e) {
  const {
    chainId: t,
    gas: n,
    nonce: r,
    to: s,
    from: o,
    value: i,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    customSignature: u,
    factoryDeps: d,
    paymaster: l,
    paymasterInput: f,
    gasPerPubdata: p,
    data: y,
  } = e;
  za(e);
  const h = [
    r ? S(r) : "0x",
    c ? S(c) : "0x",
    a ? S(a) : "0x",
    n ? S(n) : "0x",
    s ?? "0x",
    i ? S(i) : "0x",
    y ?? "0x0",
    S(t),
    S(""),
    S(""),
    S(t),
    o ?? "0x",
    S(p || zs),
    d ?? [],
    u ?? "0x",
    l && f ? [l, f] : [],
  ];
  return Se(["0x71", Ye(h)]);
}
class Mh extends E {
  constructor({ givenLength: t, maxBytecodeSize: n }) {
    super(`Bytecode cannot be longer than ${n} bytes. Given length: ${t}`, {
      name: "BytecodeLengthExceedsMaxSizeError",
    });
  }
}
class Oh extends E {
  constructor({ givenLengthInWords: t }) {
    super(
      `Bytecode length in 32-byte words must be odd. Given length in words: ${t}`,
      { name: "BytecodeLengthInWordsMustBeOddError" },
    );
  }
}
class Rh extends E {
  constructor({ givenLength: t }) {
    super(
      `The bytecode length in bytes must be divisible by 32. Given length: ${t}`,
      { name: "BytecodeLengthMustBeDivisibleBy32Error" },
    );
  }
}
function jh(e) {
  const t = Ie(e);
  if (t.length % 32 !== 0) throw new Rh({ givenLength: t.length });
  if (t.length > To)
    throw new Mh({ givenLength: t.length, maxBytecodeSize: To });
  const n = Ui(t),
    r = Ie(n),
    s = t.length / 32;
  if (s % 2 === 0) throw new Oh({ givenLengthInWords: s });
  const o = Ie(s),
    i = mt(o, { size: 2 }),
    a = new Uint8Array([1, 0]);
  return r.set(a, 0), r.set(i, 2), r;
}
const Uh = (e) => {
  za(e);
  const t = qh(e);
  return {
    domain: { name: "zkSync", version: "2", chainId: e.chainId },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" },
      ],
    },
    primaryType: "Transaction",
    message: t,
  };
};
function qh(e) {
  const {
    gas: t,
    nonce: n,
    to: r,
    from: s,
    value: o,
    maxFeePerGas: i,
    maxPriorityFeePerGas: a,
    factoryDeps: c,
    paymaster: u,
    paymasterInput: d,
    gasPerPubdata: l,
    data: f,
  } = e;
  return {
    txType: 113n,
    from: BigInt(s),
    to: r ? BigInt(r) : 0n,
    gasLimit: t ?? 0n,
    gasPerPubdataByteLimit: l ?? zs,
    maxFeePerGas: i ?? 0n,
    maxPriorityFeePerGas: a ?? 0n,
    paymaster: u ? BigInt(u) : 0n,
    nonce: n ? BigInt(n) : 0n,
    value: o ?? 0n,
    data: f || "0x0",
    factoryDeps: (c == null ? void 0 : c.map((p) => S(jh(p)))) ?? [],
    paymasterInput: d || "0x",
  };
}
const Ma = { formatters: Fa, serializers: Lh, custom: { getEip712Domain: Uh } },
  Wr = la({
    ...Ma,
    id: 324,
    name: "ZKsync Era",
    network: "zksync-era",
    nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
    rpcUrls: {
      default: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"],
      },
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://era.zksync.network/",
        apiUrl: "https://api-era.zksync.network/api",
      },
      native: {
        name: "ZKsync Explorer",
        url: "https://explorer.zksync.io/",
        apiUrl: "https://block-explorer-api.mainnet.zksync.io/api",
      },
    },
    contracts: {
      multicall3: { address: "0xF9cda624FBC7e059355ce98a31693d299FACd963" },
    },
  }),
  Kr = la({
    ...Ma,
    id: 300,
    name: "ZKsync Sepolia Testnet",
    network: "zksync-sepolia-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sepolia.era.zksync.dev"],
        webSocket: ["wss://sepolia.era.zksync.dev/ws"],
      },
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://sepolia-era.zksync.network/",
        apiUrl: "https://api-sepolia-era.zksync.network/api",
      },
      native: {
        name: "ZKsync Explorer",
        url: "https://sepolia.explorer.zksync.io/",
        blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api",
      },
    },
    contracts: {
      multicall3: { address: "0xF9cda624FBC7e059355ce98a31693d299FACd963" },
    },
    testnet: !0,
  }),
  Rn = [Wr, Kr],
  Dh = {
    [Wr.id]: Wr.blockExplorers.native.apiUrl,
    [Kr.id]: Kr.blockExplorers.native.blockExplorerApi,
  },
  Qe = Oo("account", () => {
    const e = Do("account", null, void 0, { serializer: qo.object }),
      t = (d) => {
        e.value = d;
      },
      n = () => {
        e.value = null;
      };
    let r = null;
    const s = de(null),
      o = Z(() => !!s.value),
      i = () => {
        if (!e.value) throw new Error("No account data");
        (r = Sh(e.value.privateKey)), (s.value = r.address);
      },
      a = () => {
        (r = null), (s.value = null);
      };
    return (
      ut(
        e,
        (d) => {
          d ? i() : a();
        },
        { immediate: !0 },
      ),
      {
        address: s,
        isLoggedIn: o,
        getWalletClient: ({ chainId: d }) => {
          if (!r) throw new Error("No account data");
          const l = Rn.find((p) => p.id === d) || Rn[0];
          return $h({ account: r, chain: l, transport: _f() }).extend(hh);
        },
        createSessionKey: async () => {
          if (!e.value) throw new Error("No account data");
          return await Promise.resolve(e.value.privateKey);
        },
        login: t,
        logout: n,
      }
    );
  });
function Ms(e) {
  const t = de(!1),
    n = de(null),
    r = de(null),
    s = de(null);
  async function o(...i) {
    (s.value = i), (t.value = !0), (n.value = null);
    try {
      const a = await e(...i);
      return (r.value = a), a;
    } catch (a) {
      const c =
        a instanceof Error ? a : new Error("An unexpected error occurred.");
      if (((n.value = c), c)) throw c;
    } finally {
      t.value = !1;
    }
  }
  return { result: r, inProgress: t, payload: s, error: n, execute: o };
}
const Gh = async (e, t) => {
    if (
      !window.PublicKeyCredential ||
      !PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable ||
      !PublicKeyCredential.isConditionalMediationAvailable
    )
      throw new Error("No platform authenticator available");
    if (
      !(
        await Promise.all([
          PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(),
          PublicKeyCredential.isConditionalMediationAvailable(),
        ])
      ).every((s) => s === !0)
    )
      throw new Error("No platform authenticator available");
    return await navigator.credentials.create({
      publicKey: {
        challenge: new Uint8Array(32),
        rp: { name: "account.zksync.io", id: "localhost" },
        user: { id: new Uint8Array(16), name: e, displayName: t },
        pubKeyCredParams: [
          { alg: -7, type: "public-key" },
          { alg: -257, type: "public-key" },
        ],
        excludeCredentials: [],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          requireResidentKey: !0,
        },
      },
    });
  },
  Hh = { class: "h-full flex flex-col" },
  Vh = { class: "flex justify-center items-center isolate mt-6" },
  Zh = N(
    "h1",
    { class: "text-white text-center text-2xl mt-8 font-semibold" },
    " Login to your account ",
    -1,
  ),
  Wh = { class: "mt-auto flex flex-col gap-4" },
  Kh = ee({
    __name: "Login",
    setup(e) {
      const { login: t } = Qe(),
        {
          inProgress: n,
          execute: r,
          error: s,
        } = Ms(async () => {
          await Gh("ZKsync Account", ""),
            t({
              privateKey:
                "0x4ab2ece42121c123ac09b423499c665360fa9c23772d6b72f689b9c31f4f014d",
            });
        });
      return (o, i) => {
        const a = lc,
          c = jn;
        return (
          F(),
          j("div", Hh, [
            N("div", Vh, [
              R(a, {
                class: "w-full h-auto max-h-10 max-w-full object-contain",
              }),
            ]),
            Zh,
            le(" " + ne(A(s)) + " ", 1),
            N("div", Wh, [
              R(
                c,
                {
                  class: "w-full",
                  loading: A(n),
                  onClick: i[0] || (i[0] = (u) => A(r)()),
                },
                { default: D(() => [le(" Create account ")]), _: 1 },
                8,
                ["loading"],
              ),
              R(
                c,
                {
                  class: "w-full",
                  variant: "neutral",
                  loading: A(n),
                  onClick: i[1] || (i[1] = (u) => A(r)()),
                },
                { default: D(() => [le(" I already have account ")]), _: 1 },
                8,
                ["loading"],
              ),
            ]),
          ])
        );
      };
    },
  }),
  Yh = {},
  Jh = { class: "h-full flex items-center justify-center py-10" },
  Xh = { class: "w-max h-max appear-with-delay" };
function Qh(e, t) {
  const n = Ro;
  return F(), j("div", Jh, [N("div", Xh, [R(n, { class: "w-16 h-16" })])]);
}
const ep = xe(Yh, [
    ["render", Qh],
    ["__scopeId", "data-v-99a19b7e"],
  ]),
  Oa = (e, t = 3) => `${e.slice(0, t + 2)}...${e.slice(-t)}`,
  Ra = (e, t, n = 4) => {
    const r = lt(e, t);
    if (parseFloat(r) < Math.pow(10, -n))
      return `<${Math.pow(10, -n).toFixed(n)}`;
    const s = r.indexOf(".");
    if (s === -1) return r;
    const o = r.slice(0, s),
      i = r.slice(s + 1);
    let a = i.slice(0, n);
    return (
      i.length > n &&
        parseInt(i[n], 10) >= 5 &&
        (a = (parseInt(a, 10) + 1).toString().padStart(n, "0")),
      (a = a.replace(/0+$/, "")),
      a === "" ? o : `${o}.${a}`
    );
  },
  ja = (e) => {
    if (e) {
      if (e < 0.01) return "<$0.01";
    } else return "$0.00";
    const t = 2;
    return e.toFixed(t).endsWith(`.${"0".repeat(t)}`)
      ? "$" + e.toFixed(0)
      : "$" + e.toFixed(2);
  },
  tp = (e, t, n) => {
    const r = lt(e, t);
    return ja(parseFloat(r) * n);
  };
function np(e, t) {
  return (
    F(),
    j(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
      },
      [
        N("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15M12 9l-3 3m0 0 3 3m-3-3h12.75",
        }),
      ],
    )
  );
}
function br(e, t) {
  return (
    F(),
    j(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
      },
      [
        N("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "m4.5 12.75 6 6 9-13.5",
        }),
      ],
    )
  );
}
function rp(e, t) {
  return (
    F(),
    j(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
      },
      [
        N("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z",
        }),
      ],
    )
  );
}
function sp(e, t) {
  return (
    F(),
    j(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
      },
      [
        N("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M7.864 4.243A7.5 7.5 0 0 1 19.5 10.5c0 2.92-.556 5.709-1.568 8.268M5.742 6.364A7.465 7.465 0 0 0 4.5 10.5a7.464 7.464 0 0 1-1.15 3.993m1.989 3.559A11.209 11.209 0 0 0 8.25 10.5a3.75 3.75 0 1 1 7.5 0c0 .527-.021 1.049-.064 1.565M12 10.5a14.94 14.94 0 0 1-3.6 9.75m6.633-4.596a18.666 18.666 0 0 1-2.485 5.33",
        }),
      ],
    )
  );
}
const Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.createAvatar = qa = Tt.getGradientColors = void 0;
function Ua(e) {
  let t;
  const n =
      (t = e.match(/.{1,7}/g)) === null || t === void 0
        ? void 0
        : t.splice(0, 5),
    r = [];
  return (
    n == null ||
      n.forEach((s) => {
        let o = 0;
        for (let a = 0; a < s.length; a += 1)
          (o = s.charCodeAt(a) + ((o << 5) - o)), (o = o & o);
        const i = [0, 0, 0];
        for (let a = 0; a < 3; a += 1) {
          const c = (o >> (a * 8)) & 255;
          i[a] = c;
        }
        r.push(`rgb(${i[0]}, ${i[1]}, ${i[2]})`);
      }),
    r
  );
}
var qa = (Tt.getGradientColors = Ua);
function Da(e, t) {
  const n = Ua(t),
    r = typeof e == "string" ? document.querySelector(e) : e;
  if (!r) throw new Error("Avatar element not found");
  (r.style.borderRadius = "50%"),
    (r.style.boxShadow = "inset 0 0 0 1px rgba(0, 0, 0, 0.1)"),
    (r.style.backgroundColor = n[0]),
    (r.style.backgroundImage = `
    radial-gradient(at 66% 77%, ${n[1]} 0px, transparent 50%),
    radial-gradient(at 29% 97%, ${n[2]} 0px, transparent 50%),
    radial-gradient(at 99% 86%, ${n[3]} 0px, transparent 50%),
    radial-gradient(at 29% 88%, ${n[4]} 0px, transparent 50%)
  `);
}
Tt.createAvatar = Da;
Tt.default = Da;
const op = { class: "web3-avatar" },
  ip = ee({
    __name: "Avatar",
    props: { address: { type: String, required: !0 } },
    setup(e) {
      const t = e;
      ec((r) => ({
        "6ebd55e8": A(n)[0],
        "6ebd5607": A(n)[1],
        "6ebd5626": A(n)[2],
        "6ebd5645": A(n)[3],
        "6ebd5664": A(n)[4],
      }));
      const n = Z(() => qa(t.address));
      return (r, s) => (F(), j("div", op));
    },
  }),
  ap = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r, s] of t) n[r] = s;
    return n;
  },
  Os = ap(ip, [["__scopeId", "data-v-75502b3d"]]),
  cp = {
    class: "flex items-center -mx-4 -mt-4 border-b border-neutral-900 p-4 mb-4",
  },
  up = { class: "text-sm flex items-center" },
  lp = { class: "text-neutral-400" },
  dp = { class: "font-medium" },
  Rs = ee({
    __name: "AccountHeader",
    props: { message: { type: String, required: !0 } },
    setup(e) {
      const { logout: t } = Qe(),
        { address: n } = Te(Qe());
      return (r, s) => (
        F(),
        j("div", cp, [
          N("div", up, [
            N("span", lp, ne(e.message) + "", 1),
            R(
              A(Os),
              { address: A(n), class: "w-4 h-4 rounded-full" },
              null,
              8,
              ["address"],
            ),
            N(
              "span",
              dp,
              "" +
                ne(("shortenAddress" in r ? r.shortenAddress : A(Oa))(A(n))),
              1,
            ),
          ]),
          N(
            "button",
            {
              class:
                "ml-auto w-5 h-5 text-neutral-400 hover:text-white transition",
              onClick: s[0] || (s[0] = (o) => A(t)()),
            },
            [R(A(np))],
          ),
        ])
      );
    },
  }),
  $n = () => {
    const e = tc(),
      t = Z(() => e.query.origin),
      n = Do("app-meta", {});
    return {
      appMeta: Z({
        get: () => n.value[t.value],
        set: (s) => {
          n.value[t.value] = s;
        },
      }),
      origin: t,
    };
  };
class fp {
  constructor() {
    He(this, "listeners", new Map());
    He(this, "openerOrigin");
    He(this, "messageHandler", (t) => {
      t.origin === this.openerOrigin &&
        this.listeners.forEach((n, r) => {
          r(t) &&
            (window.removeEventListener("message", r),
            this.listeners.delete(r));
        });
    });
    He(this, "postMessage", (t) => {
      if (!window.opener) throw new Error("No opener window found");
      window.opener.postMessage(t, this.openerOrigin);
    });
    He(
      this,
      "onMessage",
      async (t) =>
        new Promise((n, r) => {
          const s = (o) => {
            const i = o.data;
            return t(i) ? (n(i), !0) : !1;
          };
          window.addEventListener("message", s),
            this.listeners.set(s, { reject: r });
        }),
    );
    He(this, "disconnect", () => {
      this.listeners.forEach(({ reject: t }, n) => {
        window.removeEventListener("message", n),
          t(new Error("Request rejected"));
      }),
        this.listeners.clear(),
        window.close();
    });
    He(this, "init", () => {
      this.postMessage({ event: "PopupLoaded", id: crypto.randomUUID() }),
        this.onMessage(({ event: t }) => t === "PopupUnload")
          .then(this.disconnect)
          .catch(() => {}),
        window.addEventListener("beforeunload", () => {
          this.postMessage({ event: "PopupUnload", id: crypto.randomUUID() });
        });
    });
    const t = new URLSearchParams(window.location.search).get("origin");
    if (!t) throw new Error("Origin not defined in query params");
    (this.openerOrigin = t),
      window.addEventListener("message", this.messageHandler);
  }
}
const Ut = new fp();
const hp = { exports: {} };
(function (e) {
  let t = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function s(c, u, d) {
    (this.fn = c), (this.context = u), (this.once = d || !1);
  }
  function o(c, u, d, l, f) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    const p = new s(d, l || c, f),
      y = n ? n + u : u;
    return (
      c._events[y]
        ? c._events[y].fn
          ? (c._events[y] = [c._events[y], p])
          : c._events[y].push(p)
        : ((c._events[y] = p), c._eventsCount++),
      c
    );
  }
  function i(c, u) {
    --c._eventsCount === 0 ? (c._events = new r()) : delete c._events[u];
  }
  function a() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (a.prototype.eventNames = function () {
    let u = [],
      d,
      l;
    if (this._eventsCount === 0) return u;
    for (l in (d = this._events)) t.call(d, l) && u.push(n ? l.slice(1) : l);
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(d))
      : u;
  }),
    (a.prototype.listeners = function (u) {
      const d = n ? n + u : u,
        l = this._events[d];
      if (!l) return [];
      if (l.fn) return [l.fn];
      for (var f = 0, p = l.length, y = new Array(p); f < p; f++)
        y[f] = l[f].fn;
      return y;
    }),
    (a.prototype.listenerCount = function (u) {
      const d = n ? n + u : u,
        l = this._events[d];
      return l ? (l.fn ? 1 : l.length) : 0;
    }),
    (a.prototype.emit = function (u, d, l, f, p, y) {
      const h = n ? n + u : u;
      if (!this._events[h]) return !1;
      let m = this._events[h],
        b = arguments.length,
        g,
        w;
      if (m.fn) {
        switch ((m.once && this.removeListener(u, m.fn, void 0, !0), b)) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, d), !0;
          case 3:
            return m.fn.call(m.context, d, l), !0;
          case 4:
            return m.fn.call(m.context, d, l, f), !0;
          case 5:
            return m.fn.call(m.context, d, l, f, p), !0;
          case 6:
            return m.fn.call(m.context, d, l, f, p, y), !0;
        }
        for (w = 1, g = new Array(b - 1); w < b; w++) g[w - 1] = arguments[w];
        m.fn.apply(m.context, g);
      } else {
        let v = m.length,
          P;
        for (w = 0; w < v; w++)
          switch (
            (m[w].once && this.removeListener(u, m[w].fn, void 0, !0), b)
          ) {
            case 1:
              m[w].fn.call(m[w].context);
              break;
            case 2:
              m[w].fn.call(m[w].context, d);
              break;
            case 3:
              m[w].fn.call(m[w].context, d, l);
              break;
            case 4:
              m[w].fn.call(m[w].context, d, l, f);
              break;
            default:
              if (!g)
                for (P = 1, g = new Array(b - 1); P < b; P++)
                  g[P - 1] = arguments[P];
              m[w].fn.apply(m[w].context, g);
          }
      }
      return !0;
    }),
    (a.prototype.on = function (u, d, l) {
      return o(this, u, d, l, !1);
    }),
    (a.prototype.once = function (u, d, l) {
      return o(this, u, d, l, !0);
    }),
    (a.prototype.removeListener = function (u, d, l, f) {
      const p = n ? n + u : u;
      if (!this._events[p]) return this;
      if (!d) return i(this, p), this;
      const y = this._events[p];
      if (y.fn)
        y.fn === d && (!f || y.once) && (!l || y.context === l) && i(this, p);
      else {
        for (var h = 0, m = [], b = y.length; h < b; h++)
          (y[h].fn !== d || (f && !y[h].once) || (l && y[h].context !== l)) &&
            m.push(y[h]);
        m.length ? (this._events[p] = m.length === 1 ? m[0] : m) : i(this, p);
      }
      return this;
    }),
    (a.prototype.removeAllListeners = function (u) {
      let d;
      return (
        u
          ? ((d = n ? n + u : u), this._events[d] && i(this, d))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = n),
    (a.EventEmitter = a),
    (e.exports = a);
})(hp);
const pp = {
  handshake: ["eth_requestAccounts"],
  sign: [
    "eth_ecRecover",
    "personal_sign",
    "personal_ecRecover",
    "eth_signTransaction",
    "eth_sendTransaction",
    "eth_signTypedData_v1",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_signTypedData",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_watchAsset",
    "wallet_getCapabilities",
    "wallet_sendCalls",
    "wallet_showCallsStatus",
  ],
  state: ["eth_chainId", "eth_accounts", "net_version"],
  deprecated: [],
};
Hn("0x000000000000000000000000000000000000800a");
const Ue = Oo("requests", () => {
    const { appMeta: e } = $n(),
      t = de(),
      n = Z(() => {
        let c, u;
        const a = (c = t.value) == null ? void 0 : c.request.action.method;
        if (a)
          return (u = Object.entries(pp).find(([d, l]) => l.includes(a))) ==
            null
            ? void 0
            : u[0];
      }),
      r = Z(() => {
        let c;
        const a = (c = t.value) == null ? void 0 : c.request.chainId;
        return Rn.find((u) => u.id === a);
      });
    Ut.onMessage((a) => "content" in a).then(async (a) => {
      a.content.action.method === "eth_requestAccounts" &&
        (e.value = a.content.action.params.metadata),
        (t.value = { id: a.id, type: "rpc-request", request: a.content });
    });
    const { inProgress: s, execute: o } = Ms(async (a) => {
        if (!t.value) throw new Error("No request to confirm");
        Ut.postMessage({
          requestId: t.value.id,
          id: crypto.randomUUID(),
          timestamp: new Date(),
          content: await a(),
        }),
          Ut.disconnect();
      }),
      i = () => {
        Ut.disconnect();
      };
    return {
      request: Z(() => t.value),
      requestType: n,
      responseInProgress: s,
      requestChain: r,
      respond: o,
      deny: i,
    };
  }),
  mp = { class: "h-full flex flex-col" },
  yp = { class: "flex justify-center items-center isolate mt-6" },
  bp = { class: "w-20 h-20 rounded-full bg-neutral-800" },
  gp = ["src", "alt"],
  wp = { class: "text-white text-center text-2xl mt-4 font-semibold" },
  vp = { class: "text-neutral-400 text-center mt-2" },
  xp = { class: "mt-6 text-neutral-300" },
  Ep = { class: "flex items-center gap-4 leading-tight my-4" },
  Pp = { class: "flex items-center gap-4 leading-tight my-4" },
  _p = { class: "flex items-center gap-4 leading-tight my-4" },
  $p = { class: "mt-auto flex gap-4" },
  Ap = ee({
    __name: "RequestAccounts",
    setup(e) {
      const { appMeta: t, origin: n } = $n(),
        { respond: r, deny: s } = Ue(),
        { responseInProgress: o } = Te(Ue()),
        { address: i } = Te(Qe()),
        a = Z(() => new URL(n.value).host),
        c = () => {
          r(() => ({ result: { value: [i.value] } }));
        };
      return (u, d) => {
        const l = Rs,
          f = jn;
        return (
          F(),
          j("div", mp, [
            R(l, { message: "Connecting with" }),
            N("div", yp, [
              R(
                A(Os),
                { address: A(i), class: "w-20 h-20 rounded-full -z-[1] -mr-4" },
                null,
                8,
                ["address"],
              ),
              N("div", bp, [
                A(t).appLogoUrl
                  ? (F(),
                    j(
                      "img",
                      {
                        key: 0,
                        src: A(t).appLogoUrl,
                        alt: A(t).appName,
                        class: "h-full w-full object-cover rounded-full",
                      },
                      null,
                      8,
                      gp,
                    ))
                  : ie("", !0),
              ]),
            ]),
            N("h1", wp, " Connect to " + ne(A(t).appName), 1),
            N("p", vp, ne(A(a)), 1),
            N("ul", xp, [
              N("li", Ep, [
                R(A(br), { class: "w-6 h-6 text-primary-300 shrink-0" }),
                le(" Let it see your address, balance and activity "),
              ]),
              N("li", Pp, [
                R(A(br), { class: "w-6 h-6 text-primary-300 shrink-0" }),
                le(" Let it send you requests for transactions "),
              ]),
              N("li", _p, [
                R(A(br), { class: "w-6 h-6 text-primary-300 shrink-0" }),
                le(
                  " Funds will not leave your account without your confirmation ",
                ),
              ]),
            ]),
            N("div", $p, [
              R(
                f,
                {
                  class: "w-full",
                  variant: "neutral",
                  onClick: d[0] || (d[0] = (p) => A(s)()),
                },
                { default: D(() => [le(" Cancel ")]), _: 1 },
              ),
              R(
                f,
                {
                  class: "w-full",
                  loading: !A(t) || A(o),
                  onClick: d[1] || (d[1] = (p) => c()),
                },
                { default: D(() => [le(" Connect ")]), _: 1 },
                8,
                ["loading"],
              ),
            ]),
          ])
        );
      };
    },
  }),
  Ip = ee({
    __name: "Line",
    props: { as: { type: [String, Object], default: "div" } },
    setup(e) {
      return (t, n) => (
        F(),
        J(
          Yr(e.as),
          { class: "line-container" },
          { default: D(() => [we(t.$slots, "default", {}, void 0, !0)]), _: 3 },
        )
      );
    },
  }),
  Ga = xe(Ip, [["__scopeId", "data-v-611f7e1d"]]),
  Bp = ee({
    __name: "Line",
    props: {
      as: { type: [String, Object], default: "button" },
      size: { type: String, default: "md" },
    },
    setup(e) {
      return (t, n) => {
        const r = Ga;
        return (
          F(),
          J(
            r,
            {
              is: e.as,
              class: Et(["line-button-container", [`size-${e.size}`]]),
            },
            {
              default: D(() => [we(t.$slots, "default", {}, void 0, !0)]),
              _: 3,
            },
            8,
            ["is", "class"],
          )
        );
      };
    },
  }),
  Ha = xe(Bp, [["__scopeId", "data-v-f255aa6b"]]),
  Cp = { class: "content-loader animate-pulse" },
  Tp = { key: 0 },
  kp = ee({
    __name: "ContentLoader",
    props: {
      length: { type: Number, default: 15 },
      rows: { type: Number, default: 1 },
    },
    setup(e) {
      return (t, n) => (
        F(),
        j("span", Cp, [
          (F(!0),
          j(
            it,
            null,
            Fn(
              e.rows,
              (r) => (
                F(),
                j("span", { key: r }, [
                  (F(!0),
                  j(
                    it,
                    null,
                    Fn(
                      e.length,
                      (s) => (F(), j(it, { key: s }, [le("")], 64)),
                    ),
                    128,
                  )),
                  r < e.rows ? (F(), j("br", Tp)) : ie("", !0),
                ])
              ),
            ),
            128,
          )),
        ])
      );
    },
  }),
  js = xe(kp, [["__scopeId", "data-v-9d72797f"]]),
  Sp = {},
  Np = { class: "button-line-body-info" },
  Fp = { key: 0, class: "button-line-body-info-label" },
  Lp = { key: 1, class: "button-line-body-info-secondary" },
  zp = { key: 2, class: "button-line-body-info-underline" };
function Mp(e, t) {
  return (
    F(),
    j("div", Np, [
      e.$slots.label
        ? (F(), j("div", Fp, [we(e.$slots, "label", {}, void 0, !0)]))
        : ie("", !0),
      e.$slots.secondary
        ? (F(), j("div", Lp, [we(e.$slots, "secondary", {}, void 0, !0)]))
        : ie("", !0),
      e.$slots.underline
        ? (F(), j("div", zp, [we(e.$slots, "underline", {}, void 0, !0)]))
        : ie("", !0),
    ])
  );
}
const Us = xe(Sp, [
    ["render", Mp],
    ["__scopeId", "data-v-2b771943"],
  ]),
  Op = { class: "line-button-with-img-image" },
  Rp = { class: "line-button-with-img-body" },
  jp = { key: 0, class: "line-button-with-img-right" },
  Up = ee({
    __name: "LineWithImg",
    props: {
      as: { type: [String, Object] },
      icon: { type: [Object, Function] },
      iconLoading: { type: Boolean, default: !1 },
      size: { type: String, default: "md" },
    },
    setup(e) {
      return (t, n) => {
        const r = js,
          s = Ha;
        return (
          F(),
          J(
            s,
            {
              as: e.as,
              size: e.size,
              class: Et(["line-button-with-img", [`size-${e.size}`]]),
            },
            {
              default: D(() => [
                N("div", Op, [we(t.$slots, "image", {}, void 0, !0)]),
                N("div", Rp, [we(t.$slots, "default", {}, void 0, !0)]),
                t.$slots.right
                  ? (F(), j("div", jp, [we(t.$slots, "right", {}, void 0, !0)]))
                  : ie("", !0),
                e.icon
                  ? (F(),
                    J(Yr(e.icon), {
                      key: 1,
                      class: "line-button-with-img-icon",
                      "aria-hidden": "true",
                    }))
                  : e.iconLoading
                    ? (F(),
                      J(r, {
                        key: 2,
                        length: 0,
                        class: "line-button-with-img-icon-loading",
                      }))
                    : ie("", !0),
              ]),
              _: 3,
            },
            8,
            ["as", "size", "class"],
          )
        );
      };
    },
  }),
  Va = xe(Up, [["__scopeId", "data-v-18eecc3b"]]),
  qp = ee({
    __name: "TokenAmountLoader",
    props: { sendRouteName: { type: Boolean, default: !1 } },
    setup(e) {
      return (t, n) => {
        const r = js,
          s = Us,
          o = Va;
        return (
          F(),
          J(
            o,
            { "icon-loading": "", as: "div", class: "token-balance-loader" },
            {
              image: D(() => [
                R(r, { length: 0, class: "token-balance-image-container" }),
              ]),
              default: D(() => [
                R(
                  s,
                  { class: "text-left" },
                  {
                    label: D(() => [R(r, { length: 10 })]),
                    underline: D(() => [R(r, { length: 28 })]),
                    _: 1,
                  },
                ),
              ]),
              right: D(() => [
                R(
                  s,
                  { class: "text-right" },
                  {
                    secondary: D(() => [R(r, { length: 20 })]),
                    underline: D(() => [R(r, { length: 20 })]),
                    _: 1,
                  },
                ),
              ]),
              _: 1,
            },
          )
        );
      };
    },
  }),
  Dp = xe(qp, [["__scopeId", "data-v-1602d60b"]]),
  Gp = { class: "image-loader-container" },
  Hp = { key: 0, class: "image-loader-placeholder" },
  Vp = ["src", "alt"],
  Zp = ee({
    __name: "ImageLoader",
    props: { src: { type: String }, alt: { type: String } },
    setup(e) {
      const t = e,
        { isReady: n, error: r } = t.src
          ? Lc({ src: t.src })
          : { isReady: Z(() => !0), error: Z(() => !0) };
      return (s, o) => {
        const i = js;
        return (
          F(),
          j("div", Gp, [
            R(
              So,
              {
                "leave-active-class": "transition ease-in duration-[50ms]",
                "leave-from-class": "opacity-100",
                "leave-to-class": "opacity-0",
              },
              {
                default: D(() => [
                  !A(n) || A(r) || !e.src
                    ? (F(),
                      j("div", Hp, [
                        we(
                          s.$slots,
                          "placeholder",
                          {},
                          () => [
                            R(i, { class: "image-loader-placeholder-default" }),
                          ],
                          !0,
                        ),
                      ]))
                    : ie("", !0),
                ]),
                _: 3,
              },
            ),
            e.src
              ? (F(),
                j(
                  "img",
                  {
                    key: 0,
                    class: Et([
                      "image-loader-image",
                      { loaded: A(n) && !A(r) },
                    ]),
                    src: e.src,
                    alt: e.alt,
                  },
                  null,
                  10,
                  Vp,
                ))
              : ie("", !0),
          ])
        );
      };
    },
  }),
  Wp = xe(Zp, [["__scopeId", "data-v-961b4a7c"]]),
  Kp = { class: "token-placeholder" },
  Yp = {
    key: 0,
    class: "no-icon-placeholder",
    viewBox: "0 0 100 100",
    preserveAspectRatio: "xMidYMid meet",
    "aria-hidden": "true",
  },
  Jp = {
    x: "50%",
    y: "55%",
    "dominant-baseline": "middle",
    "text-anchor": "middle",
    style: { fill: "currentColor", "font-size": "50px" },
  },
  Xp = ee({
    __name: "TokenImage",
    props: {
      symbol: { type: String, required: !0 },
      iconUrl: { type: String },
    },
    setup(e) {
      return (t, n) => {
        const r = Wp;
        return (
          F(),
          J(
            r,
            {
              src: e.iconUrl,
              alt: `${e.symbol} token icon`,
              class: "token-image-container",
            },
            {
              placeholder: D(() => [
                N("div", Kp, [
                  e.iconUrl
                    ? ie("", !0)
                    : (F(), j("svg", Yp, [N("text", Jp, ne(e.symbol[0]), 1)])),
                ]),
              ]),
              _: 1,
            },
            8,
            ["src", "alt"],
          )
        );
      };
    },
  }),
  Qp = xe(Xp, [["__scopeId", "data-v-27e39f31"]]),
  em = { class: "truncate" },
  tm = { class: "truncate" },
  nm = ee({
    __name: "TokenLine",
    props: {
      as: { type: [String, Object] },
      symbol: { type: String, required: !0 },
      name: { type: String },
      address: { type: String, required: !0 },
      decimals: { type: Number, required: !0 },
      iconUrl: { type: String },
      price: { type: [String, Number] },
    },
    setup(e) {
      return (t, n) => {
        const r = Qp,
          s = Us,
          o = Va;
        return (
          F(),
          J(
            o,
            { as: e.as },
            {
              image: D(() => [
                R(
                  r,
                  {
                    symbol: e.symbol,
                    address: e.address,
                    "icon-url": e.iconUrl,
                  },
                  null,
                  8,
                  ["symbol", "address", "icon-url"],
                ),
              ]),
              default: D(() => [
                R(
                  s,
                  { class: "text-left" },
                  nc(
                    { label: D(() => [N("div", em, ne(e.symbol), 1)]), _: 2 },
                    [
                      e.name
                        ? {
                            name: "underline",
                            fn: D(() => [N("div", tm, ne(e.name), 1)]),
                            key: "0",
                          }
                        : void 0,
                    ],
                  ),
                  1024,
                ),
              ]),
              right: D(() => [we(t.$slots, "right")]),
              _: 3,
            },
            8,
            ["as"],
          )
        );
      };
    },
  }),
  rm = ["title"],
  sm = { class: "token-balance-price" },
  om = ee({
    __name: "TokenAmount",
    props: {
      as: { type: [String, Object] },
      symbol: { type: String, required: !0 },
      name: { type: String },
      address: { type: String, required: !0 },
      decimals: { type: Number, required: !0 },
      iconUrl: { type: String },
      amount: { type: String, required: !0 },
      price: { type: [String, Number] },
      sendRouteName: { type: String },
    },
    setup(e) {
      const t = e,
        n = Z(() => !t.amount),
        r = Z(() => Ra(BigInt(t.amount), t.decimals)),
        s = Z(() => {
          if (t.price) return tp(BigInt(t.amount), t.decimals, t.price);
        });
      return (o, i) => {
        const a = Us,
          c = nm;
        return (
          F(),
          J(
            c,
            {
              symbol: e.symbol,
              name: e.name,
              address: e.address,
              decimals: e.decimals,
              "icon-url": e.iconUrl,
              as: e.sendRouteName ? "RouterLink" : e.as,
              to: e.sendRouteName
                ? { name: e.sendRouteName, query: { token: e.address } }
                : void 0,
              class: Et(["token-balance", { "is-zero-amount": A(n) }]),
            },
            {
              right: D(() => [
                R(
                  a,
                  { class: "text-right" },
                  {
                    secondary: D(() => [
                      N(
                        "div",
                        { class: "token-balance-amount", title: A(r) },
                        ne(A(r)),
                        9,
                        rm,
                      ),
                    ]),
                    underline: D(() => [
                      N("div", sm, [
                        !A(n) && A(s)
                          ? (F(), j(it, { key: 0 }, [le(ne(A(s)), 1)], 64))
                          : ie("", !0),
                      ]),
                    ]),
                    _: 1,
                  },
                ),
              ]),
              _: 1,
            },
            8,
            [
              "symbol",
              "name",
              "address",
              "decimals",
              "icon-url",
              "as",
              "to",
              "class",
            ],
          )
        );
      };
    },
  }),
  im = xe(om, [["__scopeId", "data-v-b05fccc4"]]),
  ko = "0x000000000000000000000000000000000000800A",
  am = { class: "h-full flex flex-col" },
  cm = { class: "w-14 h-14 rounded-full bg-neutral-800 mx-auto" },
  um = ["src", "alt"],
  lm = { class: "text-white text-center text-xl mt-2 font-semibold" },
  dm = {
    class:
      "text-neutral-300 text-center bg-neutral-900 mt-2 mx-auto w-max px-2 py-1 rounded-3xl justify-center",
  },
  fm = { class: "space-y-2 mt-4" },
  hm = N("div", { class: "font-medium" }, "Permissions", -1),
  pm = { class: "flex items-center gap-2 py-2" },
  mm = N("div", null, "Act on your behalf", -1),
  ym = { class: "flex items-center gap-2 py-2" },
  bm = N("div", { class: "font-medium" }, "Allowed spending", -1),
  gm = N("div", { class: "font-medium" }, "Total", -1),
  wm = N("div", { class: "border border-dashed border-neutral-800" }, null, -1),
  vm = { class: "mt-auto flex gap-4 pt-4" },
  xm = ee({
    __name: "RequestSession",
    props: { session: { type: Object, required: !0 } },
    setup(e) {
      const t = e,
        { appMeta: n, origin: r } = $n(),
        { respond: s, deny: o } = Ue(),
        { request: i, responseInProgress: a, requestChain: c } = Te(Ue()),
        { address: u } = Te(Qe()),
        { getWalletClient: d, createSessionKey: l } = Qe(),
        f = Z(() => new URL(r.value).host),
        p = jc(t.session.validUntil),
        {
          result: y,
          inProgress: h,
          execute: m,
        } = Ms(async () => {
          const v = async (x) => {
              try {
                const { result: _ } = await rc(
                    `${Dh[c.value.id]}?module=token&action=tokeninfo&contractaddress=${x}`,
                  ),
                  $ = _[0];
                return {
                  address: x,
                  name: $.tokenName,
                  symbol: $.symbol,
                  decimals: parseInt($.tokenDecimal),
                  price: parseFloat($.tokenPriceUSD),
                  iconUrl: $.iconURL,
                };
              } catch (_) {
                return (
                  console.error(`Failed to fetch token info for ${x}`, _),
                  {
                    address: x,
                    name: "Unknown",
                    symbol: "unknown",
                    decimals: 0,
                  }
                );
              }
            },
            P = Object.keys(t.session.spendLimit).map(async (x) => v(x));
          return (
            Object.keys(t.session.spendLimit).includes(ko) || P.push(v(ko)),
            Object.fromEntries(
              (await Promise.all(P)).map((x) => [x.address, x]),
            )
          );
        }),
        b = Z(() => {
          if (!(!t.session || !y.value))
            return Object.entries(t.session.spendLimit).map(([v, P]) => ({
              token: y.value[v],
              amount: P,
            }));
        }),
        g = Z(() =>
          (b.value || []).reduce((v, P) => {
            if (!P.token.price) return v;
            const x = lt(BigInt(P.amount), P.token.decimals);
            return v + parseFloat(x) * P.token.price;
          }, 0),
        ),
        w = async () => {
          s(async () => {
            const v = d({ chainId: i.value.request.chainId }),
              P = {
                address: u.value,
                chainId: v.chain.id,
                sessionKey: await l(),
                validUntil: t.session.validUntil,
                spendLimit: t.session.spendLimit
                  ? Object.fromEntries(
                      Object.entries(t.session.spendLimit).map(([_, $]) => [
                        Hn(_.toLowerCase()),
                        $.toString(),
                      ]),
                    )
                  : {},
              };
            return {
              result: {
                account: { address: P.address, session: P },
                chains: Rn.map((_) => ({
                  id: _.id,
                  name: _.name,
                  rpcUrl: _.rpcUrls.default.http[0],
                  capabilities: {
                    paymasterService: { supported: !0 },
                    atomicBatch: { supported: !0 },
                    auxiliaryFunds: { supported: !0 },
                  },
                  contracts: {
                    session: "0xa1cf087DB965Ab02Fb3CFaCe1f5c63935815f044",
                  },
                })),
              },
            };
          });
        };
      return (
        m(),
        (v, P) => {
          const x = Rs,
            _ = Ha,
            $ = Dp,
            k = im,
            B = Ga,
            T = jn;
          return (
            F(),
            j("div", am, [
              R(x, { message: "Connecting with" }),
              N("div", cm, [
                A(n).appLogoUrl
                  ? (F(),
                    j(
                      "img",
                      {
                        key: 0,
                        src: A(n).appLogoUrl,
                        alt: A(n).appName,
                        class: "h-full w-full object-cover rounded-full",
                      },
                      null,
                      8,
                      um,
                    ))
                  : ie("", !0),
              ]),
              N("h1", lm, " Authorize " + ne(A(n).appName), 1),
              N("p", dm, ne(A(f)), 1),
              N("div", fm, [
                hm,
                R(
                  _,
                  { size: "sm", as: "div" },
                  {
                    default: D(() => [
                      N("div", pm, [
                        R(A(sp), { class: "text-neutral-400 w-8 h-8" }),
                        mm,
                      ]),
                      N("div", ym, [
                        R(A(rp), { class: "text-neutral-400 w-8 h-8" }),
                        N("div", null, "Expires " + ne(A(p)), 1),
                      ]),
                    ]),
                    _: 1,
                  },
                ),
                bm,
                R(B, null, {
                  default: D(() => [
                    A(g) > 0
                      ? (F(),
                        j(
                          it,
                          { key: 0 },
                          [
                            R(
                              _,
                              {
                                as: "div",
                                size: "sm",
                                class: "flex justify-between",
                              },
                              {
                                default: D(() => [
                                  gm,
                                  N(
                                    "div",
                                    null,
                                    ne(
                                      ("formatPricePretty" in v
                                        ? v.formatPricePretty
                                        : A(ja))(A(g)),
                                    ),
                                    1,
                                  ),
                                ]),
                                _: 1,
                              },
                            ),
                            wm,
                          ],
                          64,
                        ))
                      : ie("", !0),
                    N("div", null, [
                      A(h)
                        ? (F(!0),
                          j(
                            it,
                            { key: 0 },
                            Fn(
                              Object.keys(t.session.spendLimit),
                              (L) => (F(), J($, { key: L })),
                            ),
                            128,
                          ))
                        : (F(!0),
                          j(
                            it,
                            { key: 1 },
                            Fn(
                              A(b),
                              (L) => (
                                F(),
                                J(
                                  k,
                                  {
                                    key: L.token.address,
                                    as: "div",
                                    size: "sm",
                                    symbol: L.token.symbol,
                                    decimals: L.token.decimals,
                                    address: L.token.address,
                                    price: L.token.price,
                                    "icon-url": L.token.iconUrl,
                                    amount: L.amount.toString(),
                                  },
                                  null,
                                  8,
                                  [
                                    "symbol",
                                    "decimals",
                                    "address",
                                    "price",
                                    "icon-url",
                                    "amount",
                                  ],
                                )
                              ),
                            ),
                            128,
                          )),
                    ]),
                  ]),
                  _: 1,
                }),
              ]),
              N("div", vm, [
                R(
                  T,
                  {
                    class: "w-full",
                    variant: "neutral",
                    onClick: P[0] || (P[0] = (L) => A(o)()),
                  },
                  { default: D(() => [le(" Cancel ")]), _: 1 },
                ),
                R(
                  T,
                  {
                    class: "w-full",
                    loading: !A(n) || A(a),
                    onClick: P[1] || (P[1] = (L) => w()),
                  },
                  { default: D(() => [le(" Connect ")]), _: 1 },
                  8,
                  ["loading"],
                ),
              ]),
            ])
          );
        }
      );
    },
  }),
  Em = ee({
    __name: "Connect",
    setup(e) {
      const { request: t } = Te(Ue()),
        n = Z(() => {
          let r;
          return (r = t.value) == null
            ? void 0
            : r.request.action.params.session;
        });
      return (r, s) => {
        const o = Ap,
          i = xm;
        return A(n)
          ? (F(), J(i, { key: 1, session: A(n) }, null, 8, ["session"]))
          : (F(), J(o, { key: 0 }));
      };
    },
  }),
  Pm = { class: "h-full flex flex-col" },
  _m = {
    class:
      "flex items-center justify-center text-white text-center text-3xl mt-6 font-semibold",
  },
  $m = ["title"],
  Am = { class: "w-8 h-8 rounded-full bg-neutral-800" },
  Im = ["src", "alt"],
  Bm = { class: "text-lg flex justify-between mt-12" },
  Cm = N("div", { class: "text-neutral-400" }, "Sending to", -1),
  Tm = { key: 0, class: "flex items-center" },
  km = { class: "font-medium" },
  Sm = { class: "text-lg flex justify-between mt-4" },
  Nm = N("div", { class: "text-neutral-400" }, "Fees", -1),
  Fm = { key: 0, class: "flex items-center" },
  Lm = { class: "w-5 h-5 rounded-full bg-neutral-800" },
  zm = ["src", "alt"],
  Mm = { class: "mt-auto flex gap-4" },
  Om = ee({
    __name: "Send",
    setup(e) {
      const { appMeta: t } = $n(),
        { respond: n, deny: r } = Ue(),
        { responseInProgress: s, request: o } = Te(Ue()),
        { getWalletClient: i } = Qe(),
        a = Z(() => {
          let p, y;
          const l = {
            amount: "0",
            token: { symbol: "ETH", decimals: 18, iconUrl: "/img/eth.svg" },
          };
          if (
            !o.value ||
            !(
              (y = (p = o.value.request.action) == null ? void 0 : p.params) !=
                null && y.length
            )
          )
            return l;
          const { value: f } = o.value.request.action.params[0];
          return f ? { amount: f, token: l.token } : l;
        }),
        c = Z(() => {
          let f, p, y;
          if (
            !(
              (y =
                (p = (f = o.value) == null ? void 0 : f.request.action) == null
                  ? void 0
                  : p.params) != null && y.length
            )
          )
            return null;
          const { to: l } = o.value.request.action.params[0];
          return l || null;
        }),
        u = Z(() => {
          let p, y, h;
          if (
            !(
              (h =
                (y = (p = o.value) == null ? void 0 : p.request.action) == null
                  ? void 0
                  : y.params) != null && h.length
            )
          )
            return null;
          const { gas: l, gasPrice: f } = o.value.request.action.params[0];
          return l && f ? BigInt(l) * BigInt(f) : null;
        }),
        d = async () => {
          n(async () => {
            const l = i({ chainId: o.value.request.chainId }),
              p = o.value.request.action.params[0];
            try {
              return {
                result: {
                  value: await l.sendTransaction({
                    gas: BigInt(p.gas),
                    gasPrice: BigInt(p.gasPrice),
                    to: p.to,
                    value: BigInt(p.value),
                  }),
                },
              };
            } catch (y) {
              return { failure: y };
            }
          });
        };
      return (l, f) => {
        const p = Rs,
          y = jn;
        return (
          F(),
          j("div", Pm, [
            R(p, { message: "Sending from" }),
            N("h2", _m, [
              N(
                "span",
                { title: A(lt)(BigInt(A(a).amount), A(a).token.decimals) },
                " -" +
                  ne(
                    ("formatAmount" in l ? l.formatAmount : A(Ra))(
                      BigInt(A(a).amount),
                      A(a).token.decimals,
                    ),
                  ),
                9,
                $m,
              ),
              N("span", null, "" + ne(A(a).token.symbol) + "", 1),
              N("div", Am, [
                A(a).token.iconUrl
                  ? (F(),
                    j(
                      "img",
                      {
                        key: 0,
                        src: A(a).token.iconUrl,
                        alt: A(a).token.symbol,
                        class: "h-full w-full object-cover rounded-full",
                      },
                      null,
                      8,
                      Im,
                    ))
                  : ie("", !0),
              ]),
            ]),
            N("div", Bm, [
              Cm,
              A(c)
                ? (F(),
                  j("div", Tm, [
                    R(
                      A(Os),
                      { address: A(c), class: "w-4 h-4 rounded-full" },
                      null,
                      8,
                      ["address"],
                    ),
                    N(
                      "span",
                      km,
                      "" +
                        ne(
                          ("shortenAddress" in l ? l.shortenAddress : A(Oa))(
                            A(c),
                          ),
                        ),
                      1,
                    ),
                  ]))
                : ie("", !0),
            ]),
            N("div", Sm, [
              Nm,
              A(u)
                ? (F(),
                  j("div", Fm, [
                    N("span", null, ne(A(lt)(A(u), 18)) + " ETH", 1),
                    N("div", Lm, [
                      A(a).token.iconUrl
                        ? (F(),
                          j(
                            "img",
                            {
                              key: 0,
                              src: A(a).token.iconUrl,
                              alt: A(a).token.symbol,
                              class: "h-full w-full object-cover rounded-full",
                            },
                            null,
                            8,
                            zm,
                          ))
                        : ie("", !0),
                    ]),
                  ]))
                : ie("", !0),
            ]),
            N("div", Mm, [
              R(
                y,
                {
                  class: "w-full",
                  variant: "neutral",
                  onClick: f[0] || (f[0] = (h) => A(r)()),
                },
                { default: D(() => [le(" Cancel ")]), _: 1 },
              ),
              R(
                y,
                {
                  class: "w-full",
                  loading: !A(t) || A(s),
                  onClick: f[1] || (f[1] = (h) => d()),
                },
                { default: D(() => [le(" Confirm ")]), _: 1 },
                8,
                ["loading"],
              ),
            ]),
          ])
        );
      };
    },
  }),
  Rm = ee({
    __name: "Confirmation",
    setup(e) {
      const { request: t } = Te(Ue());
      return (
        Z(() => {
          let n;
          return (n = t.value) == null ? void 0 : n.request.action.method;
        }),
        (n, r) => {
          const s = Om;
          return F(), J(s);
        }
      );
    },
  }),
  jm = { class: "flex items-center justify-center h-full" },
  Um = ee({
    __name: "confirm",
    setup(e) {
      const { appMeta: t } = $n(),
        { isLoggedIn: n } = Te(Qe()),
        { request: r, requestType: s } = Te(Ue());
      return (
        Ut.init(),
        (o, i) => {
          const a = Kh,
            c = ep,
            u = Em,
            d = Rm;
          return (
            F(),
            j("div", jm, [
              R(
                sc,
                No("TransitionOpacity" in o ? o.TransitionOpacity : A(jo), {
                  tag: "div",
                  mode: "out-in",
                  class:
                    "w-full h-full xs:max-w-[450px] xs:h-max bg-neutral-950 xs:rounded-[32px] p-4",
                }),
                {
                  default: D(() => [
                    A(n)
                      ? !A(t) || !A(r)
                        ? (F(), J(c, { key: "loading" }))
                        : A(s) === "handshake"
                          ? (F(), J(u, { key: "connect" }))
                          : (F(), J(d, { key: "confirmation" }))
                      : (F(), J(a, { key: "login" })),
                  ]),
                  _: 1,
                },
                16,
              ),
            ])
          );
        }
      );
    },
  }),
  Hm = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: Um },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  );
export {
  E as B,
  qt as H,
  Oe as a,
  ve as b,
  Xn as c,
  Vl as d,
  kt as e,
  Hm as f,
  as as g,
  ws as i,
  ae as s,
};
